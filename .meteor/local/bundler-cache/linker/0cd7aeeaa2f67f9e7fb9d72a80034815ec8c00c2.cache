[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\nvar $ = Package.jquery.$;\nvar jQuery = Package.jquery.jQuery;\n\n/* Package-scope variables */\nvar check, Match;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/check/match.js                                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// XXX docs                                                                                                          // 1\n                                                                                                                     // 2\n// Things we explicitly do NOT support:                                                                              // 3\n//    - heterogenous arrays                                                                                          // 4\n                                                                                                                     // 5\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;                                                         // 6\n                                                                                                                     // 7\n/**                                                                                                                  // 8\n * @summary Check that a value matches a [pattern](#matchpatterns).                                                  // 9\n * If the value does not match the pattern, throw a `Match.Error`.                                                   // 10\n *                                                                                                                   // 11\n * Particularly useful to assert that arguments to a function have the right                                         // 12\n * types and structure.                                                                                              // 13\n * @locus Anywhere                                                                                                   // 14\n * @param {Any} value The value to check                                                                             // 15\n * @param {MatchPattern} pattern The pattern to match                                                                // 16\n * `value` against                                                                                                   // 17\n */                                                                                                                  // 18\ncheck = function (value, pattern) {                                                                                  // 19\n  // Record that check got called, if somebody cared.                                                                // 20\n  //                                                                                                                 // 21\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()                                                  // 22\n  // from non-Fiber server contexts; the downside is that if you forget to                                           // 23\n  // bindEnvironment on some random callback in your method/publisher,                                               // 24\n  // it might not find the argumentChecker and you'll get an error about                                             // 25\n  // not checking an argument that it looks like you're checking (instead                                            // 26\n  // of just getting a \"Node code must run in a Fiber\" error).                                                       // 27\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();                                                 // 28\n  if (argChecker)                                                                                                    // 29\n    argChecker.checking(value);                                                                                      // 30\n  var result = testSubtree(value, pattern);                                                                          // 31\n  if (result) {                                                                                                      // 32\n    var err = new Match.Error(result.message);                                                                       // 33\n    if (result.path) {                                                                                               // 34\n      err.message += \" in field \" + result.path;                                                                     // 35\n      err.path = result.path;                                                                                        // 36\n    }                                                                                                                // 37\n    throw err;                                                                                                       // 38\n  }                                                                                                                  // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\n/**                                                                                                                  // 42\n * @namespace Match                                                                                                  // 43\n * @summary The namespace for all Match types and methods.                                                           // 44\n */                                                                                                                  // 45\nMatch = {                                                                                                            // 46\n  Optional: function (pattern) {                                                                                     // 47\n    return new Optional(pattern);                                                                                    // 48\n  },                                                                                                                 // 49\n  Maybe: function (pattern) {                                                                                        // 50\n    return new Maybe(pattern);                                                                                       // 51\n  },                                                                                                                 // 52\n  OneOf: function (/*arguments*/) {                                                                                  // 53\n    return new OneOf(_.toArray(arguments));                                                                          // 54\n  },                                                                                                                 // 55\n  Any: ['__any__'],                                                                                                  // 56\n  Where: function (condition) {                                                                                      // 57\n    return new Where(condition);                                                                                     // 58\n  },                                                                                                                 // 59\n  ObjectIncluding: function (pattern) {                                                                              // 60\n    return new ObjectIncluding(pattern);                                                                             // 61\n  },                                                                                                                 // 62\n  ObjectWithValues: function (pattern) {                                                                             // 63\n    return new ObjectWithValues(pattern);                                                                            // 64\n  },                                                                                                                 // 65\n  // Matches only signed 32-bit integers                                                                             // 66\n  Integer: ['__integer__'],                                                                                          // 67\n                                                                                                                     // 68\n  // XXX matchers should know how to describe themselves for errors                                                  // 69\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {                                                        // 70\n    this.message = \"Match error: \" + msg;                                                                            // 71\n    // The path of the value that failed to match. Initially empty, this gets                                        // 72\n    // populated by catching and rethrowing the exception as it goes back up the                                     // 73\n    // stack.                                                                                                        // 74\n    // E.g.: \"vals[3].entity.created\"                                                                                // 75\n    this.path = \"\";                                                                                                  // 76\n    // If this gets sent over DDP, don't give full internal details but at least                                     // 77\n    // provide something better than 500 Internal server error.                                                      // 78\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");                                                     // 79\n  }),                                                                                                                // 80\n                                                                                                                     // 81\n  // Tests to see if value matches pattern. Unlike check, it merely returns true                                     // 82\n  // or false (unless an error other than Match.Error was thrown). It does not                                       // 83\n  // interact with _failIfArgumentsAreNotAllChecked.                                                                 // 84\n  // XXX maybe also implement a Match.match which returns more information about                                     // 85\n  //     failures but without using exception handling or doing what check()                                         // 86\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion                                      // 87\n                                                                                                                     // 88\n  /**                                                                                                                // 89\n   * @summary Returns true if the value matches the pattern.                                                         // 90\n   * @locus Anywhere                                                                                                 // 91\n   * @param {Any} value The value to check                                                                           // 92\n   * @param {MatchPattern} pattern The pattern to match `value` against                                              // 93\n   */                                                                                                                // 94\n  test: function (value, pattern) {                                                                                  // 95\n    return !testSubtree(value, pattern);                                                                             // 96\n  },                                                                                                                 // 97\n                                                                                                                     // 98\n  // Runs `f.apply(context, args)`. If check() is not called on every element of                                     // 99\n  // `args` (either directly or in the first level of an array), throws an error                                     // 100\n  // (using `description` in the message).                                                                           // 101\n  //                                                                                                                 // 102\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {                                       // 103\n    var argChecker = new ArgumentChecker(args, description);                                                         // 104\n    var result = currentArgumentChecker.withValue(argChecker, function () {                                          // 105\n      return f.apply(context, args);                                                                                 // 106\n    });                                                                                                              // 107\n    // If f didn't itself throw, make sure it checked all of its arguments.                                          // 108\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();                                                             // 109\n    return result;                                                                                                   // 110\n  }                                                                                                                  // 111\n};                                                                                                                   // 112\n                                                                                                                     // 113\nvar Optional = function (pattern) {                                                                                  // 114\n  this.pattern = pattern;                                                                                            // 115\n};                                                                                                                   // 116\n                                                                                                                     // 117\nvar Maybe = Optional;                                                                                                // 118\n                                                                                                                     // 119\nvar OneOf = function (choices) {                                                                                     // 120\n  if (_.isEmpty(choices))                                                                                            // 121\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");                                              // 122\n  this.choices = choices;                                                                                            // 123\n};                                                                                                                   // 124\n                                                                                                                     // 125\nvar Where = function (condition) {                                                                                   // 126\n  this.condition = condition;                                                                                        // 127\n};                                                                                                                   // 128\n                                                                                                                     // 129\nvar ObjectIncluding = function (pattern) {                                                                           // 130\n  this.pattern = pattern;                                                                                            // 131\n};                                                                                                                   // 132\n                                                                                                                     // 133\nvar ObjectWithValues = function (pattern) {                                                                          // 134\n  this.pattern = pattern;                                                                                            // 135\n};                                                                                                                   // 136\n                                                                                                                     // 137\nvar typeofChecks = [                                                                                                 // 138\n  [String, \"string\"],                                                                                                // 139\n  [Number, \"number\"],                                                                                                // 140\n  [Boolean, \"boolean\"],                                                                                              // 141\n  // While we don't allow undefined in EJSON, this is good for optional                                              // 142\n  // arguments with OneOf.                                                                                           // 143\n  [undefined, \"undefined\"]                                                                                           // 144\n];                                                                                                                   // 145\n                                                                                                                     // 146\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.                    // 147\nvar testSubtree = function (value, pattern) {                                                                        // 148\n  // Match anything!                                                                                                 // 149\n  if (pattern === Match.Any)                                                                                         // 150\n    return false;                                                                                                    // 151\n                                                                                                                     // 152\n  // Basic atomic types.                                                                                             // 153\n  // Do not match boxed objects (e.g. String, Boolean)                                                               // 154\n  for (var i = 0; i < typeofChecks.length; ++i) {                                                                    // 155\n    if (pattern === typeofChecks[i][0]) {                                                                            // 156\n      if (typeof value === typeofChecks[i][1])                                                                       // 157\n        return false;                                                                                                // 158\n      return {                                                                                                       // 159\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + (value === null ? \"null\" : typeof value),             // 160\n        path: \"\"                                                                                                     // 161\n      };                                                                                                             // 162\n    }                                                                                                                // 163\n  }                                                                                                                  // 164\n  if (pattern === null) {                                                                                            // 165\n    if (value === null)                                                                                              // 166\n      return false;                                                                                                  // 167\n    return {                                                                                                         // 168\n      message: \"Expected null, got \" + EJSON.stringify(value),                                                       // 169\n      path: \"\"                                                                                                       // 170\n    };                                                                                                               // 171\n  }                                                                                                                  // 172\n                                                                                                                     // 173\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.                                     // 174\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {                  // 175\n    if (value === pattern)                                                                                           // 176\n      return false;                                                                                                  // 177\n    return {                                                                                                         // 178\n      message: \"Expected \" + pattern + \", got \" + EJSON.stringify(value),                                            // 179\n      path: \"\"                                                                                                       // 180\n    };                                                                                                               // 181\n  }                                                                                                                  // 182\n                                                                                                                     // 183\n  // Match.Integer is special type encoded with array                                                                // 184\n  if (pattern === Match.Integer) {                                                                                   // 185\n    // There is no consistent and reliable way to check if variable is a 64-bit                                      // 186\n    // integer. One of the popular solutions is to get reminder of division by 1                                     // 187\n    // but this method fails on really large floats with big precision.                                              // 188\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8                                                                   // 189\n    // Bitwise operators work consistantly but always cast variable to 32-bit                                        // 190\n    // signed integer according to JavaScript specs.                                                                 // 191\n    if (typeof value === \"number\" && (value | 0) === value)                                                          // 192\n      return false;                                                                                                  // 193\n    return {                                                                                                         // 194\n      message: \"Expected Integer, got \" + (value instanceof Object ? EJSON.stringify(value) : value),                // 195\n      path: \"\"                                                                                                       // 196\n    };                                                                                                               // 197\n  }                                                                                                                  // 198\n                                                                                                                     // 199\n  // \"Object\" is shorthand for Match.ObjectIncluding({});                                                            // 200\n  if (pattern === Object)                                                                                            // 201\n    pattern = Match.ObjectIncluding({});                                                                             // 202\n                                                                                                                     // 203\n  // Array (checked AFTER Any, which is implemented as an Array).                                                    // 204\n  if (pattern instanceof Array) {                                                                                    // 205\n    if (pattern.length !== 1) {                                                                                      // 206\n      return {                                                                                                       // 207\n        message: \"Bad pattern: arrays must have one type element\" + EJSON.stringify(pattern),                        // 208\n        path: \"\"                                                                                                     // 209\n      };                                                                                                             // 210\n    }                                                                                                                // 211\n    if (!_.isArray(value) && !_.isArguments(value)) {                                                                // 212\n      return {                                                                                                       // 213\n        message: \"Expected array, got \" + EJSON.stringify(value),                                                    // 214\n        path: \"\"                                                                                                     // 215\n      };                                                                                                             // 216\n    }                                                                                                                // 217\n                                                                                                                     // 218\n    for (var i = 0, length = value.length; i < length; i++) {                                                        // 219\n      var result = testSubtree(value[i], pattern[0]);                                                                // 220\n      if (result) {                                                                                                  // 221\n        result.path = _prependPath(i, result.path);                                                                  // 222\n        return result;                                                                                               // 223\n      }                                                                                                              // 224\n    }                                                                                                                // 225\n    return false;                                                                                                    // 226\n  }                                                                                                                  // 227\n                                                                                                                     // 228\n  // Arbitrary validation checks. The condition can return false or throw a                                          // 229\n  // Match.Error (ie, it can internally use check()) to fail.                                                        // 230\n  if (pattern instanceof Where) {                                                                                    // 231\n    var result;                                                                                                      // 232\n    try {                                                                                                            // 233\n      result = pattern.condition(value);                                                                             // 234\n    } catch (err) {                                                                                                  // 235\n      if (!(err instanceof Match.Error))                                                                             // 236\n        throw err;                                                                                                   // 237\n      return {                                                                                                       // 238\n        message: err.message,                                                                                        // 239\n        path: err.path                                                                                               // 240\n      };                                                                                                             // 241\n    }                                                                                                                // 242\n    if (result)                                                                                                      // 243\n      return false;                                                                                                  // 244\n    // XXX this error is terrible                                                                                    // 245\n    return {                                                                                                         // 246\n      message: \"Failed Match.Where validation\",                                                                      // 247\n      path: \"\"                                                                                                       // 248\n    };                                                                                                               // 249\n  }                                                                                                                  // 250\n                                                                                                                     // 251\n                                                                                                                     // 252\n  if (pattern instanceof Maybe) {                                                                                    // 253\n    pattern = Match.OneOf(undefined, null, pattern.pattern);                                                         // 254\n  }                                                                                                                  // 255\n  else if (pattern instanceof Optional) {                                                                            // 256\n    pattern = Match.OneOf(undefined, pattern.pattern);                                                               // 257\n  }                                                                                                                  // 258\n                                                                                                                     // 259\n  if (pattern instanceof OneOf) {                                                                                    // 260\n    for (var i = 0; i < pattern.choices.length; ++i) {                                                               // 261\n      var result = testSubtree(value, pattern.choices[i]);                                                           // 262\n      if (!result) {                                                                                                 // 263\n        // No error? Yay, return.                                                                                    // 264\n        return false;                                                                                                // 265\n      }                                                                                                              // 266\n      // Match errors just mean try another choice.                                                                  // 267\n    }                                                                                                                // 268\n    // XXX this error is terrible                                                                                    // 269\n    return {                                                                                                         // 270\n      message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",                                       // 271\n      path: \"\"                                                                                                       // 272\n    };                                                                                                               // 273\n  }                                                                                                                  // 274\n                                                                                                                     // 275\n  // A function that isn't something we special-case is assumed to be a                                              // 276\n  // constructor.                                                                                                    // 277\n  if (pattern instanceof Function) {                                                                                 // 278\n    if (value instanceof pattern)                                                                                    // 279\n      return false;                                                                                                  // 280\n    return {                                                                                                         // 281\n      message: \"Expected \" + (pattern.name ||\"particular constructor\"),                                              // 282\n      path: \"\"                                                                                                       // 283\n    };                                                                                                               // 284\n  }                                                                                                                  // 285\n                                                                                                                     // 286\n  var unknownKeysAllowed = false;                                                                                    // 287\n  var unknownKeyPattern;                                                                                             // 288\n  if (pattern instanceof ObjectIncluding) {                                                                          // 289\n    unknownKeysAllowed = true;                                                                                       // 290\n    pattern = pattern.pattern;                                                                                       // 291\n  }                                                                                                                  // 292\n  if (pattern instanceof ObjectWithValues) {                                                                         // 293\n    unknownKeysAllowed = true;                                                                                       // 294\n    unknownKeyPattern = [pattern.pattern];                                                                           // 295\n    pattern = {};  // no required keys                                                                               // 296\n  }                                                                                                                  // 297\n                                                                                                                     // 298\n  if (typeof pattern !== \"object\") {                                                                                 // 299\n    return {                                                                                                         // 300\n      message: \"Bad pattern: unknown pattern type\",                                                                  // 301\n      path: \"\"                                                                                                       // 302\n    };                                                                                                               // 303\n  }                                                                                                                  // 304\n                                                                                                                     // 305\n  // An object, with required and optional keys. Note that this does NOT do                                          // 306\n  // structural matches against objects of special types that happen to match                                        // 307\n  // the pattern: this really needs to be a plain old {Object}!                                                      // 308\n  if (typeof value !== 'object') {                                                                                   // 309\n    return {                                                                                                         // 310\n      message: \"Expected object, got \" + typeof value,                                                               // 311\n      path: \"\"                                                                                                       // 312\n    };                                                                                                               // 313\n  }                                                                                                                  // 314\n  if (value === null) {                                                                                              // 315\n    return {                                                                                                         // 316\n      message: \"Expected object, got null\",                                                                          // 317\n      path: \"\"                                                                                                       // 318\n    };                                                                                                               // 319\n  }                                                                                                                  // 320\n  if (! jQuery.isPlainObject(value)) {                                                                               // 321\n    return {                                                                                                         // 322\n      message: \"Expected plain object\",                                                                              // 323\n      path: \"\"                                                                                                       // 324\n    };                                                                                                               // 325\n  }                                                                                                                  // 326\n                                                                                                                     // 327\n  var requiredPatterns = {};                                                                                         // 328\n  var optionalPatterns = {};                                                                                         // 329\n  _.each(pattern, function (subPattern, key) {                                                                       // 330\n    if (subPattern instanceof Optional || subPattern instanceof Maybe)                                               // 331\n      optionalPatterns[key] = subPattern.pattern;                                                                    // 332\n    else                                                                                                             // 333\n      requiredPatterns[key] = subPattern;                                                                            // 334\n  });                                                                                                                // 335\n                                                                                                                     // 336\n  //XXX: replace with underscore's _.allKeys if Meteor updates underscore to 1.8+ (or lodash)                        // 337\n  var allKeys = function(obj){                                                                                       // 338\n    var keys = [];                                                                                                   // 339\n    if (_.isObject(obj)){                                                                                            // 340\n      for (var key in obj) keys.push(key);                                                                           // 341\n    }                                                                                                                // 342\n    return keys;                                                                                                     // 343\n  }                                                                                                                  // 344\n                                                                                                                     // 345\n  for (var keys = allKeys(value), i = 0, length = keys.length; i < length; i++) {                                    // 346\n    var key = keys[i];                                                                                               // 347\n    var subValue = value[key];                                                                                       // 348\n    if (_.has(requiredPatterns, key)) {                                                                              // 349\n      var result = testSubtree(subValue, requiredPatterns[key]);                                                     // 350\n      if (result) {                                                                                                  // 351\n        result.path = _prependPath(key, result.path);                                                                // 352\n        return result;                                                                                               // 353\n      }                                                                                                              // 354\n      delete requiredPatterns[key];                                                                                  // 355\n    } else if (_.has(optionalPatterns, key)) {                                                                       // 356\n      var result = testSubtree(subValue, optionalPatterns[key]);                                                     // 357\n      if (result) {                                                                                                  // 358\n        result.path = _prependPath(key, result.path);                                                                // 359\n        return result;                                                                                               // 360\n      }                                                                                                              // 361\n    } else {                                                                                                         // 362\n      if (!unknownKeysAllowed) {                                                                                     // 363\n        return {                                                                                                     // 364\n          message: \"Unknown key\",                                                                                    // 365\n          path: key                                                                                                  // 366\n        };                                                                                                           // 367\n      }                                                                                                              // 368\n      if (unknownKeyPattern) {                                                                                       // 369\n        var result = testSubtree(subValue, unknownKeyPattern[0]);                                                    // 370\n        if (result) {                                                                                                // 371\n          result.path = _prependPath(key, result.path);                                                              // 372\n          return result;                                                                                             // 373\n        }                                                                                                            // 374\n      }                                                                                                              // 375\n    }                                                                                                                // 376\n  }                                                                                                                  // 377\n                                                                                                                     // 378\n  var keys = _.keys(requiredPatterns);                                                                               // 379\n  if (keys.length) {                                                                                                 // 380\n    return {                                                                                                         // 381\n      message: \"Missing key '\" + keys[0] + \"'\",                                                                      // 382\n      path: \"\"                                                                                                       // 383\n    };                                                                                                               // 384\n  }                                                                                                                  // 385\n};                                                                                                                   // 386\n                                                                                                                     // 387\nvar ArgumentChecker = function (args, description) {                                                                 // 388\n  var self = this;                                                                                                   // 389\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks                                           // 390\n  // against its contents.)                                                                                          // 391\n  self.args = _.clone(args);                                                                                         // 392\n  // Since the common case will be to check arguments in order, and we splice                                        // 393\n  // out arguments when we check them, make it so we splice out from the end                                         // 394\n  // rather than the beginning.                                                                                      // 395\n  self.args.reverse();                                                                                               // 396\n  self.description = description;                                                                                    // 397\n};                                                                                                                   // 398\n                                                                                                                     // 399\n_.extend(ArgumentChecker.prototype, {                                                                                // 400\n  checking: function (value) {                                                                                       // 401\n    var self = this;                                                                                                 // 402\n    if (self._checkingOneValue(value))                                                                               // 403\n      return;                                                                                                        // 404\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])                                       // 405\n    // or check([foo, bar], [String]) to count... but only if value wasn't                                           // 406\n    // itself an argument.                                                                                           // 407\n    if (_.isArray(value) || _.isArguments(value)) {                                                                  // 408\n      _.each(value, _.bind(self._checkingOneValue, self));                                                           // 409\n    }                                                                                                                // 410\n  },                                                                                                                 // 411\n  _checkingOneValue: function (value) {                                                                              // 412\n    var self = this;                                                                                                 // 413\n    for (var i = 0; i < self.args.length; ++i) {                                                                     // 414\n      // Is this value one of the arguments? (This can have a false positive if                                      // 415\n      // the argument is an interned primitive, but it's still a good enough                                         // 416\n      // check.)                                                                                                     // 417\n      // (NaN is not === to itself, so we have to check specially.)                                                  // 418\n      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) {                                     // 419\n        self.args.splice(i, 1);                                                                                      // 420\n        return true;                                                                                                 // 421\n      }                                                                                                              // 422\n    }                                                                                                                // 423\n    return false;                                                                                                    // 424\n  },                                                                                                                 // 425\n  throwUnlessAllArgumentsHaveBeenChecked: function () {                                                              // 426\n    var self = this;                                                                                                 // 427\n    if (!_.isEmpty(self.args))                                                                                       // 428\n      throw new Error(\"Did not check() all arguments during \" +                                                      // 429\n                      self.description);                                                                             // 430\n  }                                                                                                                  // 431\n});                                                                                                                  // 432\n                                                                                                                     // 433\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",                                      // 434\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",                                           // 435\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",                                            // 436\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",                                              // 437\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",                                       // 438\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",                                       // 439\n  \"instanceof\"];                                                                                                     // 440\n                                                                                                                     // 441\n// Assumes the base of path is already escaped properly                                                              // 442\n// returns key + base                                                                                                // 443\nvar _prependPath = function (key, base) {                                                                            // 444\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))                                                            // 445\n    key = \"[\" + key + \"]\";                                                                                           // 446\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))                                      // 447\n    key = JSON.stringify([key]);                                                                                     // 448\n                                                                                                                     // 449\n  if (base && base[0] !== \"[\")                                                                                       // 450\n    return key + '.' + base;                                                                                         // 451\n  return key + base;                                                                                                 // 452\n};                                                                                                                   // 453\n                                                                                                                     // 454\n                                                                                                                     // 455\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.check = {}, {\n  check: check,\n  Match: Match\n});\n\n})();\n","servePath":"/packages/check.js"}]