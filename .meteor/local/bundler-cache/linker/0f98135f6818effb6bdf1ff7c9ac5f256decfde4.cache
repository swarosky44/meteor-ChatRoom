[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar meteorBabelHelpers;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"babel-runtime\":{\"babel-runtime.js\":[\"regenerator/runtime-module\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/babel-runtime/babel-runtime.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                              // 1\nvar S = typeof Symbol === \"function\" ? Symbol : {};                                                        // 2\nvar iteratorSymbol = S.iterator || \"@@iterator\";                                                           // 3\n                                                                                                           // 4\nfunction canDefineNonEnumerableProperties() {                                                              // 5\n  var testObj = {};                                                                                        // 6\n  var testPropName = \"t\";                                                                                  // 7\n                                                                                                           // 8\n  try {                                                                                                    // 9\n    Object.defineProperty(testObj, testPropName, {                                                         // 10\n      enumerable: false,                                                                                   // 11\n      value: testObj                                                                                       // 12\n    });                                                                                                    // 13\n                                                                                                           // 14\n    for (var k in testObj) {                                                                               // 15\n      if (k === testPropName) {                                                                            // 16\n        return false;                                                                                      // 17\n      }                                                                                                    // 18\n    }                                                                                                      // 19\n  } catch (e) {                                                                                            // 20\n    return false;                                                                                          // 21\n  }                                                                                                        // 22\n                                                                                                           // 23\n  return testObj[testPropName] === testObj;                                                                // 24\n}                                                                                                          // 25\n                                                                                                           // 26\nmeteorBabelHelpers = {                                                                                     // 27\n  // Meteor-specific runtime helper for wrapping the object of for-in                                      // 28\n  // loops, so that inherited Array methods defined by es5-shim can be                                     // 29\n  // ignored in browsers where they cannot be defined as non-enumerable.                                   // 30\n  sanitizeForInObject: canDefineNonEnumerableProperties()                                                  // 31\n    ? function (value) { return value; }                                                                   // 32\n    : function (obj) {                                                                                     // 33\n      if (Array.isArray(obj)) {                                                                            // 34\n        var newObj = {};                                                                                   // 35\n        var keys = Object.keys(obj);                                                                       // 36\n        var keyCount = keys.length;                                                                        // 37\n        for (var i = 0; i < keyCount; ++i) {                                                               // 38\n          var key = keys[i];                                                                               // 39\n          newObj[key] = obj[key];                                                                          // 40\n        }                                                                                                  // 41\n        return newObj;                                                                                     // 42\n      }                                                                                                    // 43\n                                                                                                           // 44\n      return obj;                                                                                          // 45\n    }                                                                                                      // 46\n};                                                                                                         // 47\n                                                                                                           // 48\nvar BabelRuntime = {                                                                                       // 49\n  // es6.templateLiterals                                                                                  // 50\n  // Constructs the object passed to the tag function in a tagged                                          // 51\n  // template literal.                                                                                     // 52\n  taggedTemplateLiteralLoose: function (strings, raw) {                                                    // 53\n    // Babel's own version of this calls Object.freeze on `strings` and                                    // 54\n    // `strings.raw`, but it doesn't seem worth the compatibility and                                      // 55\n    // performance concerns.  If you're writing code against this helper,                                  // 56\n    // don't add properties to these objects.                                                              // 57\n    strings.raw = raw;                                                                                     // 58\n    return strings;                                                                                        // 59\n  },                                                                                                       // 60\n                                                                                                           // 61\n  // es6.classes                                                                                           // 62\n  // Checks that a class constructor is being called with `new`, and throws                                // 63\n  // an error if it is not.                                                                                // 64\n  classCallCheck: function (instance, Constructor) {                                                       // 65\n    if (!(instance instanceof Constructor)) {                                                              // 66\n      throw new TypeError(\"Cannot call a class as a function\");                                            // 67\n    }                                                                                                      // 68\n  },                                                                                                       // 69\n                                                                                                           // 70\n  // es6.classes                                                                                           // 71\n  inherits: function (subClass, superClass) {                                                              // 72\n    if (typeof superClass !== \"function\" && superClass !== null) {                                         // 73\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }                                                                                                      // 75\n                                                                                                           // 76\n    if (superClass) {                                                                                      // 77\n      if (Object.create) {                                                                                 // 78\n        // All but IE 8                                                                                    // 79\n        subClass.prototype = Object.create(superClass.prototype, {                                         // 80\n          constructor: {                                                                                   // 81\n            value: subClass,                                                                               // 82\n            enumerable: false,                                                                             // 83\n            writable: true,                                                                                // 84\n            configurable: true                                                                             // 85\n          }                                                                                                // 86\n        });                                                                                                // 87\n      } else {                                                                                             // 88\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`                           // 89\n        // is enumerable and shows up in the inspector unnecessarily.                                      // 90\n        // It's not an \"own\" property of any instance though.                                              // 91\n        //                                                                                                 // 92\n        // For correctness when writing code,                                                              // 93\n        // don't enumerate all the own-and-inherited properties of an instance                             // 94\n        // of a class and expect not to find `constructor` (but who does that?).                           // 95\n        var F = function () {                                                                              // 96\n          this.constructor = subClass;                                                                     // 97\n        };                                                                                                 // 98\n        F.prototype = superClass.prototype;                                                                // 99\n        subClass.prototype = new F();                                                                      // 100\n      }                                                                                                    // 101\n                                                                                                           // 102\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,                             // 103\n      // but IE <=10 don't support `__proto__`, and in this case the difference                            // 104\n      // would be detectable; code that works in modern browsers could easily                              // 105\n      // fail on IE 8 if we ever used the `__proto__` trick.                                               // 106\n      //                                                                                                   // 107\n      // There's no perfect way to make static methods inherited if they are                               // 108\n      // assigned after declaration of the classes.  The best we can do is                                 // 109\n      // to copy them.  In other words, when you write `class Foo                                          // 110\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future                            // 111\n      // ones are not copied.                                                                              // 112\n      //                                                                                                   // 113\n      // For correctness when writing code, don't add static methods to a class                            // 114\n      // after you subclass it.                                                                            // 115\n                                                                                                           // 116\n      // The ecmascript-runtime package provides adequate polyfills for                                    // 117\n      // all of these Object.* functions (and Array#forEach), and anyone                                   // 118\n      // using babel-runtime is almost certainly using it because of the                                   // 119\n      // ecmascript package, which also implies ecmascript-runtime.                                        // 120\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {                                        // 121\n        // This property descriptor dance preserves getter/setter behavior                                 // 122\n        // in browsers that support accessor properties (all except                                        // 123\n        // IE8). In IE8, the superClass can't have accessor properties                                     // 124\n        // anyway, so this code is still safe.                                                             // 125\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);                                   // 126\n        if (descriptor && typeof descriptor === \"object\") {                                                // 127\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {                                              // 128\n            // If subClass already has a property by this name, then it                                    // 129\n            // would not be inherited, so it should not be copied. This                                    // 130\n            // notably excludes properties like .prototype and .name.                                      // 131\n            return;                                                                                        // 132\n          }                                                                                                // 133\n                                                                                                           // 134\n          Object.defineProperty(subClass, k, descriptor);                                                  // 135\n        }                                                                                                  // 136\n      });                                                                                                  // 137\n    }                                                                                                      // 138\n  },                                                                                                       // 139\n                                                                                                           // 140\n  createClass: (function () {                                                                              // 141\n    var hasDefineProperty = false;                                                                         // 142\n    try {                                                                                                  // 143\n      // IE 8 has a broken Object.defineProperty, so feature-test by                                       // 144\n      // trying to call it.                                                                                // 145\n      Object.defineProperty({}, 'x', {});                                                                  // 146\n      hasDefineProperty = true;                                                                            // 147\n    } catch (e) {}                                                                                         // 148\n                                                                                                           // 149\n    function defineProperties(target, props) {                                                             // 150\n      for (var i = 0; i < props.length; i++) {                                                             // 151\n        var descriptor = props[i];                                                                         // 152\n        descriptor.enumerable = descriptor.enumerable || false;                                            // 153\n        descriptor.configurable = true;                                                                    // 154\n        if (\"value\" in descriptor) descriptor.writable = true;                                             // 155\n        Object.defineProperty(target, descriptor.key, descriptor);                                         // 156\n      }                                                                                                    // 157\n    }                                                                                                      // 158\n                                                                                                           // 159\n    return function (Constructor, protoProps, staticProps) {                                               // 160\n      if (! hasDefineProperty) {                                                                           // 161\n        // e.g. `class Foo { get bar() {} }`.  If you try to use getters and                               // 162\n        // setters in IE 8, you will get a big nasty error, with or without                                // 163\n        // Babel.  I don't know of any other syntax features besides getters                               // 164\n        // and setters that will trigger this error.                                                       // 165\n        throw new Error(                                                                                   // 166\n          \"Your browser does not support this type of class property.  \" +                                 // 167\n            \"For example, Internet Explorer 8 does not support getters and \" +                             // 168\n            \"setters.\");                                                                                   // 169\n      }                                                                                                    // 170\n                                                                                                           // 171\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);                                 // 172\n      if (staticProps) defineProperties(Constructor, staticProps);                                         // 173\n      return Constructor;                                                                                  // 174\n    };                                                                                                     // 175\n  })(),                                                                                                    // 176\n                                                                                                           // 177\n  \"typeof\": function (obj) {                                                                               // 178\n    return obj && obj.constructor === Symbol ? \"symbol\" : typeof obj;                                      // 179\n  },                                                                                                       // 180\n                                                                                                           // 181\n  possibleConstructorReturn: function (self, call) {                                                       // 182\n    if (! self) {                                                                                          // 183\n      throw new ReferenceError(                                                                            // 184\n        \"this hasn't been initialised - super() hasn't been called\"                                        // 185\n      );                                                                                                   // 186\n    }                                                                                                      // 187\n                                                                                                           // 188\n    var callType = typeof call;                                                                            // 189\n    if (call &&                                                                                            // 190\n        callType === \"function\" ||                                                                         // 191\n        callType === \"object\") {                                                                           // 192\n      return call;                                                                                         // 193\n    }                                                                                                      // 194\n                                                                                                           // 195\n    return self;                                                                                           // 196\n  },                                                                                                       // 197\n                                                                                                           // 198\n  interopRequireDefault: function (obj) {                                                                  // 199\n    return obj && obj.__esModule ? obj : { 'default': obj };                                               // 200\n  },                                                                                                       // 201\n                                                                                                           // 202\n  interopRequireWildcard: function (obj) {                                                                 // 203\n    if (obj && obj.__esModule) {                                                                           // 204\n      return obj;                                                                                          // 205\n    }                                                                                                      // 206\n                                                                                                           // 207\n    var newObj = {};                                                                                       // 208\n                                                                                                           // 209\n    if (obj != null) {                                                                                     // 210\n      for (var key in obj) {                                                                               // 211\n        if (hasOwn.call(obj, key)) {                                                                       // 212\n          newObj[key] = obj[key];                                                                          // 213\n        }                                                                                                  // 214\n      }                                                                                                    // 215\n    }                                                                                                      // 216\n                                                                                                           // 217\n    newObj[\"default\"] = obj;                                                                               // 218\n    return newObj;                                                                                         // 219\n  },                                                                                                       // 220\n                                                                                                           // 221\n  interopExportWildcard: function (obj, defaults) {                                                        // 222\n    var newObj = defaults({}, obj);                                                                        // 223\n    delete newObj[\"default\"];                                                                              // 224\n    return newObj;                                                                                         // 225\n  },                                                                                                       // 226\n                                                                                                           // 227\n  defaults: function (obj, defaults) {                                                                     // 228\n    Object.getOwnPropertyNames(defaults).forEach(function (key) {                                          // 229\n      var desc = Object.getOwnPropertyDescriptor(defaults, key);                                           // 230\n      if (desc && desc.configurable && typeof obj[key] === \"undefined\") {                                  // 231\n        Object.defineProperty(obj, key, desc);                                                             // 232\n      }                                                                                                    // 233\n    });                                                                                                    // 234\n                                                                                                           // 235\n    return obj;                                                                                            // 236\n  },                                                                                                       // 237\n                                                                                                           // 238\n  // es7.objectRestSpread and react (JSX)                                                                  // 239\n  \"extends\": Object.assign || (function (target) {                                                         // 240\n    for (var i = 1; i < arguments.length; i++) {                                                           // 241\n      var source = arguments[i];                                                                           // 242\n      for (var key in source) {                                                                            // 243\n        if (hasOwn.call(source, key)) {                                                                    // 244\n          target[key] = source[key];                                                                       // 245\n        }                                                                                                  // 246\n      }                                                                                                    // 247\n    }                                                                                                      // 248\n    return target;                                                                                         // 249\n  }),                                                                                                      // 250\n                                                                                                           // 251\n  // es6.destructuring                                                                                     // 252\n  objectWithoutProperties: function (obj, keys) {                                                          // 253\n    var target = {};                                                                                       // 254\n    outer: for (var i in obj) {                                                                            // 255\n      if (! hasOwn.call(obj, i)) continue;                                                                 // 256\n      for (var j = 0; j < keys.length; j++) {                                                              // 257\n        if (keys[j] === i) continue outer;                                                                 // 258\n      }                                                                                                    // 259\n      target[i] = obj[i];                                                                                  // 260\n    }                                                                                                      // 261\n    return target;                                                                                         // 262\n  },                                                                                                       // 263\n                                                                                                           // 264\n  // es6.destructuring                                                                                     // 265\n  objectDestructuringEmpty: function (obj) {                                                               // 266\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");                                  // 267\n  },                                                                                                       // 268\n                                                                                                           // 269\n  // es6.spread                                                                                            // 270\n  bind: Function.prototype.bind || (function () {                                                          // 271\n    var isCallable = function (value) { return typeof value === 'function'; };                             // 272\n    var $Object = Object;                                                                                  // 273\n    var to_string = Object.prototype.toString;                                                             // 274\n    var array_slice = Array.prototype.slice;                                                               // 275\n    var array_concat = Array.prototype.concat;                                                             // 276\n    var array_push = Array.prototype.push;                                                                 // 277\n    var max = Math.max;                                                                                    // 278\n    var Empty = function Empty() {};                                                                       // 279\n                                                                                                           // 280\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.                                 // 281\n    return function bind(that) {                                                                           // 282\n      var target = this;                                                                                   // 283\n      if (!isCallable(target)) {                                                                           // 284\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);                   // 285\n      }                                                                                                    // 286\n                                                                                                           // 287\n      var args = array_slice.call(arguments, 1);                                                           // 288\n                                                                                                           // 289\n      var bound;                                                                                           // 290\n      var binder = function () {                                                                           // 291\n                                                                                                           // 292\n        if (this instanceof bound) {                                                                       // 293\n          var result = target.apply(                                                                       // 294\n            this,                                                                                          // 295\n            array_concat.call(args, array_slice.call(arguments))                                           // 296\n          );                                                                                               // 297\n          if ($Object(result) === result) {                                                                // 298\n            return result;                                                                                 // 299\n          }                                                                                                // 300\n          return this;                                                                                     // 301\n        } else {                                                                                           // 302\n          return target.apply(                                                                             // 303\n            that,                                                                                          // 304\n            array_concat.call(args, array_slice.call(arguments))                                           // 305\n          );                                                                                               // 306\n        }                                                                                                  // 307\n      };                                                                                                   // 308\n                                                                                                           // 309\n      var boundLength = max(0, target.length - args.length);                                               // 310\n                                                                                                           // 311\n      var boundArgs = [];                                                                                  // 312\n      for (var i = 0; i < boundLength; i++) {                                                              // 313\n        array_push.call(boundArgs, '$' + i);                                                               // 314\n      }                                                                                                    // 315\n                                                                                                           // 316\n      // Create a Function from source code so that it has the right `.length`.                            // 317\n      // Probably not important for Babel.  This code violates CSPs that ban                               // 318\n      // `eval`, but the browsers that need this polyfill don't have CSP!                                  // 319\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n                                                                                                           // 321\n      if (target.prototype) {                                                                              // 322\n        Empty.prototype = target.prototype;                                                                // 323\n        bound.prototype = new Empty();                                                                     // 324\n        Empty.prototype = null;                                                                            // 325\n      }                                                                                                    // 326\n                                                                                                           // 327\n      return bound;                                                                                        // 328\n    };                                                                                                     // 329\n                                                                                                           // 330\n  })(),                                                                                                    // 331\n                                                                                                           // 332\n  toConsumableArray: function (arr) {                                                                      // 333\n    if (Array.isArray(arr)) {                                                                              // 334\n      for (var i = arr.length - 1, arr2 = Array(i + 1); i >= 0; --i) {                                     // 335\n        arr2[i] = arr[i];                                                                                  // 336\n      }                                                                                                    // 337\n                                                                                                           // 338\n      return arr2;                                                                                         // 339\n    }                                                                                                      // 340\n                                                                                                           // 341\n    return Array.from(arr);                                                                                // 342\n  },                                                                                                       // 343\n                                                                                                           // 344\n  toArray: function (arr) {                                                                                // 345\n    return Array.isArray(arr) ? arr : Array.from(arr);                                                     // 346\n  },                                                                                                       // 347\n                                                                                                           // 348\n  slicedToArray: function (iterable, limit) {                                                              // 349\n    if (Array.isArray(iterable)) {                                                                         // 350\n      return iterable;                                                                                     // 351\n    }                                                                                                      // 352\n                                                                                                           // 353\n    if (iterable) {                                                                                        // 354\n      var it = iterable[iteratorSymbol]();                                                                 // 355\n      var result = [];                                                                                     // 356\n      var info;                                                                                            // 357\n                                                                                                           // 358\n      if (typeof limit !== \"number\") {                                                                     // 359\n        limit = Infinity;                                                                                  // 360\n      }                                                                                                    // 361\n                                                                                                           // 362\n      while (result.length < limit &&                                                                      // 363\n             ! (info = it.next()).done) {                                                                  // 364\n        result.push(info.value);                                                                           // 365\n      }                                                                                                    // 366\n                                                                                                           // 367\n      return result;                                                                                       // 368\n    }                                                                                                      // 369\n                                                                                                           // 370\n    throw new TypeError(                                                                                   // 371\n      \"Invalid attempt to destructure non-iterable instance\"                                               // 372\n    );                                                                                                     // 373\n  },                                                                                                       // 374\n                                                                                                           // 375\n  slice: Array.prototype.slice                                                                             // 376\n};                                                                                                         // 377\n                                                                                                           // 378\n// Use meteorInstall to install all of the above helper functions within                                   // 379\n// node_modules/babel-runtime/helpers.                                                                     // 380\nObject.keys(BabelRuntime).forEach(function (helperName) {                                                  // 381\n  var helpers = {};                                                                                        // 382\n                                                                                                           // 383\n  helpers[helperName + \".js\"] = function (require, exports, module) {                                      // 384\n    module.exports = BabelRuntime[helperName];                                                             // 385\n  };                                                                                                       // 386\n                                                                                                           // 387\n  meteorInstall({                                                                                          // 388\n    node_modules: {                                                                                        // 389\n      \"babel-runtime\": {                                                                                   // 390\n        helpers: helpers                                                                                   // 391\n      }                                                                                                    // 392\n    }                                                                                                      // 393\n  });                                                                                                      // 394\n});                                                                                                        // 395\n                                                                                                           // 396\n// Use meteorInstall to install the regenerator runtime at                                                 // 397\n// node_modules/babel-runtime/regenerator.                                                                 // 398\nmeteorInstall({                                                                                            // 399\n  node_modules: {                                                                                          // 400\n    \"babel-runtime\": {                                                                                     // 401\n      \"regenerator.js\": function (r, e, module) {                                                          // 402\n        // Note that we use the require function provided to the                                           // 403\n        // babel-runtime.js file, not the one named 'r' above.                                             // 404\n        var runtime = require(\"regenerator/runtime-module\");                                               // 405\n                                                                                                           // 406\n        // If Promise.asyncApply is defined, use it to wrap calls to                                       // 407\n        // runtime.async so that the entire async function will run in its                                 // 408\n        // own Fiber, not just the code that comes after the first await.                                  // 409\n        if (typeof Promise === \"function\" &&                                                               // 410\n            typeof Promise.asyncApply === \"function\") {                                                    // 411\n          var realAsync = runtime.async;                                                                   // 412\n          runtime.async = function () {                                                                    // 413\n            return Promise.asyncApply(realAsync, runtime, arguments);                                      // 414\n          };                                                                                               // 415\n        }                                                                                                  // 416\n                                                                                                           // 417\n        module.exports = runtime;                                                                          // 418\n      }                                                                                                    // 419\n    }                                                                                                      // 420\n  }                                                                                                        // 421\n});                                                                                                        // 422\n                                                                                                           // 423\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"regenerator\":{\"runtime-module.js\":[\"./runtime\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator/runtime-module.js                            //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// This method of obtaining a reference to the global object needs to be                                   // 1\n// kept identical to the way it is obtained in runtime.js                                                  // 2\nvar g =                                                                                                    // 3\n  typeof global === \"object\" ? global :                                                                    // 4\n  typeof window === \"object\" ? window :                                                                    // 5\n  typeof self === \"object\" ? self : this;                                                                  // 6\n                                                                                                           // 7\n// Use `getOwnPropertyNames` because not all browsers support calling                                      // 8\n// `hasOwnProperty` on the global `self` object in a worker. See #183.                                     // 9\nvar hadRuntime = g.regeneratorRuntime &&                                                                   // 10\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;                                        // 11\n                                                                                                           // 12\n// Save the old regeneratorRuntime in case it needs to be restored later.                                  // 13\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;                                                       // 14\n                                                                                                           // 15\n// Force reevalutation of runtime.js.                                                                      // 16\ng.regeneratorRuntime = undefined;                                                                          // 17\n                                                                                                           // 18\nmodule.exports = require(\"./runtime\");                                                                     // 19\n                                                                                                           // 20\nif (hadRuntime) {                                                                                          // 21\n  // Restore the original runtime.                                                                         // 22\n  g.regeneratorRuntime = oldRuntime;                                                                       // 23\n} else {                                                                                                   // 24\n  // Remove the global property added by runtime.js.                                                       // 25\n  try {                                                                                                    // 26\n    delete g.regeneratorRuntime;                                                                           // 27\n  } catch(e) {                                                                                             // 28\n    g.regeneratorRuntime = undefined;                                                                      // 29\n  }                                                                                                        // 30\n}                                                                                                          // 31\n                                                                                                           // 32\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"runtime.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator/runtime.js                                   //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n/**                                                                                                        // 1\n * Copyright (c) 2014, Facebook, Inc.                                                                      // 2\n * All rights reserved.                                                                                    // 3\n *                                                                                                         // 4\n * This source code is licensed under the BSD-style license found in the                                   // 5\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An                                     // 6\n * additional grant of patent rights can be found in the PATENTS file in                                   // 7\n * the same directory.                                                                                     // 8\n */                                                                                                        // 9\n                                                                                                           // 10\n!(function(global) {                                                                                       // 11\n  \"use strict\";                                                                                            // 12\n                                                                                                           // 13\n  var hasOwn = Object.prototype.hasOwnProperty;                                                            // 14\n  var undefined; // More compressible than void 0.                                                         // 15\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};                                                // 16\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";                                                   // 17\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";                                          // 18\n                                                                                                           // 19\n  var inModule = typeof module === \"object\";                                                               // 20\n  var runtime = global.regeneratorRuntime;                                                                 // 21\n  if (runtime) {                                                                                           // 22\n    if (inModule) {                                                                                        // 23\n      // If regeneratorRuntime is defined globally and we're in a module,                                  // 24\n      // make the exports object identical to regeneratorRuntime.                                          // 25\n      module.exports = runtime;                                                                            // 26\n    }                                                                                                      // 27\n    // Don't bother evaluating the rest of this file if the runtime was                                    // 28\n    // already defined globally.                                                                           // 29\n    return;                                                                                                // 30\n  }                                                                                                        // 31\n                                                                                                           // 32\n  // Define the runtime globally (as expected by generated code) as either                                 // 33\n  // module.exports (if we're in a module) or a new, empty object.                                         // 34\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};                                    // 35\n                                                                                                           // 36\n  function wrap(innerFn, outerFn, self, tryLocsList) {                                                     // 37\n    // If outerFn provided, then outerFn.prototype instanceof Generator.                                   // 38\n    var generator = Object.create((outerFn || Generator).prototype);                                       // 39\n    var context = new Context(tryLocsList || []);                                                          // 40\n                                                                                                           // 41\n    // The ._invoke method unifies the implementations of the .next,                                       // 42\n    // .throw, and .return methods.                                                                        // 43\n    generator._invoke = makeInvokeMethod(innerFn, self, context);                                          // 44\n                                                                                                           // 45\n    return generator;                                                                                      // 46\n  }                                                                                                        // 47\n  runtime.wrap = wrap;                                                                                     // 48\n                                                                                                           // 49\n  // Try/catch helper to minimize deoptimizations. Returns a completion                                    // 50\n  // record like context.tryEntries[i].completion. This interface could                                    // 51\n  // have been (and was previously) designed to take a closure to be                                       // 52\n  // invoked without arguments, but in all the cases we care about we                                      // 53\n  // already have an existing method we want to call, so there's no need                                   // 54\n  // to create a new function object. We can even get away with assuming                                   // 55\n  // the method takes exactly one argument, since that happens to be true                                  // 56\n  // in every case, so we don't have to touch the arguments object. The                                    // 57\n  // only additional allocation required is the completion record, which                                   // 58\n  // has a stable shape and so hopefully should be cheap to allocate.                                      // 59\n  function tryCatch(fn, obj, arg) {                                                                        // 60\n    try {                                                                                                  // 61\n      return { type: \"normal\", arg: fn.call(obj, arg) };                                                   // 62\n    } catch (err) {                                                                                        // 63\n      return { type: \"throw\", arg: err };                                                                  // 64\n    }                                                                                                      // 65\n  }                                                                                                        // 66\n                                                                                                           // 67\n  var GenStateSuspendedStart = \"suspendedStart\";                                                           // 68\n  var GenStateSuspendedYield = \"suspendedYield\";                                                           // 69\n  var GenStateExecuting = \"executing\";                                                                     // 70\n  var GenStateCompleted = \"completed\";                                                                     // 71\n                                                                                                           // 72\n  // Returning this object from the innerFn has the same effect as                                         // 73\n  // breaking out of the dispatch switch statement.                                                        // 74\n  var ContinueSentinel = {};                                                                               // 75\n                                                                                                           // 76\n  // Dummy constructor functions that we use as the .constructor and                                       // 77\n  // .constructor.prototype properties for functions that return Generator                                 // 78\n  // objects. For full spec compliance, you may wish to configure your                                     // 79\n  // minifier not to mangle the names of these two functions.                                              // 80\n  function Generator() {}                                                                                  // 81\n  function GeneratorFunction() {}                                                                          // 82\n  function GeneratorFunctionPrototype() {}                                                                 // 83\n                                                                                                           // 84\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;                                     // 85\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;                               // 86\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;                                              // 87\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";     // 88\n                                                                                                           // 89\n  // Helper for defining the .next, .throw, and .return methods of the                                     // 90\n  // Iterator interface in terms of a single ._invoke method.                                              // 91\n  function defineIteratorMethods(prototype) {                                                              // 92\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {                                                 // 93\n      prototype[method] = function(arg) {                                                                  // 94\n        return this._invoke(method, arg);                                                                  // 95\n      };                                                                                                   // 96\n    });                                                                                                    // 97\n  }                                                                                                        // 98\n                                                                                                           // 99\n  runtime.isGeneratorFunction = function(genFun) {                                                         // 100\n    var ctor = typeof genFun === \"function\" && genFun.constructor;                                         // 101\n    return ctor                                                                                            // 102\n      ? ctor === GeneratorFunction ||                                                                      // 103\n        // For the native GeneratorFunction constructor, the best we can                                   // 104\n        // do is to check its .name property.                                                              // 105\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"                                            // 106\n      : false;                                                                                             // 107\n  };                                                                                                       // 108\n                                                                                                           // 109\n  runtime.mark = function(genFun) {                                                                        // 110\n    if (Object.setPrototypeOf) {                                                                           // 111\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);                                           // 112\n    } else {                                                                                               // 113\n      genFun.__proto__ = GeneratorFunctionPrototype;                                                       // 114\n      if (!(toStringTagSymbol in genFun)) {                                                                // 115\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";                                                   // 116\n      }                                                                                                    // 117\n    }                                                                                                      // 118\n    genFun.prototype = Object.create(Gp);                                                                  // 119\n    return genFun;                                                                                         // 120\n  };                                                                                                       // 121\n                                                                                                           // 122\n  // Within the body of any async function, `await x` is transformed to                                    // 123\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test                                     // 124\n  // `value instanceof AwaitArgument` to determine if the yielded value is                                 // 125\n  // meant to be awaited. Some may consider the name of this method too                                    // 126\n  // cutesy, but they are curmudgeons.                                                                     // 127\n  runtime.awrap = function(arg) {                                                                          // 128\n    return new AwaitArgument(arg);                                                                         // 129\n  };                                                                                                       // 130\n                                                                                                           // 131\n  function AwaitArgument(arg) {                                                                            // 132\n    this.arg = arg;                                                                                        // 133\n  }                                                                                                        // 134\n                                                                                                           // 135\n  function AsyncIterator(generator) {                                                                      // 136\n    function invoke(method, arg, resolve, reject) {                                                        // 137\n      var record = tryCatch(generator[method], generator, arg);                                            // 138\n      if (record.type === \"throw\") {                                                                       // 139\n        reject(record.arg);                                                                                // 140\n      } else {                                                                                             // 141\n        var result = record.arg;                                                                           // 142\n        var value = result.value;                                                                          // 143\n        if (value instanceof AwaitArgument) {                                                              // 144\n          return Promise.resolve(value.arg).then(function(value) {                                         // 145\n            invoke(\"next\", value, resolve, reject);                                                        // 146\n          }, function(err) {                                                                               // 147\n            invoke(\"throw\", err, resolve, reject);                                                         // 148\n          });                                                                                              // 149\n        }                                                                                                  // 150\n                                                                                                           // 151\n        return Promise.resolve(value).then(function(unwrapped) {                                           // 152\n          // When a yielded Promise is resolved, its final value becomes                                   // 153\n          // the .value of the Promise<{value,done}> result for the                                        // 154\n          // current iteration. If the Promise is rejected, however, the                                   // 155\n          // result for this iteration will be rejected with the same                                      // 156\n          // reason. Note that rejections of yielded Promises are not                                      // 157\n          // thrown back into the generator function, as is the case                                       // 158\n          // when an awaited Promise is rejected. This difference in                                       // 159\n          // behavior between yield and await is important, because it                                     // 160\n          // allows the consumer to decide what to do with the yielded                                     // 161\n          // rejection (swallow it and continue, manually .throw it back                                   // 162\n          // into the generator, abandon iteration, whatever). With                                        // 163\n          // await, by contrast, there is no opportunity to examine the                                    // 164\n          // rejection reason outside the generator function, so the                                       // 165\n          // only option is to throw it from the await expression, and                                     // 166\n          // let the generator function handle the exception.                                              // 167\n          result.value = unwrapped;                                                                        // 168\n          resolve(result);                                                                                 // 169\n        }, reject);                                                                                        // 170\n      }                                                                                                    // 171\n    }                                                                                                      // 172\n                                                                                                           // 173\n    if (typeof process === \"object\" && process.domain) {                                                   // 174\n      invoke = process.domain.bind(invoke);                                                                // 175\n    }                                                                                                      // 176\n                                                                                                           // 177\n    var previousPromise;                                                                                   // 178\n                                                                                                           // 179\n    function enqueue(method, arg) {                                                                        // 180\n      function callInvokeWithMethodAndArg() {                                                              // 181\n        return new Promise(function(resolve, reject) {                                                     // 182\n          invoke(method, arg, resolve, reject);                                                            // 183\n        });                                                                                                // 184\n      }                                                                                                    // 185\n                                                                                                           // 186\n      return previousPromise =                                                                             // 187\n        // If enqueue has been called before, then we want to wait until                                   // 188\n        // all previous Promises have been resolved before calling invoke,                                 // 189\n        // so that results are always delivered in the correct order. If                                   // 190\n        // enqueue has not been called before, then it is important to                                     // 191\n        // call invoke immediately, without waiting on a callback to fire,                                 // 192\n        // so that the async generator function has the opportunity to do                                  // 193\n        // any necessary setup in a predictable way. This predictability                                   // 194\n        // is why the Promise constructor synchronously invokes its                                        // 195\n        // executor callback, and why async functions synchronously                                        // 196\n        // execute code before the first await. Since we implement simple                                  // 197\n        // async functions in terms of async generators, it is especially                                  // 198\n        // important to get this right, even though it requires care.                                      // 199\n        previousPromise ? previousPromise.then(                                                            // 200\n          callInvokeWithMethodAndArg,                                                                      // 201\n          // Avoid propagating failures to Promises returned by later                                      // 202\n          // invocations of the iterator.                                                                  // 203\n          callInvokeWithMethodAndArg                                                                       // 204\n        ) : callInvokeWithMethodAndArg();                                                                  // 205\n    }                                                                                                      // 206\n                                                                                                           // 207\n    // Define the unified helper method that is used to implement .next,                                   // 208\n    // .throw, and .return (see defineIteratorMethods).                                                    // 209\n    this._invoke = enqueue;                                                                                // 210\n  }                                                                                                        // 211\n                                                                                                           // 212\n  defineIteratorMethods(AsyncIterator.prototype);                                                          // 213\n                                                                                                           // 214\n  // Note that simple async functions are implemented on top of                                            // 215\n  // AsyncIterator objects; they just return a Promise for the value of                                    // 216\n  // the final result produced by the iterator.                                                            // 217\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {                                          // 218\n    var iter = new AsyncIterator(                                                                          // 219\n      wrap(innerFn, outerFn, self, tryLocsList)                                                            // 220\n    );                                                                                                     // 221\n                                                                                                           // 222\n    return runtime.isGeneratorFunction(outerFn)                                                            // 223\n      ? iter // If outerFn is a generator, return the full iterator.                                       // 224\n      : iter.next().then(function(result) {                                                                // 225\n          return result.done ? result.value : iter.next();                                                 // 226\n        });                                                                                                // 227\n  };                                                                                                       // 228\n                                                                                                           // 229\n  function makeInvokeMethod(innerFn, self, context) {                                                      // 230\n    var state = GenStateSuspendedStart;                                                                    // 231\n                                                                                                           // 232\n    return function invoke(method, arg) {                                                                  // 233\n      if (state === GenStateExecuting) {                                                                   // 234\n        throw new Error(\"Generator is already running\");                                                   // 235\n      }                                                                                                    // 236\n                                                                                                           // 237\n      if (state === GenStateCompleted) {                                                                   // 238\n        if (method === \"throw\") {                                                                          // 239\n          throw arg;                                                                                       // 240\n        }                                                                                                  // 241\n                                                                                                           // 242\n        // Be forgiving, per 25.3.3.3.3 of the spec:                                                       // 243\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume                       // 244\n        return doneResult();                                                                               // 245\n      }                                                                                                    // 246\n                                                                                                           // 247\n      while (true) {                                                                                       // 248\n        var delegate = context.delegate;                                                                   // 249\n        if (delegate) {                                                                                    // 250\n          if (method === \"return\" ||                                                                       // 251\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {                           // 252\n            // A return or throw (when the delegate iterator has no throw                                  // 253\n            // method) always terminates the yield* loop.                                                  // 254\n            context.delegate = null;                                                                       // 255\n                                                                                                           // 256\n            // If the delegate iterator has a return method, give it a                                     // 257\n            // chance to clean up.                                                                         // 258\n            var returnMethod = delegate.iterator[\"return\"];                                                // 259\n            if (returnMethod) {                                                                            // 260\n              var record = tryCatch(returnMethod, delegate.iterator, arg);                                 // 261\n              if (record.type === \"throw\") {                                                               // 262\n                // If the return method threw an exception, let that                                       // 263\n                // exception prevail over the original return or throw.                                    // 264\n                method = \"throw\";                                                                          // 265\n                arg = record.arg;                                                                          // 266\n                continue;                                                                                  // 267\n              }                                                                                            // 268\n            }                                                                                              // 269\n                                                                                                           // 270\n            if (method === \"return\") {                                                                     // 271\n              // Continue with the outer return, now that the delegate                                     // 272\n              // iterator has been terminated.                                                             // 273\n              continue;                                                                                    // 274\n            }                                                                                              // 275\n          }                                                                                                // 276\n                                                                                                           // 277\n          var record = tryCatch(                                                                           // 278\n            delegate.iterator[method],                                                                     // 279\n            delegate.iterator,                                                                             // 280\n            arg                                                                                            // 281\n          );                                                                                               // 282\n                                                                                                           // 283\n          if (record.type === \"throw\") {                                                                   // 284\n            context.delegate = null;                                                                       // 285\n                                                                                                           // 286\n            // Like returning generator.throw(uncaught), but without the                                   // 287\n            // overhead of an extra function call.                                                         // 288\n            method = \"throw\";                                                                              // 289\n            arg = record.arg;                                                                              // 290\n            continue;                                                                                      // 291\n          }                                                                                                // 292\n                                                                                                           // 293\n          // Delegate generator ran and handled its own exceptions so                                      // 294\n          // regardless of what the method was, we continue as if it is                                    // 295\n          // \"next\" with an undefined arg.                                                                 // 296\n          method = \"next\";                                                                                 // 297\n          arg = undefined;                                                                                 // 298\n                                                                                                           // 299\n          var info = record.arg;                                                                           // 300\n          if (info.done) {                                                                                 // 301\n            context[delegate.resultName] = info.value;                                                     // 302\n            context.next = delegate.nextLoc;                                                               // 303\n          } else {                                                                                         // 304\n            state = GenStateSuspendedYield;                                                                // 305\n            return info;                                                                                   // 306\n          }                                                                                                // 307\n                                                                                                           // 308\n          context.delegate = null;                                                                         // 309\n        }                                                                                                  // 310\n                                                                                                           // 311\n        if (method === \"next\") {                                                                           // 312\n          if (state === GenStateSuspendedYield) {                                                          // 313\n            context.sent = arg;                                                                            // 314\n          } else {                                                                                         // 315\n            context.sent = undefined;                                                                      // 316\n          }                                                                                                // 317\n                                                                                                           // 318\n        } else if (method === \"throw\") {                                                                   // 319\n          if (state === GenStateSuspendedStart) {                                                          // 320\n            state = GenStateCompleted;                                                                     // 321\n            throw arg;                                                                                     // 322\n          }                                                                                                // 323\n                                                                                                           // 324\n          if (context.dispatchException(arg)) {                                                            // 325\n            // If the dispatched exception was caught by a catch block,                                    // 326\n            // then let that catch block handle the exception normally.                                    // 327\n            method = \"next\";                                                                               // 328\n            arg = undefined;                                                                               // 329\n          }                                                                                                // 330\n                                                                                                           // 331\n        } else if (method === \"return\") {                                                                  // 332\n          context.abrupt(\"return\", arg);                                                                   // 333\n        }                                                                                                  // 334\n                                                                                                           // 335\n        state = GenStateExecuting;                                                                         // 336\n                                                                                                           // 337\n        var record = tryCatch(innerFn, self, context);                                                     // 338\n        if (record.type === \"normal\") {                                                                    // 339\n          // If an exception is thrown from innerFn, we leave state ===                                    // 340\n          // GenStateExecuting and loop back for another invocation.                                       // 341\n          state = context.done                                                                             // 342\n            ? GenStateCompleted                                                                            // 343\n            : GenStateSuspendedYield;                                                                      // 344\n                                                                                                           // 345\n          var info = {                                                                                     // 346\n            value: record.arg,                                                                             // 347\n            done: context.done                                                                             // 348\n          };                                                                                               // 349\n                                                                                                           // 350\n          if (record.arg === ContinueSentinel) {                                                           // 351\n            if (context.delegate && method === \"next\") {                                                   // 352\n              // Deliberately forget the last sent value so that we don't                                  // 353\n              // accidentally pass it on to the delegate.                                                  // 354\n              arg = undefined;                                                                             // 355\n            }                                                                                              // 356\n          } else {                                                                                         // 357\n            return info;                                                                                   // 358\n          }                                                                                                // 359\n                                                                                                           // 360\n        } else if (record.type === \"throw\") {                                                              // 361\n          state = GenStateCompleted;                                                                       // 362\n          // Dispatch the exception by looping back around to the                                          // 363\n          // context.dispatchException(arg) call above.                                                    // 364\n          method = \"throw\";                                                                                // 365\n          arg = record.arg;                                                                                // 366\n        }                                                                                                  // 367\n      }                                                                                                    // 368\n    };                                                                                                     // 369\n  }                                                                                                        // 370\n                                                                                                           // 371\n  // Define Generator.prototype.{next,throw,return} in terms of the                                        // 372\n  // unified ._invoke helper method.                                                                       // 373\n  defineIteratorMethods(Gp);                                                                               // 374\n                                                                                                           // 375\n  Gp[iteratorSymbol] = function() {                                                                        // 376\n    return this;                                                                                           // 377\n  };                                                                                                       // 378\n                                                                                                           // 379\n  Gp[toStringTagSymbol] = \"Generator\";                                                                     // 380\n                                                                                                           // 381\n  Gp.toString = function() {                                                                               // 382\n    return \"[object Generator]\";                                                                           // 383\n  };                                                                                                       // 384\n                                                                                                           // 385\n  function pushTryEntry(locs) {                                                                            // 386\n    var entry = { tryLoc: locs[0] };                                                                       // 387\n                                                                                                           // 388\n    if (1 in locs) {                                                                                       // 389\n      entry.catchLoc = locs[1];                                                                            // 390\n    }                                                                                                      // 391\n                                                                                                           // 392\n    if (2 in locs) {                                                                                       // 393\n      entry.finallyLoc = locs[2];                                                                          // 394\n      entry.afterLoc = locs[3];                                                                            // 395\n    }                                                                                                      // 396\n                                                                                                           // 397\n    this.tryEntries.push(entry);                                                                           // 398\n  }                                                                                                        // 399\n                                                                                                           // 400\n  function resetTryEntry(entry) {                                                                          // 401\n    var record = entry.completion || {};                                                                   // 402\n    record.type = \"normal\";                                                                                // 403\n    delete record.arg;                                                                                     // 404\n    entry.completion = record;                                                                             // 405\n  }                                                                                                        // 406\n                                                                                                           // 407\n  function Context(tryLocsList) {                                                                          // 408\n    // The root entry object (effectively a try statement without a catch                                  // 409\n    // or a finally block) gives us a place to store values thrown from                                    // 410\n    // locations where there is no enclosing try statement.                                                // 411\n    this.tryEntries = [{ tryLoc: \"root\" }];                                                                // 412\n    tryLocsList.forEach(pushTryEntry, this);                                                               // 413\n    this.reset(true);                                                                                      // 414\n  }                                                                                                        // 415\n                                                                                                           // 416\n  runtime.keys = function(object) {                                                                        // 417\n    var keys = [];                                                                                         // 418\n    for (var key in object) {                                                                              // 419\n      keys.push(key);                                                                                      // 420\n    }                                                                                                      // 421\n    keys.reverse();                                                                                        // 422\n                                                                                                           // 423\n    // Rather than returning an object with a next method, we keep                                         // 424\n    // things simple and return the next function itself.                                                  // 425\n    return function next() {                                                                               // 426\n      while (keys.length) {                                                                                // 427\n        var key = keys.pop();                                                                              // 428\n        if (key in object) {                                                                               // 429\n          next.value = key;                                                                                // 430\n          next.done = false;                                                                               // 431\n          return next;                                                                                     // 432\n        }                                                                                                  // 433\n      }                                                                                                    // 434\n                                                                                                           // 435\n      // To avoid creating an additional object, we just hang the .value                                   // 436\n      // and .done properties off the next function object itself. This                                    // 437\n      // also ensures that the minifier will not anonymize the function.                                   // 438\n      next.done = true;                                                                                    // 439\n      return next;                                                                                         // 440\n    };                                                                                                     // 441\n  };                                                                                                       // 442\n                                                                                                           // 443\n  function values(iterable) {                                                                              // 444\n    if (iterable) {                                                                                        // 445\n      var iteratorMethod = iterable[iteratorSymbol];                                                       // 446\n      if (iteratorMethod) {                                                                                // 447\n        return iteratorMethod.call(iterable);                                                              // 448\n      }                                                                                                    // 449\n                                                                                                           // 450\n      if (typeof iterable.next === \"function\") {                                                           // 451\n        return iterable;                                                                                   // 452\n      }                                                                                                    // 453\n                                                                                                           // 454\n      if (!isNaN(iterable.length)) {                                                                       // 455\n        var i = -1, next = function next() {                                                               // 456\n          while (++i < iterable.length) {                                                                  // 457\n            if (hasOwn.call(iterable, i)) {                                                                // 458\n              next.value = iterable[i];                                                                    // 459\n              next.done = false;                                                                           // 460\n              return next;                                                                                 // 461\n            }                                                                                              // 462\n          }                                                                                                // 463\n                                                                                                           // 464\n          next.value = undefined;                                                                          // 465\n          next.done = true;                                                                                // 466\n                                                                                                           // 467\n          return next;                                                                                     // 468\n        };                                                                                                 // 469\n                                                                                                           // 470\n        return next.next = next;                                                                           // 471\n      }                                                                                                    // 472\n    }                                                                                                      // 473\n                                                                                                           // 474\n    // Return an iterator with no values.                                                                  // 475\n    return { next: doneResult };                                                                           // 476\n  }                                                                                                        // 477\n  runtime.values = values;                                                                                 // 478\n                                                                                                           // 479\n  function doneResult() {                                                                                  // 480\n    return { value: undefined, done: true };                                                               // 481\n  }                                                                                                        // 482\n                                                                                                           // 483\n  Context.prototype = {                                                                                    // 484\n    constructor: Context,                                                                                  // 485\n                                                                                                           // 486\n    reset: function(skipTempReset) {                                                                       // 487\n      this.prev = 0;                                                                                       // 488\n      this.next = 0;                                                                                       // 489\n      this.sent = undefined;                                                                               // 490\n      this.done = false;                                                                                   // 491\n      this.delegate = null;                                                                                // 492\n                                                                                                           // 493\n      this.tryEntries.forEach(resetTryEntry);                                                              // 494\n                                                                                                           // 495\n      if (!skipTempReset) {                                                                                // 496\n        for (var name in this) {                                                                           // 497\n          // Not sure about the optimal order of these conditions:                                         // 498\n          if (name.charAt(0) === \"t\" &&                                                                    // 499\n              hasOwn.call(this, name) &&                                                                   // 500\n              !isNaN(+name.slice(1))) {                                                                    // 501\n            this[name] = undefined;                                                                        // 502\n          }                                                                                                // 503\n        }                                                                                                  // 504\n      }                                                                                                    // 505\n    },                                                                                                     // 506\n                                                                                                           // 507\n    stop: function() {                                                                                     // 508\n      this.done = true;                                                                                    // 509\n                                                                                                           // 510\n      var rootEntry = this.tryEntries[0];                                                                  // 511\n      var rootRecord = rootEntry.completion;                                                               // 512\n      if (rootRecord.type === \"throw\") {                                                                   // 513\n        throw rootRecord.arg;                                                                              // 514\n      }                                                                                                    // 515\n                                                                                                           // 516\n      return this.rval;                                                                                    // 517\n    },                                                                                                     // 518\n                                                                                                           // 519\n    dispatchException: function(exception) {                                                               // 520\n      if (this.done) {                                                                                     // 521\n        throw exception;                                                                                   // 522\n      }                                                                                                    // 523\n                                                                                                           // 524\n      var context = this;                                                                                  // 525\n      function handle(loc, caught) {                                                                       // 526\n        record.type = \"throw\";                                                                             // 527\n        record.arg = exception;                                                                            // 528\n        context.next = loc;                                                                                // 529\n        return !!caught;                                                                                   // 530\n      }                                                                                                    // 531\n                                                                                                           // 532\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 533\n        var entry = this.tryEntries[i];                                                                    // 534\n        var record = entry.completion;                                                                     // 535\n                                                                                                           // 536\n        if (entry.tryLoc === \"root\") {                                                                     // 537\n          // Exception thrown outside of any try block that could handle                                   // 538\n          // it, so set the completion value of the entire function to                                     // 539\n          // throw the exception.                                                                          // 540\n          return handle(\"end\");                                                                            // 541\n        }                                                                                                  // 542\n                                                                                                           // 543\n        if (entry.tryLoc <= this.prev) {                                                                   // 544\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");                                                   // 545\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");                                               // 546\n                                                                                                           // 547\n          if (hasCatch && hasFinally) {                                                                    // 548\n            if (this.prev < entry.catchLoc) {                                                              // 549\n              return handle(entry.catchLoc, true);                                                         // 550\n            } else if (this.prev < entry.finallyLoc) {                                                     // 551\n              return handle(entry.finallyLoc);                                                             // 552\n            }                                                                                              // 553\n                                                                                                           // 554\n          } else if (hasCatch) {                                                                           // 555\n            if (this.prev < entry.catchLoc) {                                                              // 556\n              return handle(entry.catchLoc, true);                                                         // 557\n            }                                                                                              // 558\n                                                                                                           // 559\n          } else if (hasFinally) {                                                                         // 560\n            if (this.prev < entry.finallyLoc) {                                                            // 561\n              return handle(entry.finallyLoc);                                                             // 562\n            }                                                                                              // 563\n                                                                                                           // 564\n          } else {                                                                                         // 565\n            throw new Error(\"try statement without catch or finally\");                                     // 566\n          }                                                                                                // 567\n        }                                                                                                  // 568\n      }                                                                                                    // 569\n    },                                                                                                     // 570\n                                                                                                           // 571\n    abrupt: function(type, arg) {                                                                          // 572\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 573\n        var entry = this.tryEntries[i];                                                                    // 574\n        if (entry.tryLoc <= this.prev &&                                                                   // 575\n            hasOwn.call(entry, \"finallyLoc\") &&                                                            // 576\n            this.prev < entry.finallyLoc) {                                                                // 577\n          var finallyEntry = entry;                                                                        // 578\n          break;                                                                                           // 579\n        }                                                                                                  // 580\n      }                                                                                                    // 581\n                                                                                                           // 582\n      if (finallyEntry &&                                                                                  // 583\n          (type === \"break\" ||                                                                             // 584\n           type === \"continue\") &&                                                                         // 585\n          finallyEntry.tryLoc <= arg &&                                                                    // 586\n          arg <= finallyEntry.finallyLoc) {                                                                // 587\n        // Ignore the finally entry if control is not jumping to a                                         // 588\n        // location outside the try/catch block.                                                           // 589\n        finallyEntry = null;                                                                               // 590\n      }                                                                                                    // 591\n                                                                                                           // 592\n      var record = finallyEntry ? finallyEntry.completion : {};                                            // 593\n      record.type = type;                                                                                  // 594\n      record.arg = arg;                                                                                    // 595\n                                                                                                           // 596\n      if (finallyEntry) {                                                                                  // 597\n        this.next = finallyEntry.finallyLoc;                                                               // 598\n      } else {                                                                                             // 599\n        this.complete(record);                                                                             // 600\n      }                                                                                                    // 601\n                                                                                                           // 602\n      return ContinueSentinel;                                                                             // 603\n    },                                                                                                     // 604\n                                                                                                           // 605\n    complete: function(record, afterLoc) {                                                                 // 606\n      if (record.type === \"throw\") {                                                                       // 607\n        throw record.arg;                                                                                  // 608\n      }                                                                                                    // 609\n                                                                                                           // 610\n      if (record.type === \"break\" ||                                                                       // 611\n          record.type === \"continue\") {                                                                    // 612\n        this.next = record.arg;                                                                            // 613\n      } else if (record.type === \"return\") {                                                               // 614\n        this.rval = record.arg;                                                                            // 615\n        this.next = \"end\";                                                                                 // 616\n      } else if (record.type === \"normal\" && afterLoc) {                                                   // 617\n        this.next = afterLoc;                                                                              // 618\n      }                                                                                                    // 619\n    },                                                                                                     // 620\n                                                                                                           // 621\n    finish: function(finallyLoc) {                                                                         // 622\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 623\n        var entry = this.tryEntries[i];                                                                    // 624\n        if (entry.finallyLoc === finallyLoc) {                                                             // 625\n          this.complete(entry.completion, entry.afterLoc);                                                 // 626\n          resetTryEntry(entry);                                                                            // 627\n          return ContinueSentinel;                                                                         // 628\n        }                                                                                                  // 629\n      }                                                                                                    // 630\n    },                                                                                                     // 631\n                                                                                                           // 632\n    \"catch\": function(tryLoc) {                                                                            // 633\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 634\n        var entry = this.tryEntries[i];                                                                    // 635\n        if (entry.tryLoc === tryLoc) {                                                                     // 636\n          var record = entry.completion;                                                                   // 637\n          if (record.type === \"throw\") {                                                                   // 638\n            var thrown = record.arg;                                                                       // 639\n            resetTryEntry(entry);                                                                          // 640\n          }                                                                                                // 641\n          return thrown;                                                                                   // 642\n        }                                                                                                  // 643\n      }                                                                                                    // 644\n                                                                                                           // 645\n      // The context.catch method must only be called with a location                                      // 646\n      // argument that corresponds to a known catch block.                                                 // 647\n      throw new Error(\"illegal catch attempt\");                                                            // 648\n    },                                                                                                     // 649\n                                                                                                           // 650\n    delegateYield: function(iterable, resultName, nextLoc) {                                               // 651\n      this.delegate = {                                                                                    // 652\n        iterator: values(iterable),                                                                        // 653\n        resultName: resultName,                                                                            // 654\n        nextLoc: nextLoc                                                                                   // 655\n      };                                                                                                   // 656\n                                                                                                           // 657\n      return ContinueSentinel;                                                                             // 658\n    }                                                                                                      // 659\n  };                                                                                                       // 660\n})(                                                                                                        // 661\n  // Among the various tricks for obtaining a reference to the global                                      // 662\n  // object, this seems to be the most reliable technique that does not                                    // 663\n  // use indirect eval (which violates Content Security Policy).                                           // 664\n  typeof global === \"object\" ? global :                                                                    // 665\n  typeof window === \"object\" ? window :                                                                    // 666\n  typeof self === \"object\" ? self : this                                                                   // 667\n);                                                                                                         // 668\n                                                                                                           // 669\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/babel-runtime/babel-runtime.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['babel-runtime'] = {}, {\n  meteorBabelHelpers: meteorBabelHelpers\n});\n\n})();\n","servePath":"/packages/babel-runtime.js"}]