[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Retry = Package.retry.Retry;\nvar IdMap = Package['id-map'].IdMap;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\n\n/* Package-scope variables */\nvar DDP, LivedataTest, MongoIDMap, SockJS, toSockjsUrl, toWebsocketUrl, allConnections, Ledger, objectsWithUsers, errorThrownWhenCallingSetUserIdDirectlyOnServer, One, Two, StubStream;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/namespace.js                                                                                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/**                                                                                                                  // 1\n * @namespace DDP                                                                                                    // 2\n * @summary Namespace for DDP-related methods/classes.                                                               // 3\n */                                                                                                                  // 4\nDDP          = {};                                                                                                   // 5\nLivedataTest = {};                                                                                                   // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/id_map.js                                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nMongoIDMap = function () {                                                                                           // 1\n  var self = this;                                                                                                   // 2\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);                                                            // 3\n};                                                                                                                   // 4\n                                                                                                                     // 5\nMeteor._inherits(MongoIDMap, IdMap);                                                                                 // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/sockjs-0.3.4.js                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// XXX METEOR changes in <METEOR>                                                                                    // 1\n                                                                                                                     // 2\n/* SockJS client, version 0.3.4, http://sockjs.org, MIT License                                                      // 3\n                                                                                                                     // 4\nCopyright (c) 2011-2012 VMware, Inc.                                                                                 // 5\n                                                                                                                     // 6\nPermission is hereby granted, free of charge, to any person obtaining a copy                                         // 7\nof this software and associated documentation files (the \"Software\"), to deal                                        // 8\nin the Software without restriction, including without limitation the rights                                         // 9\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell                                            // 10\ncopies of the Software, and to permit persons to whom the Software is                                                // 11\nfurnished to do so, subject to the following conditions:                                                             // 12\n                                                                                                                     // 13\nThe above copyright notice and this permission notice shall be included in                                           // 14\nall copies or substantial portions of the Software.                                                                  // 15\n                                                                                                                     // 16\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                           // 17\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                             // 18\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                          // 19\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                               // 20\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                        // 21\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                                            // 22\nTHE SOFTWARE.                                                                                                        // 23\n*/                                                                                                                   // 24\n                                                                                                                     // 25\n// <METEOR> Commented out JSO implementation (use json package instead).                                             // 26\n// JSON2 by Douglas Crockford (minified).                                                                            // 27\n// var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n// </METEOR>                                                                                                         // 29\n                                                                                                                     // 30\n//     [*] Including lib/index.js                                                                                    // 31\n// Public object                                                                                                     // 32\nSockJS = (function(){                                                                                                // 33\n              var _document = document;                                                                              // 34\n              var _window = window;                                                                                  // 35\n              var utils = {};                                                                                        // 36\n                                                                                                                     // 37\n                                                                                                                     // 38\n//         [*] Including lib/reventtarget.js                                                                         // 39\n/*                                                                                                                   // 40\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 41\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 42\n *                                                                                                                   // 43\n * For the license see COPYING.                                                                                      // 44\n * ***** END LICENSE BLOCK *****                                                                                     // 45\n */                                                                                                                  // 46\n                                                                                                                     // 47\n/* Simplified implementation of DOM2 EventTarget.                                                                    // 48\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget                                          // 49\n */                                                                                                                  // 50\nvar REventTarget = function() {};                                                                                    // 51\nREventTarget.prototype.addEventListener = function (eventType, listener) {                                           // 52\n    if(!this._listeners) {                                                                                           // 53\n         this._listeners = {};                                                                                       // 54\n    }                                                                                                                // 55\n    if(!(eventType in this._listeners)) {                                                                            // 56\n        this._listeners[eventType] = [];                                                                             // 57\n    }                                                                                                                // 58\n    var arr = this._listeners[eventType];                                                                            // 59\n    if(utils.arrIndexOf(arr, listener) === -1) {                                                                     // 60\n        arr.push(listener);                                                                                          // 61\n    }                                                                                                                // 62\n    return;                                                                                                          // 63\n};                                                                                                                   // 64\n                                                                                                                     // 65\nREventTarget.prototype.removeEventListener = function (eventType, listener) {                                        // 66\n    if(!(this._listeners && (eventType in this._listeners))) {                                                       // 67\n        return;                                                                                                      // 68\n    }                                                                                                                // 69\n    var arr = this._listeners[eventType];                                                                            // 70\n    var idx = utils.arrIndexOf(arr, listener);                                                                       // 71\n    if (idx !== -1) {                                                                                                // 72\n        if(arr.length > 1) {                                                                                         // 73\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );                               // 74\n        } else {                                                                                                     // 75\n            delete this._listeners[eventType];                                                                       // 76\n        }                                                                                                            // 77\n        return;                                                                                                      // 78\n    }                                                                                                                // 79\n    return;                                                                                                          // 80\n};                                                                                                                   // 81\n                                                                                                                     // 82\nREventTarget.prototype.dispatchEvent = function (event) {                                                            // 83\n    var t = event.type;                                                                                              // 84\n    var args = Array.prototype.slice.call(arguments, 0);                                                             // 85\n    if (this['on'+t]) {                                                                                              // 86\n        this['on'+t].apply(this, args);                                                                              // 87\n    }                                                                                                                // 88\n    if (this._listeners && t in this._listeners) {                                                                   // 89\n        for(var i=0; i < this._listeners[t].length; i++) {                                                           // 90\n            this._listeners[t][i].apply(this, args);                                                                 // 91\n        }                                                                                                            // 92\n    }                                                                                                                // 93\n};                                                                                                                   // 94\n//         [*] End of lib/reventtarget.js                                                                            // 95\n                                                                                                                     // 96\n                                                                                                                     // 97\n//         [*] Including lib/simpleevent.js                                                                          // 98\n/*                                                                                                                   // 99\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 100\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 101\n *                                                                                                                   // 102\n * For the license see COPYING.                                                                                      // 103\n * ***** END LICENSE BLOCK *****                                                                                     // 104\n */                                                                                                                  // 105\n                                                                                                                     // 106\nvar SimpleEvent = function(type, obj) {                                                                              // 107\n    this.type = type;                                                                                                // 108\n    if (typeof obj !== 'undefined') {                                                                                // 109\n        for(var k in obj) {                                                                                          // 110\n            if (!obj.hasOwnProperty(k)) continue;                                                                    // 111\n            this[k] = obj[k];                                                                                        // 112\n        }                                                                                                            // 113\n    }                                                                                                                // 114\n};                                                                                                                   // 115\n                                                                                                                     // 116\nSimpleEvent.prototype.toString = function() {                                                                        // 117\n    var r = [];                                                                                                      // 118\n    for(var k in this) {                                                                                             // 119\n        if (!this.hasOwnProperty(k)) continue;                                                                       // 120\n        var v = this[k];                                                                                             // 121\n        if (typeof v === 'function') v = '[function]';                                                               // 122\n        r.push(k + '=' + v);                                                                                         // 123\n    }                                                                                                                // 124\n    return 'SimpleEvent(' + r.join(', ') + ')';                                                                      // 125\n};                                                                                                                   // 126\n//         [*] End of lib/simpleevent.js                                                                             // 127\n                                                                                                                     // 128\n                                                                                                                     // 129\n//         [*] Including lib/eventemitter.js                                                                         // 130\n/*                                                                                                                   // 131\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 132\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 133\n *                                                                                                                   // 134\n * For the license see COPYING.                                                                                      // 135\n * ***** END LICENSE BLOCK *****                                                                                     // 136\n */                                                                                                                  // 137\n                                                                                                                     // 138\nvar EventEmitter = function(events) {                                                                                // 139\n    var that = this;                                                                                                 // 140\n    that._events = events || [];                                                                                     // 141\n    that._listeners = {};                                                                                            // 142\n};                                                                                                                   // 143\nEventEmitter.prototype.emit = function(type) {                                                                       // 144\n    var that = this;                                                                                                 // 145\n    that._verifyType(type);                                                                                          // 146\n    if (that._nuked) return;                                                                                         // 147\n                                                                                                                     // 148\n    var args = Array.prototype.slice.call(arguments, 1);                                                             // 149\n    if (that['on'+type]) {                                                                                           // 150\n        that['on'+type].apply(that, args);                                                                           // 151\n    }                                                                                                                // 152\n    if (type in that._listeners) {                                                                                   // 153\n        for(var i = 0; i < that._listeners[type].length; i++) {                                                      // 154\n            that._listeners[type][i].apply(that, args);                                                              // 155\n        }                                                                                                            // 156\n    }                                                                                                                // 157\n};                                                                                                                   // 158\n                                                                                                                     // 159\nEventEmitter.prototype.on = function(type, callback) {                                                               // 160\n    var that = this;                                                                                                 // 161\n    that._verifyType(type);                                                                                          // 162\n    if (that._nuked) return;                                                                                         // 163\n                                                                                                                     // 164\n    if (!(type in that._listeners)) {                                                                                // 165\n        that._listeners[type] = [];                                                                                  // 166\n    }                                                                                                                // 167\n    that._listeners[type].push(callback);                                                                            // 168\n};                                                                                                                   // 169\n                                                                                                                     // 170\nEventEmitter.prototype._verifyType = function(type) {                                                                // 171\n    var that = this;                                                                                                 // 172\n    if (utils.arrIndexOf(that._events, type) === -1) {                                                               // 173\n        utils.log('Event ' + JSON.stringify(type) +                                                                  // 174\n                  ' not listed ' + JSON.stringify(that._events) +                                                    // 175\n                  ' in ' + that);                                                                                    // 176\n    }                                                                                                                // 177\n};                                                                                                                   // 178\n                                                                                                                     // 179\nEventEmitter.prototype.nuke = function() {                                                                           // 180\n    var that = this;                                                                                                 // 181\n    that._nuked = true;                                                                                              // 182\n    for(var i=0; i<that._events.length; i++) {                                                                       // 183\n        delete that[that._events[i]];                                                                                // 184\n    }                                                                                                                // 185\n    that._listeners = {};                                                                                            // 186\n};                                                                                                                   // 187\n//         [*] End of lib/eventemitter.js                                                                            // 188\n                                                                                                                     // 189\n                                                                                                                     // 190\n//         [*] Including lib/utils.js                                                                                // 191\n/*                                                                                                                   // 192\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 193\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 194\n *                                                                                                                   // 195\n * For the license see COPYING.                                                                                      // 196\n * ***** END LICENSE BLOCK *****                                                                                     // 197\n */                                                                                                                  // 198\n                                                                                                                     // 199\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';                                                   // 200\nutils.random_string = function(length, max) {                                                                        // 201\n    max = max || random_string_chars.length;                                                                         // 202\n    var i, ret = [];                                                                                                 // 203\n    for(i=0; i < length; i++) {                                                                                      // 204\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );                                   // 205\n    }                                                                                                                // 206\n    return ret.join('');                                                                                             // 207\n};                                                                                                                   // 208\nutils.random_number = function(max) {                                                                                // 209\n    return Math.floor(Math.random() * max);                                                                          // 210\n};                                                                                                                   // 211\nutils.random_number_string = function(max) {                                                                         // 212\n    var t = (''+(max - 1)).length;                                                                                   // 213\n    var p = Array(t+1).join('0');                                                                                    // 214\n    return (p + utils.random_number(max)).slice(-t);                                                                 // 215\n};                                                                                                                   // 216\n                                                                                                                     // 217\n// Assuming that url looks like: http://asdasd:111/asd                                                               // 218\nutils.getOrigin = function(url) {                                                                                    // 219\n    url += '/';                                                                                                      // 220\n    var parts = url.split('/').slice(0, 3);                                                                          // 221\n    return parts.join('/');                                                                                          // 222\n};                                                                                                                   // 223\n                                                                                                                     // 224\nutils.isSameOriginUrl = function(url_a, url_b) {                                                                     // 225\n    // location.origin would do, but it's not always available.                                                      // 226\n    if (!url_b) url_b = _window.location.href;                                                                       // 227\n                                                                                                                     // 228\n    return (url_a.split('/').slice(0,3).join('/')                                                                    // 229\n                ===                                                                                                  // 230\n            url_b.split('/').slice(0,3).join('/'));                                                                  // 231\n};                                                                                                                   // 232\n                                                                                                                     // 233\n// <METEOR>                                                                                                          // 234\n// https://github.com/sockjs/sockjs-client/issues/79                                                                 // 235\nutils.isSameOriginScheme = function(url_a, url_b) {                                                                  // 236\n    if (!url_b) url_b = _window.location.href;                                                                       // 237\n                                                                                                                     // 238\n    return (url_a.split(':')[0]                                                                                      // 239\n                ===                                                                                                  // 240\n            url_b.split(':')[0]);                                                                                    // 241\n};                                                                                                                   // 242\n// </METEOR>                                                                                                         // 243\n                                                                                                                     // 244\n                                                                                                                     // 245\nutils.getParentDomain = function(url) {                                                                              // 246\n    // ipv4 ip address                                                                                               // 247\n    if (/^[0-9.]*$/.test(url)) return url;                                                                           // 248\n    // ipv6 ip address                                                                                               // 249\n    if (/^\\[/.test(url)) return url;                                                                                 // 250\n    // no dots                                                                                                       // 251\n    if (!(/[.]/.test(url))) return url;                                                                              // 252\n                                                                                                                     // 253\n    var parts = url.split('.').slice(1);                                                                             // 254\n    return parts.join('.');                                                                                          // 255\n};                                                                                                                   // 256\n                                                                                                                     // 257\nutils.objectExtend = function(dst, src) {                                                                            // 258\n    for(var k in src) {                                                                                              // 259\n        if (src.hasOwnProperty(k)) {                                                                                 // 260\n            dst[k] = src[k];                                                                                         // 261\n        }                                                                                                            // 262\n    }                                                                                                                // 263\n    return dst;                                                                                                      // 264\n};                                                                                                                   // 265\n                                                                                                                     // 266\nvar WPrefix = '_jp';                                                                                                 // 267\n                                                                                                                     // 268\nutils.polluteGlobalNamespace = function() {                                                                          // 269\n    if (!(WPrefix in _window)) {                                                                                     // 270\n        _window[WPrefix] = {};                                                                                       // 271\n    }                                                                                                                // 272\n};                                                                                                                   // 273\n                                                                                                                     // 274\nutils.closeFrame = function (code, reason) {                                                                         // 275\n    return 'c'+JSON.stringify([code, reason]);                                                                       // 276\n};                                                                                                                   // 277\n                                                                                                                     // 278\nutils.userSetCode = function (code) {                                                                                // 279\n    return code === 1000 || (code >= 3000 && code <= 4999);                                                          // 280\n};                                                                                                                   // 281\n                                                                                                                     // 282\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/                                            // 283\n// and RFC 2988.                                                                                                     // 284\nutils.countRTO = function (rtt) {                                                                                    // 285\n    var rto;                                                                                                         // 286\n    if (rtt > 100) {                                                                                                 // 287\n        rto = 3 * rtt; // rto > 300msec                                                                              // 288\n    } else {                                                                                                         // 289\n        rto = rtt + 200; // 200msec < rto <= 300msec                                                                 // 290\n    }                                                                                                                // 291\n    return rto;                                                                                                      // 292\n}                                                                                                                    // 293\n                                                                                                                     // 294\nutils.log = function() {                                                                                             // 295\n    if (_window.console && console.log && console.log.apply) {                                                       // 296\n        console.log.apply(console, arguments);                                                                       // 297\n    }                                                                                                                // 298\n};                                                                                                                   // 299\n                                                                                                                     // 300\nutils.bind = function(fun, that) {                                                                                   // 301\n    if (fun.bind) {                                                                                                  // 302\n        return fun.bind(that);                                                                                       // 303\n    } else {                                                                                                         // 304\n        return function() {                                                                                          // 305\n            return fun.apply(that, arguments);                                                                       // 306\n        };                                                                                                           // 307\n    }                                                                                                                // 308\n};                                                                                                                   // 309\n                                                                                                                     // 310\nutils.flatUrl = function(url) {                                                                                      // 311\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;                                                       // 312\n};                                                                                                                   // 313\n                                                                                                                     // 314\n// `relativeTo` is an optional absolute URL. If provided, `url` will be                                              // 315\n// interpreted relative to `relativeTo`. Defaults to `document.location`.                                            // 316\n// <METEOR>                                                                                                          // 317\nutils.amendUrl = function(url, relativeTo) {                                                                         // 318\n    var baseUrl;                                                                                                     // 319\n    if (relativeTo === undefined) {                                                                                  // 320\n      baseUrl = _document.location;                                                                                  // 321\n    } else {                                                                                                         // 322\n      var protocolMatch = /^([a-z0-9.+-]+:)/i.exec(relativeTo);                                                      // 323\n      if (protocolMatch) {                                                                                           // 324\n        var protocol = protocolMatch[0].toLowerCase();                                                               // 325\n        var rest = relativeTo.substring(protocol.length);                                                            // 326\n        var hostMatch = /[a-z0-9\\.-]+(:[0-9]+)?/.exec(rest);                                                         // 327\n        if (hostMatch)                                                                                               // 328\n          var host = hostMatch[0];                                                                                   // 329\n      }                                                                                                              // 330\n      if (! protocol || ! host)                                                                                      // 331\n        throw new Error(\"relativeTo must be an absolute url\");                                                       // 332\n      baseUrl = {                                                                                                    // 333\n        protocol: protocol,                                                                                          // 334\n        host: host                                                                                                   // 335\n      };                                                                                                             // 336\n    }                                                                                                                // 337\n    if (!url) {                                                                                                      // 338\n        throw new Error('Wrong url for SockJS');                                                                     // 339\n    }                                                                                                                // 340\n    if (!utils.flatUrl(url)) {                                                                                       // 341\n        throw new Error('Only basic urls are supported in SockJS');                                                  // 342\n    }                                                                                                                // 343\n                                                                                                                     // 344\n    //  '//abc' --> 'http://abc'                                                                                     // 345\n    if (url.indexOf('//') === 0) {                                                                                   // 346\n        url = baseUrl.protocol + url;                                                                                // 347\n    }                                                                                                                // 348\n    // '/abc' --> 'http://localhost:1234/abc'                                                                        // 349\n    if (url.indexOf('/') === 0) {                                                                                    // 350\n        url = baseUrl.protocol + '//' + baseUrl.host + url;                                                          // 351\n    }                                                                                                                // 352\n    // </METEOR>                                                                                                     // 353\n    // strip trailing slashes                                                                                        // 354\n    url = url.replace(/[/]+$/,'');                                                                                   // 355\n                                                                                                                     // 356\n    // We have a full url here, with proto and host. For some browsers                                               // 357\n    // http://localhost:80/ is not in the same origin as http://localhost/                                           // 358\n\t// Remove explicit :80 or :443 in such cases. See #74                                                               // 359\n    var parts = url.split(\"/\");                                                                                      // 360\n    if ((parts[0] === \"http:\" && /:80$/.test(parts[2])) ||                                                           // 361\n\t    (parts[0] === \"https:\" && /:443$/.test(parts[2]))) {                                                            // 362\n\t\tparts[2] = parts[2].replace(/:(80|443)$/, \"\");                                                                     // 363\n\t}                                                                                                                   // 364\n    url = parts.join(\"/\");                                                                                           // 365\n    return url;                                                                                                      // 366\n};                                                                                                                   // 367\n                                                                                                                     // 368\n// IE doesn't support [].indexOf.                                                                                    // 369\nutils.arrIndexOf = function(arr, obj){                                                                               // 370\n    for(var i=0; i < arr.length; i++){                                                                               // 371\n        if(arr[i] === obj){                                                                                          // 372\n            return i;                                                                                                // 373\n        }                                                                                                            // 374\n    }                                                                                                                // 375\n    return -1;                                                                                                       // 376\n};                                                                                                                   // 377\n                                                                                                                     // 378\nutils.arrSkip = function(arr, obj) {                                                                                 // 379\n    var idx = utils.arrIndexOf(arr, obj);                                                                            // 380\n    if (idx === -1) {                                                                                                // 381\n        return arr.slice();                                                                                          // 382\n    } else {                                                                                                         // 383\n        var dst = arr.slice(0, idx);                                                                                 // 384\n        return dst.concat(arr.slice(idx+1));                                                                         // 385\n    }                                                                                                                // 386\n};                                                                                                                   // 387\n                                                                                                                     // 388\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df                                     // 389\nutils.isArray = Array.isArray || function(value) {                                                                   // 390\n    return {}.toString.call(value).indexOf('Array') >= 0                                                             // 391\n};                                                                                                                   // 392\n                                                                                                                     // 393\nutils.delay = function(t, fun) {                                                                                     // 394\n    if(typeof t === 'function') {                                                                                    // 395\n        fun = t;                                                                                                     // 396\n        t = 0;                                                                                                       // 397\n    }                                                                                                                // 398\n    return setTimeout(fun, t);                                                                                       // 399\n};                                                                                                                   // 400\n                                                                                                                     // 401\n                                                                                                                     // 402\n// Chars worth escaping, as defined by Douglas Crockford:                                                            // 403\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196         // 404\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {                                                                                                  // 406\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",                                         // 407\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",                                         // 408\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",                                           // 409\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",                                         // 410\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",                                         // 411\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",                                         // 412\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",                                         // 413\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",                                                       // 414\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",                                         // 415\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",                                         // 416\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",                                         // 417\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",                                         // 418\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",                                         // 419\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",                                         // 420\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",                                         // 421\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",                                         // 422\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",                                         // 423\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",                                         // 424\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",                                         // 425\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",                                         // 426\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",                                         // 427\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",                                         // 428\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",                                         // 429\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",                                         // 430\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",                                         // 431\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",                                         // 432\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",                                         // 433\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",                                         // 434\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",                                         // 435\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};                                                           // 436\n                                                                                                                     // 437\n// Some extra characters that Chrome gets wrong, and substitutes with                                                // 438\n// something else on the wire.                                                                                       // 439\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;                                                                                                    // 441\n                                                                                                                     // 442\n// JSON Quote string. Use native implementation when possible.                                                       // 443\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {                                                       // 444\n    json_escapable.lastIndex = 0;                                                                                    // 445\n    if (json_escapable.test(string)) {                                                                               // 446\n        string = string.replace(json_escapable, function(a) {                                                        // 447\n            return json_lookup[a];                                                                                   // 448\n        });                                                                                                          // 449\n    }                                                                                                                // 450\n    return '\"' + string + '\"';                                                                                       // 451\n};                                                                                                                   // 452\n                                                                                                                     // 453\n// This may be quite slow, so let's delay until user actually uses bad                                               // 454\n// characters.                                                                                                       // 455\nvar unroll_lookup = function(escapable) {                                                                            // 456\n    var i;                                                                                                           // 457\n    var unrolled = {}                                                                                                // 458\n    var c = []                                                                                                       // 459\n    for(i=0; i<65536; i++) {                                                                                         // 460\n        c.push( String.fromCharCode(i) );                                                                            // 461\n    }                                                                                                                // 462\n    escapable.lastIndex = 0;                                                                                         // 463\n    c.join('').replace(escapable, function (a) {                                                                     // 464\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                                   // 465\n        return '';                                                                                                   // 466\n    });                                                                                                              // 467\n    escapable.lastIndex = 0;                                                                                         // 468\n    return unrolled;                                                                                                 // 469\n};                                                                                                                   // 470\n                                                                                                                     // 471\n// Quote string, also taking care of unicode characters that browsers                                                // 472\n// often break. Especially, take care of unicode surrogates:                                                         // 473\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates                                          // 474\nutils.quote = function(string) {                                                                                     // 475\n    var quoted = JSONQuote(string);                                                                                  // 476\n                                                                                                                     // 477\n    // In most cases this should be very fast and good enough.                                                       // 478\n    extra_escapable.lastIndex = 0;                                                                                   // 479\n    if(!extra_escapable.test(quoted)) {                                                                              // 480\n        return quoted;                                                                                               // 481\n    }                                                                                                                // 482\n                                                                                                                     // 483\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);                                                 // 484\n                                                                                                                     // 485\n    return quoted.replace(extra_escapable, function(a) {                                                             // 486\n        return extra_lookup[a];                                                                                      // 487\n    });                                                                                                              // 488\n}                                                                                                                    // 489\n                                                                                                                     // 490\nvar _all_protocols = ['websocket',                                                                                   // 491\n                      'xdr-streaming',                                                                               // 492\n                      'xhr-streaming',                                                                               // 493\n                      'iframe-eventsource',                                                                          // 494\n                      'iframe-htmlfile',                                                                             // 495\n                      'xdr-polling',                                                                                 // 496\n                      'xhr-polling',                                                                                 // 497\n                      'iframe-xhr-polling',                                                                          // 498\n                      'jsonp-polling'];                                                                              // 499\n                                                                                                                     // 500\nutils.probeProtocols = function() {                                                                                  // 501\n    var probed = {};                                                                                                 // 502\n    for(var i=0; i<_all_protocols.length; i++) {                                                                     // 503\n        var protocol = _all_protocols[i];                                                                            // 504\n        // User can have a typo in protocol name.                                                                    // 505\n        probed[protocol] = SockJS[protocol] &&                                                                       // 506\n                           SockJS[protocol].enabled();                                                               // 507\n    }                                                                                                                // 508\n    return probed;                                                                                                   // 509\n};                                                                                                                   // 510\n                                                                                                                     // 511\nutils.detectProtocols = function(probed, protocols_whitelist, info) {                                                // 512\n    var pe = {},                                                                                                     // 513\n        protocols = [];                                                                                              // 514\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;                                                  // 515\n    for(var i=0; i<protocols_whitelist.length; i++) {                                                                // 516\n        var protocol = protocols_whitelist[i];                                                                       // 517\n        pe[protocol] = probed[protocol];                                                                             // 518\n    }                                                                                                                // 519\n    var maybe_push = function(protos) {                                                                              // 520\n        var proto = protos.shift();                                                                                  // 521\n        if (pe[proto]) {                                                                                             // 522\n            protocols.push(proto);                                                                                   // 523\n        } else {                                                                                                     // 524\n            if (protos.length > 0) {                                                                                 // 525\n                maybe_push(protos);                                                                                  // 526\n            }                                                                                                        // 527\n        }                                                                                                            // 528\n    }                                                                                                                // 529\n                                                                                                                     // 530\n    // 1. Websocket                                                                                                  // 531\n    if (info.websocket !== false) {                                                                                  // 532\n        maybe_push(['websocket']);                                                                                   // 533\n    }                                                                                                                // 534\n                                                                                                                     // 535\n    // 2. Streaming                                                                                                  // 536\n    if (pe['xhr-streaming'] && !info.null_origin) {                                                                  // 537\n        protocols.push('xhr-streaming');                                                                             // 538\n    } else {                                                                                                         // 539\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {                                       // 540\n            protocols.push('xdr-streaming');                                                                         // 541\n        } else {                                                                                                     // 542\n            maybe_push(['iframe-eventsource',                                                                        // 543\n                        'iframe-htmlfile']);                                                                         // 544\n        }                                                                                                            // 545\n    }                                                                                                                // 546\n                                                                                                                     // 547\n    // 3. Polling                                                                                                    // 548\n    if (pe['xhr-polling'] && !info.null_origin) {                                                                    // 549\n        protocols.push('xhr-polling');                                                                               // 550\n    } else {                                                                                                         // 551\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {                                         // 552\n            protocols.push('xdr-polling');                                                                           // 553\n        } else {                                                                                                     // 554\n            maybe_push(['iframe-xhr-polling',                                                                        // 555\n                        'jsonp-polling']);                                                                           // 556\n        }                                                                                                            // 557\n    }                                                                                                                // 558\n    return protocols;                                                                                                // 559\n}                                                                                                                    // 560\n//         [*] End of lib/utils.js                                                                                   // 561\n                                                                                                                     // 562\n                                                                                                                     // 563\n//         [*] Including lib/dom.js                                                                                  // 564\n/*                                                                                                                   // 565\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 566\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 567\n *                                                                                                                   // 568\n * For the license see COPYING.                                                                                      // 569\n * ***** END LICENSE BLOCK *****                                                                                     // 570\n */                                                                                                                  // 571\n                                                                                                                     // 572\n// May be used by htmlfile jsonp and transports.                                                                     // 573\nvar MPrefix = '_sockjs_global';                                                                                      // 574\nutils.createHook = function() {                                                                                      // 575\n    var window_id = 'a' + utils.random_string(8);                                                                    // 576\n    if (!(MPrefix in _window)) {                                                                                     // 577\n        var map = {};                                                                                                // 578\n        _window[MPrefix] = function(window_id) {                                                                     // 579\n            if (!(window_id in map)) {                                                                               // 580\n                map[window_id] = {                                                                                   // 581\n                    id: window_id,                                                                                   // 582\n                    del: function() {delete map[window_id];}                                                         // 583\n                };                                                                                                   // 584\n            }                                                                                                        // 585\n            return map[window_id];                                                                                   // 586\n        }                                                                                                            // 587\n    }                                                                                                                // 588\n    return _window[MPrefix](window_id);                                                                              // 589\n};                                                                                                                   // 590\n                                                                                                                     // 591\n                                                                                                                     // 592\n                                                                                                                     // 593\nutils.attachMessage = function(listener) {                                                                           // 594\n    utils.attachEvent('message', listener);                                                                          // 595\n};                                                                                                                   // 596\nutils.attachEvent = function(event, listener) {                                                                      // 597\n    if (typeof _window.addEventListener !== 'undefined') {                                                           // 598\n        _window.addEventListener(event, listener, false);                                                            // 599\n    } else {                                                                                                         // 600\n        // IE quirks.                                                                                                // 601\n        // According to: http://stevesouders.com/misc/test-postmessage.php                                           // 602\n        // the message gets delivered only to 'document', not 'window'.                                              // 603\n        _document.attachEvent(\"on\" + event, listener);                                                               // 604\n        // I get 'window' for ie8.                                                                                   // 605\n        _window.attachEvent(\"on\" + event, listener);                                                                 // 606\n    }                                                                                                                // 607\n};                                                                                                                   // 608\n                                                                                                                     // 609\nutils.detachMessage = function(listener) {                                                                           // 610\n    utils.detachEvent('message', listener);                                                                          // 611\n};                                                                                                                   // 612\nutils.detachEvent = function(event, listener) {                                                                      // 613\n    if (typeof _window.addEventListener !== 'undefined') {                                                           // 614\n        _window.removeEventListener(event, listener, false);                                                         // 615\n    } else {                                                                                                         // 616\n        _document.detachEvent(\"on\" + event, listener);                                                               // 617\n        _window.detachEvent(\"on\" + event, listener);                                                                 // 618\n    }                                                                                                                // 619\n};                                                                                                                   // 620\n                                                                                                                     // 621\n                                                                                                                     // 622\nvar on_unload = {};                                                                                                  // 623\n// Things registered after beforeunload are to be called immediately.                                                // 624\nvar after_unload = false;                                                                                            // 625\n                                                                                                                     // 626\nvar trigger_unload_callbacks = function() {                                                                          // 627\n    for(var ref in on_unload) {                                                                                      // 628\n        on_unload[ref]();                                                                                            // 629\n        delete on_unload[ref];                                                                                       // 630\n    };                                                                                                               // 631\n};                                                                                                                   // 632\n                                                                                                                     // 633\nvar unload_triggered = function() {                                                                                  // 634\n    if(after_unload) return;                                                                                         // 635\n    after_unload = true;                                                                                             // 636\n    trigger_unload_callbacks();                                                                                      // 637\n};                                                                                                                   // 638\n                                                                                                                     // 639\n// 'unload' alone is not reliable in opera within an iframe, but we                                                  // 640\n// can't use `beforeunload` as IE fires it on javascript: links.                                                     // 641\nutils.attachEvent('unload', unload_triggered);                                                                       // 642\n                                                                                                                     // 643\nutils.unload_add = function(listener) {                                                                              // 644\n    var ref = utils.random_string(8);                                                                                // 645\n    on_unload[ref] = listener;                                                                                       // 646\n    if (after_unload) {                                                                                              // 647\n        utils.delay(trigger_unload_callbacks);                                                                       // 648\n    }                                                                                                                // 649\n    return ref;                                                                                                      // 650\n};                                                                                                                   // 651\nutils.unload_del = function(ref) {                                                                                   // 652\n    if (ref in on_unload)                                                                                            // 653\n        delete on_unload[ref];                                                                                       // 654\n};                                                                                                                   // 655\n                                                                                                                     // 656\n                                                                                                                     // 657\nutils.createIframe = function (iframe_url, error_callback) {                                                         // 658\n    var iframe = _document.createElement('iframe');                                                                  // 659\n    var tref, unload_ref;                                                                                            // 660\n    var unattach = function() {                                                                                      // 661\n        clearTimeout(tref);                                                                                          // 662\n        // Explorer had problems with that.                                                                          // 663\n        try {iframe.onload = null;} catch (x) {}                                                                     // 664\n        iframe.onerror = null;                                                                                       // 665\n    };                                                                                                               // 666\n    var cleanup = function() {                                                                                       // 667\n        if (iframe) {                                                                                                // 668\n            unattach();                                                                                              // 669\n            // This timeout makes chrome fire onbeforeunload event                                                   // 670\n            // within iframe. Without the timeout it goes straight to                                                // 671\n            // onunload.                                                                                             // 672\n            setTimeout(function() {                                                                                  // 673\n                if(iframe) {                                                                                         // 674\n                    iframe.parentNode.removeChild(iframe);                                                           // 675\n                }                                                                                                    // 676\n                iframe = null;                                                                                       // 677\n            }, 0);                                                                                                   // 678\n            utils.unload_del(unload_ref);                                                                            // 679\n        }                                                                                                            // 680\n    };                                                                                                               // 681\n    var onerror = function(r) {                                                                                      // 682\n        if (iframe) {                                                                                                // 683\n            cleanup();                                                                                               // 684\n            error_callback(r);                                                                                       // 685\n        }                                                                                                            // 686\n    };                                                                                                               // 687\n    var post = function(msg, origin) {                                                                               // 688\n        try {                                                                                                        // 689\n            // When the iframe is not loaded, IE raises an exception                                                 // 690\n            // on 'contentWindow'.                                                                                   // 691\n            if (iframe && iframe.contentWindow) {                                                                    // 692\n                iframe.contentWindow.postMessage(msg, origin);                                                       // 693\n            }                                                                                                        // 694\n        } catch (x) {};                                                                                              // 695\n    };                                                                                                               // 696\n                                                                                                                     // 697\n    iframe.src = iframe_url;                                                                                         // 698\n    iframe.style.display = 'none';                                                                                   // 699\n    iframe.style.position = 'absolute';                                                                              // 700\n    iframe.onerror = function(){onerror('onerror');};                                                                // 701\n    iframe.onload = function() {                                                                                     // 702\n        // `onload` is triggered before scripts on the iframe are                                                    // 703\n        // executed. Give it few seconds to actually load stuff.                                                     // 704\n        clearTimeout(tref);                                                                                          // 705\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);                                             // 706\n    };                                                                                                               // 707\n    _document.body.appendChild(iframe);                                                                              // 708\n    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                       // 709\n    unload_ref = utils.unload_add(cleanup);                                                                          // 710\n    return {                                                                                                         // 711\n        post: post,                                                                                                  // 712\n        cleanup: cleanup,                                                                                            // 713\n        loaded: unattach                                                                                             // 714\n    };                                                                                                               // 715\n};                                                                                                                   // 716\n                                                                                                                     // 717\nutils.createHtmlfile = function (iframe_url, error_callback) {                                                       // 718\n    var doc = new ActiveXObject('htmlfile');                                                                         // 719\n    var tref, unload_ref;                                                                                            // 720\n    var iframe;                                                                                                      // 721\n    var unattach = function() {                                                                                      // 722\n        clearTimeout(tref);                                                                                          // 723\n    };                                                                                                               // 724\n    var cleanup = function() {                                                                                       // 725\n        if (doc) {                                                                                                   // 726\n            unattach();                                                                                              // 727\n            utils.unload_del(unload_ref);                                                                            // 728\n            iframe.parentNode.removeChild(iframe);                                                                   // 729\n            iframe = doc = null;                                                                                     // 730\n            CollectGarbage();                                                                                        // 731\n        }                                                                                                            // 732\n    };                                                                                                               // 733\n    var onerror = function(r)  {                                                                                     // 734\n        if (doc) {                                                                                                   // 735\n            cleanup();                                                                                               // 736\n            error_callback(r);                                                                                       // 737\n        }                                                                                                            // 738\n    };                                                                                                               // 739\n    var post = function(msg, origin) {                                                                               // 740\n        try {                                                                                                        // 741\n            // When the iframe is not loaded, IE raises an exception                                                 // 742\n            // on 'contentWindow'.                                                                                   // 743\n            if (iframe && iframe.contentWindow) {                                                                    // 744\n                iframe.contentWindow.postMessage(msg, origin);                                                       // 745\n            }                                                                                                        // 746\n        } catch (x) {};                                                                                              // 747\n    };                                                                                                               // 748\n                                                                                                                     // 749\n    doc.open();                                                                                                      // 750\n    doc.write('<html><s' + 'cript>' +                                                                                // 751\n              'document.domain=\"' + document.domain + '\";' +                                                         // 752\n              '</s' + 'cript></html>');                                                                              // 753\n    doc.close();                                                                                                     // 754\n    doc.parentWindow[WPrefix] = _window[WPrefix];                                                                    // 755\n    var c = doc.createElement('div');                                                                                // 756\n    doc.body.appendChild(c);                                                                                         // 757\n    iframe = doc.createElement('iframe');                                                                            // 758\n    c.appendChild(iframe);                                                                                           // 759\n    iframe.src = iframe_url;                                                                                         // 760\n    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                       // 761\n    unload_ref = utils.unload_add(cleanup);                                                                          // 762\n    return {                                                                                                         // 763\n        post: post,                                                                                                  // 764\n        cleanup: cleanup,                                                                                            // 765\n        loaded: unattach                                                                                             // 766\n    };                                                                                                               // 767\n};                                                                                                                   // 768\n//         [*] End of lib/dom.js                                                                                     // 769\n                                                                                                                     // 770\n                                                                                                                     // 771\n//         [*] Including lib/dom2.js                                                                                 // 772\n/*                                                                                                                   // 773\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 774\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 775\n *                                                                                                                   // 776\n * For the license see COPYING.                                                                                      // 777\n * ***** END LICENSE BLOCK *****                                                                                     // 778\n */                                                                                                                  // 779\n                                                                                                                     // 780\nvar AbstractXHRObject = function(){};                                                                                // 781\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);                                                 // 782\n                                                                                                                     // 783\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {                                          // 784\n    var that = this;                                                                                                 // 785\n                                                                                                                     // 786\n    try {                                                                                                            // 787\n        that.xhr = new XMLHttpRequest();                                                                             // 788\n    } catch(x) {};                                                                                                   // 789\n                                                                                                                     // 790\n    if (!that.xhr) {                                                                                                 // 791\n        try {                                                                                                        // 792\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');                                               // 793\n        } catch(x) {};                                                                                               // 794\n    }                                                                                                                // 795\n    if (_window.ActiveXObject || _window.XDomainRequest) {                                                           // 796\n        // IE8 caches even POSTs                                                                                     // 797\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                           // 798\n    }                                                                                                                // 799\n                                                                                                                     // 800\n    // Explorer tends to keep connection open, even after the                                                        // 801\n    // tab gets closed: http://bugs.jquery.com/ticket/5280                                                           // 802\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                            // 803\n    try {                                                                                                            // 804\n        that.xhr.open(method, url, true);                                                                            // 805\n    } catch(e) {                                                                                                     // 806\n        // IE raises an exception on wrong port.                                                                     // 807\n        that.emit('finish', 0, '');                                                                                  // 808\n        that._cleanup();                                                                                             // 809\n        return;                                                                                                      // 810\n    };                                                                                                               // 811\n                                                                                                                     // 812\n    if (!opts || !opts.no_credentials) {                                                                             // 813\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :                                       // 814\n        // \"This never affects same-site requests.\"                                                                  // 815\n        that.xhr.withCredentials = 'true';                                                                           // 816\n    }                                                                                                                // 817\n    if (opts && opts.headers) {                                                                                      // 818\n        for(var key in opts.headers) {                                                                               // 819\n            that.xhr.setRequestHeader(key, opts.headers[key]);                                                       // 820\n        }                                                                                                            // 821\n    }                                                                                                                // 822\n                                                                                                                     // 823\n    that.xhr.onreadystatechange = function() {                                                                       // 824\n        if (that.xhr) {                                                                                              // 825\n            var x = that.xhr;                                                                                        // 826\n            switch (x.readyState) {                                                                                  // 827\n            case 3:                                                                                                  // 828\n                // IE doesn't like peeking into responseText or status                                               // 829\n                // on Microsoft.XMLHTTP and readystate=3                                                             // 830\n                try {                                                                                                // 831\n                    var status = x.status;                                                                           // 832\n                    var text = x.responseText;                                                                       // 833\n                } catch (x) {};                                                                                      // 834\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                       // 835\n                if (status === 1223) status = 204;                                                                   // 836\n                                                                                                                     // 837\n                // IE does return readystate == 3 for 404 answers.                                                   // 838\n                if (text && text.length > 0) {                                                                       // 839\n                    that.emit('chunk', status, text);                                                                // 840\n                }                                                                                                    // 841\n                break;                                                                                               // 842\n            case 4:                                                                                                  // 843\n                var status = x.status;                                                                               // 844\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                       // 845\n                if (status === 1223) status = 204;                                                                   // 846\n                                                                                                                     // 847\n                that.emit('finish', status, x.responseText);                                                         // 848\n                that._cleanup(false);                                                                                // 849\n                break;                                                                                               // 850\n            }                                                                                                        // 851\n        }                                                                                                            // 852\n    };                                                                                                               // 853\n    that.xhr.send(payload);                                                                                          // 854\n};                                                                                                                   // 855\n                                                                                                                     // 856\nAbstractXHRObject.prototype._cleanup = function(abort) {                                                             // 857\n    var that = this;                                                                                                 // 858\n    if (!that.xhr) return;                                                                                           // 859\n    utils.unload_del(that.unload_ref);                                                                               // 860\n                                                                                                                     // 861\n    // IE needs this field to be a function                                                                          // 862\n    that.xhr.onreadystatechange = function(){};                                                                      // 863\n                                                                                                                     // 864\n    if (abort) {                                                                                                     // 865\n        try {                                                                                                        // 866\n            that.xhr.abort();                                                                                        // 867\n        } catch(x) {};                                                                                               // 868\n    }                                                                                                                // 869\n    that.unload_ref = that.xhr = null;                                                                               // 870\n};                                                                                                                   // 871\n                                                                                                                     // 872\nAbstractXHRObject.prototype.close = function() {                                                                     // 873\n    var that = this;                                                                                                 // 874\n    that.nuke();                                                                                                     // 875\n    that._cleanup(true);                                                                                             // 876\n};                                                                                                                   // 877\n                                                                                                                     // 878\nvar XHRCorsObject = utils.XHRCorsObject = function() {                                                               // 879\n    var that = this, args = arguments;                                                                               // 880\n    utils.delay(function(){that._start.apply(that, args);});                                                         // 881\n};                                                                                                                   // 882\nXHRCorsObject.prototype = new AbstractXHRObject();                                                                   // 883\n                                                                                                                     // 884\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {                                         // 885\n    var that = this;                                                                                                 // 886\n    utils.delay(function(){                                                                                          // 887\n        that._start(method, url, payload, {                                                                          // 888\n            no_credentials: true                                                                                     // 889\n        });                                                                                                          // 890\n    });                                                                                                              // 891\n};                                                                                                                   // 892\nXHRLocalObject.prototype = new AbstractXHRObject();                                                                  // 893\n                                                                                                                     // 894\n                                                                                                                     // 895\n                                                                                                                     // 896\n// References:                                                                                                       // 897\n//   http://ajaxian.com/archives/100-line-ajax-wrapper                                                               // 898\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx                                                  // 899\nvar XDRObject = utils.XDRObject = function(method, url, payload) {                                                   // 900\n    var that = this;                                                                                                 // 901\n    utils.delay(function(){that._start(method, url, payload);});                                                     // 902\n};                                                                                                                   // 903\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);                                                         // 904\nXDRObject.prototype._start = function(method, url, payload) {                                                        // 905\n    var that = this;                                                                                                 // 906\n    var xdr = new XDomainRequest();                                                                                  // 907\n    // IE caches even POSTs                                                                                          // 908\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                               // 909\n                                                                                                                     // 910\n    var onerror = xdr.ontimeout = xdr.onerror = function() {                                                         // 911\n        that.emit('finish', 0, '');                                                                                  // 912\n        that._cleanup(false);                                                                                        // 913\n    };                                                                                                               // 914\n    xdr.onprogress = function() {                                                                                    // 915\n        that.emit('chunk', 200, xdr.responseText);                                                                   // 916\n    };                                                                                                               // 917\n    xdr.onload = function() {                                                                                        // 918\n        that.emit('finish', 200, xdr.responseText);                                                                  // 919\n        that._cleanup(false);                                                                                        // 920\n    };                                                                                                               // 921\n    that.xdr = xdr;                                                                                                  // 922\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                            // 923\n    try {                                                                                                            // 924\n        // Fails with AccessDenied if port number is bogus                                                           // 925\n        that.xdr.open(method, url);                                                                                  // 926\n        that.xdr.send(payload);                                                                                      // 927\n    } catch(x) {                                                                                                     // 928\n        onerror();                                                                                                   // 929\n    }                                                                                                                // 930\n};                                                                                                                   // 931\n                                                                                                                     // 932\nXDRObject.prototype._cleanup = function(abort) {                                                                     // 933\n    var that = this;                                                                                                 // 934\n    if (!that.xdr) return;                                                                                           // 935\n    utils.unload_del(that.unload_ref);                                                                               // 936\n                                                                                                                     // 937\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =                                                    // 938\n        that.xdr.onload = null;                                                                                      // 939\n    if (abort) {                                                                                                     // 940\n        try {                                                                                                        // 941\n            that.xdr.abort();                                                                                        // 942\n        } catch(x) {};                                                                                               // 943\n    }                                                                                                                // 944\n    that.unload_ref = that.xdr = null;                                                                               // 945\n};                                                                                                                   // 946\n                                                                                                                     // 947\nXDRObject.prototype.close = function() {                                                                             // 948\n    var that = this;                                                                                                 // 949\n    that.nuke();                                                                                                     // 950\n    that._cleanup(true);                                                                                             // 951\n};                                                                                                                   // 952\n                                                                                                                     // 953\n// 1. Is natively via XHR                                                                                            // 954\n// 2. Is natively via XDR                                                                                            // 955\n// 3. Nope, but postMessage is there so it should work via the Iframe.                                               // 956\n// 4. Nope, sorry.                                                                                                   // 957\nutils.isXHRCorsCapable = function() {                                                                                // 958\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {                                       // 959\n        return 1;                                                                                                    // 960\n    }                                                                                                                // 961\n    // XDomainRequest doesn't work if page is served from file://                                                    // 962\n    if (_window.XDomainRequest && _document.domain) {                                                                // 963\n        return 2;                                                                                                    // 964\n    }                                                                                                                // 965\n    if (IframeTransport.enabled()) {                                                                                 // 966\n        return 3;                                                                                                    // 967\n    }                                                                                                                // 968\n    return 4;                                                                                                        // 969\n};                                                                                                                   // 970\n//         [*] End of lib/dom2.js                                                                                    // 971\n                                                                                                                     // 972\n                                                                                                                     // 973\n//         [*] Including lib/sockjs.js                                                                               // 974\n/*                                                                                                                   // 975\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 976\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 977\n *                                                                                                                   // 978\n * For the license see COPYING.                                                                                      // 979\n * ***** END LICENSE BLOCK *****                                                                                     // 980\n */                                                                                                                  // 981\n                                                                                                                     // 982\nvar SockJS = function(url, dep_protocols_whitelist, options) {                                                       // 983\n    if (!(this instanceof SockJS)) {                                                                                 // 984\n        // makes `new` optional                                                                                      // 985\n        return new SockJS(url, dep_protocols_whitelist, options);                                                    // 986\n    }                                                                                                                // 987\n                                                                                                                     // 988\n    var that = this, protocols_whitelist;                                                                            // 989\n    that._options = {devel: false, debug: false, protocols_whitelist: [],                                            // 990\n                     info: undefined, rtt: undefined};                                                               // 991\n    if (options) {                                                                                                   // 992\n        utils.objectExtend(that._options, options);                                                                  // 993\n    }                                                                                                                // 994\n    that._base_url = utils.amendUrl(url);                                                                            // 995\n    that._server = that._options.server || utils.random_number_string(1000);                                         // 996\n    if (that._options.protocols_whitelist &&                                                                         // 997\n        that._options.protocols_whitelist.length) {                                                                  // 998\n        protocols_whitelist = that._options.protocols_whitelist;                                                     // 999\n    } else {                                                                                                         // 1000\n        // Deprecated API                                                                                            // 1001\n        if (typeof dep_protocols_whitelist === 'string' &&                                                           // 1002\n            dep_protocols_whitelist.length > 0) {                                                                    // 1003\n            protocols_whitelist = [dep_protocols_whitelist];                                                         // 1004\n        } else if (utils.isArray(dep_protocols_whitelist)) {                                                         // 1005\n            protocols_whitelist = dep_protocols_whitelist                                                            // 1006\n        } else {                                                                                                     // 1007\n            protocols_whitelist = null;                                                                              // 1008\n        }                                                                                                            // 1009\n        if (protocols_whitelist) {                                                                                   // 1010\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +                                        // 1011\n                        'instead of supplying protocol list as a second ' +                                          // 1012\n                        'parameter to SockJS constructor.');                                                         // 1013\n        }                                                                                                            // 1014\n    }                                                                                                                // 1015\n    that._protocols = [];                                                                                            // 1016\n    that.protocol = null;                                                                                            // 1017\n    that.readyState = SockJS.CONNECTING;                                                                             // 1018\n    that._ir = createInfoReceiver(that._base_url);                                                                   // 1019\n    that._ir.onfinish = function(info, rtt) {                                                                        // 1020\n        that._ir = null;                                                                                             // 1021\n        if (info) {                                                                                                  // 1022\n            if (that._options.info) {                                                                                // 1023\n                // Override if user supplies the option                                                              // 1024\n                info = utils.objectExtend(info, that._options.info);                                                 // 1025\n            }                                                                                                        // 1026\n            if (that._options.rtt) {                                                                                 // 1027\n                rtt = that._options.rtt;                                                                             // 1028\n            }                                                                                                        // 1029\n            that._applyInfo(info, rtt, protocols_whitelist);                                                         // 1030\n            that._didClose();                                                                                        // 1031\n        } else {                                                                                                     // 1032\n            that._didClose(1002, 'Can\\'t connect to server', true);                                                  // 1033\n        }                                                                                                            // 1034\n    };                                                                                                               // 1035\n};                                                                                                                   // 1036\n// Inheritance                                                                                                       // 1037\nSockJS.prototype = new REventTarget();                                                                               // 1038\n                                                                                                                     // 1039\nSockJS.version = \"0.3.4\";                                                                                            // 1040\n                                                                                                                     // 1041\nSockJS.CONNECTING = 0;                                                                                               // 1042\nSockJS.OPEN = 1;                                                                                                     // 1043\nSockJS.CLOSING = 2;                                                                                                  // 1044\nSockJS.CLOSED = 3;                                                                                                   // 1045\n                                                                                                                     // 1046\nSockJS.prototype._debug = function() {                                                                               // 1047\n    if (this._options.debug)                                                                                         // 1048\n        utils.log.apply(utils, arguments);                                                                           // 1049\n};                                                                                                                   // 1050\n                                                                                                                     // 1051\nSockJS.prototype._dispatchOpen = function() {                                                                        // 1052\n    var that = this;                                                                                                 // 1053\n    if (that.readyState === SockJS.CONNECTING) {                                                                     // 1054\n        if (that._transport_tref) {                                                                                  // 1055\n            clearTimeout(that._transport_tref);                                                                      // 1056\n            that._transport_tref = null;                                                                             // 1057\n        }                                                                                                            // 1058\n        that.readyState = SockJS.OPEN;                                                                               // 1059\n        that.dispatchEvent(new SimpleEvent(\"open\"));                                                                 // 1060\n    } else {                                                                                                         // 1061\n        // The server might have been restarted, and lost track of our                                               // 1062\n        // connection.                                                                                               // 1063\n        that._didClose(1006, \"Server lost session\");                                                                 // 1064\n    }                                                                                                                // 1065\n};                                                                                                                   // 1066\n                                                                                                                     // 1067\nSockJS.prototype._dispatchMessage = function(data) {                                                                 // 1068\n    var that = this;                                                                                                 // 1069\n    if (that.readyState !== SockJS.OPEN)                                                                             // 1070\n            return;                                                                                                  // 1071\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));                                                    // 1072\n};                                                                                                                   // 1073\n                                                                                                                     // 1074\nSockJS.prototype._dispatchHeartbeat = function(data) {                                                               // 1075\n    var that = this;                                                                                                 // 1076\n    if (that.readyState !== SockJS.OPEN)                                                                             // 1077\n        return;                                                                                                      // 1078\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));                                                            // 1079\n};                                                                                                                   // 1080\n                                                                                                                     // 1081\nSockJS.prototype._didClose = function(code, reason, force) {                                                         // 1082\n    var that = this;                                                                                                 // 1083\n    if (that.readyState !== SockJS.CONNECTING &&                                                                     // 1084\n        that.readyState !== SockJS.OPEN &&                                                                           // 1085\n        that.readyState !== SockJS.CLOSING)                                                                          // 1086\n            throw new Error('INVALID_STATE_ERR');                                                                    // 1087\n    if (that._ir) {                                                                                                  // 1088\n        that._ir.nuke();                                                                                             // 1089\n        that._ir = null;                                                                                             // 1090\n    }                                                                                                                // 1091\n                                                                                                                     // 1092\n    if (that._transport) {                                                                                           // 1093\n        that._transport.doCleanup();                                                                                 // 1094\n        that._transport = null;                                                                                      // 1095\n    }                                                                                                                // 1096\n                                                                                                                     // 1097\n    var close_event = new SimpleEvent(\"close\", {                                                                     // 1098\n        code: code,                                                                                                  // 1099\n        reason: reason,                                                                                              // 1100\n        wasClean: utils.userSetCode(code)});                                                                         // 1101\n                                                                                                                     // 1102\n    if (!utils.userSetCode(code) &&                                                                                  // 1103\n        that.readyState === SockJS.CONNECTING && !force) {                                                           // 1104\n        if (that._try_next_protocol(close_event)) {                                                                  // 1105\n            return;                                                                                                  // 1106\n        }                                                                                                            // 1107\n        close_event = new SimpleEvent(\"close\", {code: 2000,                                                          // 1108\n                                                reason: \"All transports failed\",                                     // 1109\n                                                wasClean: false,                                                     // 1110\n                                                last_event: close_event});                                           // 1111\n    }                                                                                                                // 1112\n    that.readyState = SockJS.CLOSED;                                                                                 // 1113\n                                                                                                                     // 1114\n    utils.delay(function() {                                                                                         // 1115\n                   that.dispatchEvent(close_event);                                                                  // 1116\n                });                                                                                                  // 1117\n};                                                                                                                   // 1118\n                                                                                                                     // 1119\nSockJS.prototype._didMessage = function(data) {                                                                      // 1120\n    var that = this;                                                                                                 // 1121\n    var type = data.slice(0, 1);                                                                                     // 1122\n    switch(type) {                                                                                                   // 1123\n    case 'o':                                                                                                        // 1124\n        that._dispatchOpen();                                                                                        // 1125\n        break;                                                                                                       // 1126\n    case 'a':                                                                                                        // 1127\n        var payload = JSON.parse(data.slice(1) || '[]');                                                             // 1128\n        for(var i=0; i < payload.length; i++){                                                                       // 1129\n            that._dispatchMessage(payload[i]);                                                                       // 1130\n        }                                                                                                            // 1131\n        break;                                                                                                       // 1132\n    case 'm':                                                                                                        // 1133\n        var payload = JSON.parse(data.slice(1) || 'null');                                                           // 1134\n        that._dispatchMessage(payload);                                                                              // 1135\n        break;                                                                                                       // 1136\n    case 'c':                                                                                                        // 1137\n        var payload = JSON.parse(data.slice(1) || '[]');                                                             // 1138\n        that._didClose(payload[0], payload[1]);                                                                      // 1139\n        break;                                                                                                       // 1140\n    case 'h':                                                                                                        // 1141\n        that._dispatchHeartbeat();                                                                                   // 1142\n        break;                                                                                                       // 1143\n    }                                                                                                                // 1144\n};                                                                                                                   // 1145\n                                                                                                                     // 1146\nSockJS.prototype._try_next_protocol = function(close_event) {                                                        // 1147\n    var that = this;                                                                                                 // 1148\n    if (that.protocol) {                                                                                             // 1149\n        that._debug('Closed transport:', that.protocol, ''+close_event);                                             // 1150\n        that.protocol = null;                                                                                        // 1151\n    }                                                                                                                // 1152\n    if (that._transport_tref) {                                                                                      // 1153\n        clearTimeout(that._transport_tref);                                                                          // 1154\n        that._transport_tref = null;                                                                                 // 1155\n    }                                                                                                                // 1156\n                                                                                                                     // 1157\n    while(1) {                                                                                                       // 1158\n        var protocol = that.protocol = that._protocols.shift();                                                      // 1159\n        if (!protocol) {                                                                                             // 1160\n            return false;                                                                                            // 1161\n        }                                                                                                            // 1162\n        // Some protocols require access to `body`, what if were in                                                  // 1163\n        // the `head`?                                                                                               // 1164\n        if (SockJS[protocol] &&                                                                                      // 1165\n            SockJS[protocol].need_body === true &&                                                                   // 1166\n            (!_document.body ||                                                                                      // 1167\n             (typeof _document.readyState !== 'undefined'                                                            // 1168\n              && _document.readyState !== 'complete'))) {                                                            // 1169\n            that._protocols.unshift(protocol);                                                                       // 1170\n            that.protocol = 'waiting-for-load';                                                                      // 1171\n            utils.attachEvent('load', function(){                                                                    // 1172\n                that._try_next_protocol();                                                                           // 1173\n            });                                                                                                      // 1174\n            return true;                                                                                             // 1175\n        }                                                                                                            // 1176\n                                                                                                                     // 1177\n        if (!SockJS[protocol] ||                                                                                     // 1178\n              !SockJS[protocol].enabled(that._options)) {                                                            // 1179\n            that._debug('Skipping transport:', protocol);                                                            // 1180\n        } else {                                                                                                     // 1181\n            var roundTrips = SockJS[protocol].roundTrips || 1;                                                       // 1182\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;                                                // 1183\n            that._transport_tref = utils.delay(to, function() {                                                      // 1184\n                if (that.readyState === SockJS.CONNECTING) {                                                         // 1185\n                    // I can't understand how it is possible to run                                                  // 1186\n                    // this timer, when the state is CLOSED, but                                                     // 1187\n                    // apparently in IE everythin is possible.                                                       // 1188\n                    that._didClose(2007, \"Transport timeouted\");                                                     // 1189\n                }                                                                                                    // 1190\n            });                                                                                                      // 1191\n                                                                                                                     // 1192\n            var connid = utils.random_string(8);                                                                     // 1193\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;                                      // 1194\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,                                           // 1195\n                        ' RTO:'+that._options.rto);                                                                  // 1196\n            that._transport = new SockJS[protocol](that, trans_url,                                                  // 1197\n                                                   that._base_url);                                                  // 1198\n            return true;                                                                                             // 1199\n        }                                                                                                            // 1200\n    }                                                                                                                // 1201\n};                                                                                                                   // 1202\n                                                                                                                     // 1203\nSockJS.prototype.close = function(code, reason) {                                                                    // 1204\n    var that = this;                                                                                                 // 1205\n    if (code && !utils.userSetCode(code))                                                                            // 1206\n        throw new Error(\"INVALID_ACCESS_ERR\");                                                                       // 1207\n    if(that.readyState !== SockJS.CONNECTING &&                                                                      // 1208\n       that.readyState !== SockJS.OPEN) {                                                                            // 1209\n        return false;                                                                                                // 1210\n    }                                                                                                                // 1211\n    that.readyState = SockJS.CLOSING;                                                                                // 1212\n    that._didClose(code || 1000, reason || \"Normal closure\");                                                        // 1213\n    return true;                                                                                                     // 1214\n};                                                                                                                   // 1215\n                                                                                                                     // 1216\nSockJS.prototype.send = function(data) {                                                                             // 1217\n    var that = this;                                                                                                 // 1218\n    if (that.readyState === SockJS.CONNECTING)                                                                       // 1219\n        throw new Error('INVALID_STATE_ERR');                                                                        // 1220\n    if (that.readyState === SockJS.OPEN) {                                                                           // 1221\n        that._transport.doSend(utils.quote('' + data));                                                              // 1222\n    }                                                                                                                // 1223\n    return true;                                                                                                     // 1224\n};                                                                                                                   // 1225\n                                                                                                                     // 1226\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {                                             // 1227\n    var that = this;                                                                                                 // 1228\n    that._options.info = info;                                                                                       // 1229\n    that._options.rtt = rtt;                                                                                         // 1230\n    that._options.rto = utils.countRTO(rtt);                                                                         // 1231\n    that._options.info.null_origin = !_document.domain;                                                              // 1232\n    // Servers can override base_url, eg to provide a randomized domain name and                                     // 1233\n    // avoid browser per-domain connection limits.                                                                   // 1234\n    if (info.base_url)                                                                                               // 1235\n      // <METEOR>                                                                                                    // 1236\n      that._base_url = utils.amendUrl(info.base_url, that._base_url);                                                // 1237\n      // </METEOR>                                                                                                   // 1238\n    var probed = utils.probeProtocols();                                                                             // 1239\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);                                      // 1240\n// <METEOR>                                                                                                          // 1241\n// https://github.com/sockjs/sockjs-client/issues/79                                                                 // 1242\n    // Hack to avoid XDR when using different protocols                                                              // 1243\n    // We're on IE trying to do cross-protocol. jsonp only.                                                          // 1244\n    if (!utils.isSameOriginScheme(that._base_url) &&                                                                 // 1245\n        2 === utils.isXHRCorsCapable()) {                                                                            // 1246\n        that._protocols = ['jsonp-polling'];                                                                         // 1247\n    }                                                                                                                // 1248\n// </METEOR>                                                                                                         // 1249\n};                                                                                                                   // 1250\n//         [*] End of lib/sockjs.js                                                                                  // 1251\n                                                                                                                     // 1252\n                                                                                                                     // 1253\n//         [*] Including lib/trans-websocket.js                                                                      // 1254\n/*                                                                                                                   // 1255\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1256\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1257\n *                                                                                                                   // 1258\n * For the license see COPYING.                                                                                      // 1259\n * ***** END LICENSE BLOCK *****                                                                                     // 1260\n */                                                                                                                  // 1261\n                                                                                                                     // 1262\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {                                                // 1263\n    var that = this;                                                                                                 // 1264\n    var url = trans_url + '/websocket';                                                                              // 1265\n    if (url.slice(0, 5) === 'https') {                                                                               // 1266\n        url = 'wss' + url.slice(5);                                                                                  // 1267\n    } else {                                                                                                         // 1268\n        url = 'ws' + url.slice(4);                                                                                   // 1269\n    }                                                                                                                // 1270\n    that.ri = ri;                                                                                                    // 1271\n    that.url = url;                                                                                                  // 1272\n    var Constructor = _window.WebSocket || _window.MozWebSocket;                                                     // 1273\n                                                                                                                     // 1274\n    that.ws = new Constructor(that.url);                                                                             // 1275\n    that.ws.onmessage = function(e) {                                                                                // 1276\n        that.ri._didMessage(e.data);                                                                                 // 1277\n    };                                                                                                               // 1278\n    // Firefox has an interesting bug. If a websocket connection is                                                  // 1279\n    // created after onunload, it stays alive even when user                                                         // 1280\n    // navigates away from the page. In such situation let's lie -                                                   // 1281\n    // let's not open the ws connection at all. See:                                                                 // 1282\n    // https://github.com/sockjs/sockjs-client/issues/28                                                             // 1283\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085                                                           // 1284\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});                                                 // 1285\n    that.ws.onclose = function() {                                                                                   // 1286\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));                                  // 1287\n    };                                                                                                               // 1288\n};                                                                                                                   // 1289\n                                                                                                                     // 1290\nWebSocketTransport.prototype.doSend = function(data) {                                                               // 1291\n    this.ws.send('[' + data + ']');                                                                                  // 1292\n};                                                                                                                   // 1293\n                                                                                                                     // 1294\nWebSocketTransport.prototype.doCleanup = function() {                                                                // 1295\n    var that = this;                                                                                                 // 1296\n    var ws = that.ws;                                                                                                // 1297\n    if (ws) {                                                                                                        // 1298\n        ws.onmessage = ws.onclose = null;                                                                            // 1299\n        ws.close();                                                                                                  // 1300\n        utils.unload_del(that.unload_ref);                                                                           // 1301\n        that.unload_ref = that.ri = that.ws = null;                                                                  // 1302\n    }                                                                                                                // 1303\n};                                                                                                                   // 1304\n                                                                                                                     // 1305\nWebSocketTransport.enabled = function() {                                                                            // 1306\n    return !!(_window.WebSocket || _window.MozWebSocket);                                                            // 1307\n};                                                                                                                   // 1308\n                                                                                                                     // 1309\n// In theory, ws should require 1 round trip. But in chrome, this is                                                 // 1310\n// not very stable over SSL. Most likely a ws connection requires a                                                  // 1311\n// separate SSL connection, in which case 2 round trips are an                                                       // 1312\n// absolute minumum.                                                                                                 // 1313\nWebSocketTransport.roundTrips = 2;                                                                                   // 1314\n//         [*] End of lib/trans-websocket.js                                                                         // 1315\n                                                                                                                     // 1316\n                                                                                                                     // 1317\n//         [*] Including lib/trans-sender.js                                                                         // 1318\n/*                                                                                                                   // 1319\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1320\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1321\n *                                                                                                                   // 1322\n * For the license see COPYING.                                                                                      // 1323\n * ***** END LICENSE BLOCK *****                                                                                     // 1324\n */                                                                                                                  // 1325\n                                                                                                                     // 1326\nvar BufferedSender = function() {};                                                                                  // 1327\nBufferedSender.prototype.send_constructor = function(sender) {                                                       // 1328\n    var that = this;                                                                                                 // 1329\n    that.send_buffer = [];                                                                                           // 1330\n    that.sender = sender;                                                                                            // 1331\n};                                                                                                                   // 1332\nBufferedSender.prototype.doSend = function(message) {                                                                // 1333\n    var that = this;                                                                                                 // 1334\n    that.send_buffer.push(message);                                                                                  // 1335\n    if (!that.send_stop) {                                                                                           // 1336\n        that.send_schedule();                                                                                        // 1337\n    }                                                                                                                // 1338\n};                                                                                                                   // 1339\n                                                                                                                     // 1340\n// For polling transports in a situation when in the message callback,                                               // 1341\n// new message is being send. If the sending connection was started                                                  // 1342\n// before receiving one, it is possible to saturate the network and                                                  // 1343\n// timeout due to the lack of receiving socket. To avoid that we delay                                               // 1344\n// sending messages by some small time, in order to let receiving                                                    // 1345\n// connection be started beforehand. This is only a halfmeasure and                                                  // 1346\n// does not fix the big problem, but it does make the tests go more                                                  // 1347\n// stable on slow networks.                                                                                          // 1348\nBufferedSender.prototype.send_schedule_wait = function() {                                                           // 1349\n    var that = this;                                                                                                 // 1350\n    var tref;                                                                                                        // 1351\n    that.send_stop = function() {                                                                                    // 1352\n        that.send_stop = null;                                                                                       // 1353\n        clearTimeout(tref);                                                                                          // 1354\n    };                                                                                                               // 1355\n    tref = utils.delay(25, function() {                                                                              // 1356\n        that.send_stop = null;                                                                                       // 1357\n        that.send_schedule();                                                                                        // 1358\n    });                                                                                                              // 1359\n};                                                                                                                   // 1360\n                                                                                                                     // 1361\nBufferedSender.prototype.send_schedule = function() {                                                                // 1362\n    var that = this;                                                                                                 // 1363\n    if (that.send_buffer.length > 0) {                                                                               // 1364\n        var payload = '[' + that.send_buffer.join(',') + ']';                                                        // 1365\n        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {                      // 1366\n            that.send_stop = null;                                                                                   // 1367\n            if (success === false) {                                                                                 // 1368\n                that.ri._didClose(1006, 'Sending error ' + abort_reason);                                            // 1369\n            } else {                                                                                                 // 1370\n                that.send_schedule_wait();                                                                           // 1371\n            }                                                                                                        // 1372\n        });                                                                                                          // 1373\n        that.send_buffer = [];                                                                                       // 1374\n    }                                                                                                                // 1375\n};                                                                                                                   // 1376\n                                                                                                                     // 1377\nBufferedSender.prototype.send_destructor = function() {                                                              // 1378\n    var that = this;                                                                                                 // 1379\n    if (that._send_stop) {                                                                                           // 1380\n        that._send_stop();                                                                                           // 1381\n    }                                                                                                                // 1382\n    that._send_stop = null;                                                                                          // 1383\n};                                                                                                                   // 1384\n                                                                                                                     // 1385\nvar jsonPGenericSender = function(url, payload, callback) {                                                          // 1386\n    var that = this;                                                                                                 // 1387\n                                                                                                                     // 1388\n    if (!('_send_form' in that)) {                                                                                   // 1389\n        var form = that._send_form = _document.createElement('form');                                                // 1390\n        var area = that._send_area = _document.createElement('textarea');                                            // 1391\n        area.name = 'd';                                                                                             // 1392\n        form.style.display = 'none';                                                                                 // 1393\n        form.style.position = 'absolute';                                                                            // 1394\n        form.method = 'POST';                                                                                        // 1395\n        form.enctype = 'application/x-www-form-urlencoded';                                                          // 1396\n        form.acceptCharset = \"UTF-8\";                                                                                // 1397\n        form.appendChild(area);                                                                                      // 1398\n        _document.body.appendChild(form);                                                                            // 1399\n    }                                                                                                                // 1400\n    var form = that._send_form;                                                                                      // 1401\n    var area = that._send_area;                                                                                      // 1402\n    var id = 'a' + utils.random_string(8);                                                                           // 1403\n    form.target = id;                                                                                                // 1404\n    form.action = url + '/jsonp_send?i=' + id;                                                                       // 1405\n                                                                                                                     // 1406\n    var iframe;                                                                                                      // 1407\n    try {                                                                                                            // 1408\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)                                       // 1409\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');                                                // 1410\n    } catch(x) {                                                                                                     // 1411\n        iframe = _document.createElement('iframe');                                                                  // 1412\n        iframe.name = id;                                                                                            // 1413\n    }                                                                                                                // 1414\n    iframe.id = id;                                                                                                  // 1415\n    form.appendChild(iframe);                                                                                        // 1416\n    iframe.style.display = 'none';                                                                                   // 1417\n                                                                                                                     // 1418\n    try {                                                                                                            // 1419\n        area.value = payload;                                                                                        // 1420\n    } catch(e) {                                                                                                     // 1421\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);                                        // 1422\n    }                                                                                                                // 1423\n    form.submit();                                                                                                   // 1424\n                                                                                                                     // 1425\n    var completed = function(e) {                                                                                    // 1426\n        if (!iframe.onerror) return;                                                                                 // 1427\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;                                           // 1428\n        // Opera mini doesn't like if we GC iframe                                                                   // 1429\n        // immediately, thus this timeout.                                                                           // 1430\n        utils.delay(500, function() {                                                                                // 1431\n                       iframe.parentNode.removeChild(iframe);                                                        // 1432\n                       iframe = null;                                                                                // 1433\n                   });                                                                                               // 1434\n        area.value = '';                                                                                             // 1435\n        // It is not possible to detect if the iframe succeeded or                                                   // 1436\n        // failed to submit our form.                                                                                // 1437\n        callback(true);                                                                                              // 1438\n    };                                                                                                               // 1439\n    iframe.onerror = iframe.onload = completed;                                                                      // 1440\n    iframe.onreadystatechange = function(e) {                                                                        // 1441\n        if (iframe.readyState == 'complete') completed();                                                            // 1442\n    };                                                                                                               // 1443\n    return completed;                                                                                                // 1444\n};                                                                                                                   // 1445\n                                                                                                                     // 1446\nvar createAjaxSender = function(AjaxObject) {                                                                        // 1447\n    return function(url, payload, callback) {                                                                        // 1448\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);                                                 // 1449\n        xo.onfinish = function(status, text) {                                                                       // 1450\n            callback(status === 200 || status === 204,                                                               // 1451\n                     'http status ' + status);                                                                       // 1452\n        };                                                                                                           // 1453\n        return function(abort_reason) {                                                                              // 1454\n            callback(false, abort_reason);                                                                           // 1455\n        };                                                                                                           // 1456\n    };                                                                                                               // 1457\n};                                                                                                                   // 1458\n//         [*] End of lib/trans-sender.js                                                                            // 1459\n                                                                                                                     // 1460\n                                                                                                                     // 1461\n//         [*] Including lib/trans-jsonp-receiver.js                                                                 // 1462\n/*                                                                                                                   // 1463\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1464\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1465\n *                                                                                                                   // 1466\n * For the license see COPYING.                                                                                      // 1467\n * ***** END LICENSE BLOCK *****                                                                                     // 1468\n */                                                                                                                  // 1469\n                                                                                                                     // 1470\n// Parts derived from Socket.io:                                                                                     // 1471\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js                  // 1472\n// and jQuery-JSONP:                                                                                                 // 1473\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js                                // 1474\nvar jsonPGenericReceiver = function(url, callback) {                                                                 // 1475\n    var tref;                                                                                                        // 1476\n    var script = _document.createElement('script');                                                                  // 1477\n    var script2;  // Opera synchronous load trick.                                                                   // 1478\n    var close_script = function(frame) {                                                                             // 1479\n        if (script2) {                                                                                               // 1480\n            script2.parentNode.removeChild(script2);                                                                 // 1481\n            script2 = null;                                                                                          // 1482\n        }                                                                                                            // 1483\n        if (script) {                                                                                                // 1484\n            clearTimeout(tref);                                                                                      // 1485\n            // Unfortunately, you can't really abort script loading of                                               // 1486\n            // the script.                                                                                           // 1487\n            script.parentNode.removeChild(script);                                                                   // 1488\n            script.onreadystatechange = script.onerror =                                                             // 1489\n                script.onload = script.onclick = null;                                                               // 1490\n            script = null;                                                                                           // 1491\n            callback(frame);                                                                                         // 1492\n            callback = null;                                                                                         // 1493\n        }                                                                                                            // 1494\n    };                                                                                                               // 1495\n                                                                                                                     // 1496\n    // IE9 fires 'error' event after orsc or before, in random order.                                                // 1497\n    var loaded_okay = false;                                                                                         // 1498\n    var error_timer = null;                                                                                          // 1499\n                                                                                                                     // 1500\n    script.id = 'a' + utils.random_string(8);                                                                        // 1501\n    script.src = url;                                                                                                // 1502\n    script.type = 'text/javascript';                                                                                 // 1503\n    script.charset = 'UTF-8';                                                                                        // 1504\n    script.onerror = function(e) {                                                                                   // 1505\n        if (!error_timer) {                                                                                          // 1506\n            // Delay firing close_script.                                                                            // 1507\n            error_timer = setTimeout(function() {                                                                    // 1508\n                if (!loaded_okay) {                                                                                  // 1509\n                    close_script(utils.closeFrame(                                                                   // 1510\n                        1006,                                                                                        // 1511\n                        \"JSONP script loaded abnormally (onerror)\"));                                                // 1512\n                }                                                                                                    // 1513\n            }, 1000);                                                                                                // 1514\n        }                                                                                                            // 1515\n    };                                                                                                               // 1516\n    script.onload = function(e) {                                                                                    // 1517\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));                             // 1518\n    };                                                                                                               // 1519\n                                                                                                                     // 1520\n    script.onreadystatechange = function(e) {                                                                        // 1521\n        if (/loaded|closed/.test(script.readyState)) {                                                               // 1522\n            if (script && script.htmlFor && script.onclick) {                                                        // 1523\n                loaded_okay = true;                                                                                  // 1524\n                try {                                                                                                // 1525\n                    // In IE, actually execute the script.                                                           // 1526\n                    script.onclick();                                                                                // 1527\n                } catch (x) {}                                                                                       // 1528\n            }                                                                                                        // 1529\n            if (script) {                                                                                            // 1530\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));         // 1531\n            }                                                                                                        // 1532\n        }                                                                                                            // 1533\n    };                                                                                                               // 1534\n    // IE: event/htmlFor/onclick trick.                                                                              // 1535\n    // One can't rely on proper order for onreadystatechange. In order to                                            // 1536\n    // make sure, set a 'htmlFor' and 'event' properties, so that                                                    // 1537\n    // script code will be installed as 'onclick' handler for the                                                    // 1538\n    // script object. Later, onreadystatechange, manually execute this                                               // 1539\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'                                                   // 1540\n    // set. For reference see:                                                                                       // 1541\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html                                       // 1542\n    // Also, read on that about script ordering:                                                                     // 1543\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order                                                  // 1544\n    if (typeof script.async === 'undefined' && _document.attachEvent) {                                              // 1545\n        // According to mozilla docs, in recent browsers script.async defaults                                       // 1546\n        // to 'true', so we may use it to detect a good browser:                                                     // 1547\n        // https://developer.mozilla.org/en/HTML/Element/script                                                      // 1548\n        if (!/opera/i.test(navigator.userAgent)) {                                                                   // 1549\n            // Naively assume we're in IE                                                                            // 1550\n            try {                                                                                                    // 1551\n                script.htmlFor = script.id;                                                                          // 1552\n                script.event = \"onclick\";                                                                            // 1553\n            } catch (x) {}                                                                                           // 1554\n            script.async = true;                                                                                     // 1555\n        } else {                                                                                                     // 1556\n            // Opera, second sync script hack                                                                        // 1557\n            script2 = _document.createElement('script');                                                             // 1558\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";    // 1559\n            script.async = script2.async = false;                                                                    // 1560\n        }                                                                                                            // 1561\n    }                                                                                                                // 1562\n    if (typeof script.async !== 'undefined') {                                                                       // 1563\n        script.async = true;                                                                                         // 1564\n    }                                                                                                                // 1565\n                                                                                                                     // 1566\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.                                     // 1567\n    tref = setTimeout(function() {                                                                                   // 1568\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));          // 1569\n                      }, 35000);                                                                                     // 1570\n                                                                                                                     // 1571\n    var head = _document.getElementsByTagName('head')[0];                                                            // 1572\n    head.insertBefore(script, head.firstChild);                                                                      // 1573\n    if (script2) {                                                                                                   // 1574\n        head.insertBefore(script2, head.firstChild);                                                                 // 1575\n    }                                                                                                                // 1576\n    return close_script;                                                                                             // 1577\n};                                                                                                                   // 1578\n//         [*] End of lib/trans-jsonp-receiver.js                                                                    // 1579\n                                                                                                                     // 1580\n                                                                                                                     // 1581\n//         [*] Including lib/trans-jsonp-polling.js                                                                  // 1582\n/*                                                                                                                   // 1583\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1584\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1585\n *                                                                                                                   // 1586\n * For the license see COPYING.                                                                                      // 1587\n * ***** END LICENSE BLOCK *****                                                                                     // 1588\n */                                                                                                                  // 1589\n                                                                                                                     // 1590\n// The simplest and most robust transport, using the well-know cross                                                 // 1591\n// domain hack - JSONP. This transport is quite inefficient - one                                                    // 1592\n// mssage could use up to one http request. But at least it works almost                                             // 1593\n// everywhere.                                                                                                       // 1594\n// Known limitations:                                                                                                // 1595\n//   o you will get a spinning cursor                                                                                // 1596\n//   o for Konqueror a dumb timer is needed to detect errors                                                         // 1597\n                                                                                                                     // 1598\n                                                                                                                     // 1599\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {                                             // 1600\n    utils.polluteGlobalNamespace();                                                                                  // 1601\n    var that = this;                                                                                                 // 1602\n    that.ri = ri;                                                                                                    // 1603\n    that.trans_url = trans_url;                                                                                      // 1604\n    that.send_constructor(jsonPGenericSender);                                                                       // 1605\n    that._schedule_recv();                                                                                           // 1606\n};                                                                                                                   // 1607\n                                                                                                                     // 1608\n// Inheritnace                                                                                                       // 1609\nJsonPTransport.prototype = new BufferedSender();                                                                     // 1610\n                                                                                                                     // 1611\nJsonPTransport.prototype._schedule_recv = function() {                                                               // 1612\n    var that = this;                                                                                                 // 1613\n    var callback = function(data) {                                                                                  // 1614\n        that._recv_stop = null;                                                                                      // 1615\n        if (data) {                                                                                                  // 1616\n            // no data - heartbeat;                                                                                  // 1617\n            if (!that._is_closing) {                                                                                 // 1618\n                that.ri._didMessage(data);                                                                           // 1619\n            }                                                                                                        // 1620\n        }                                                                                                            // 1621\n        // The message can be a close message, and change is_closing state.                                          // 1622\n        if (!that._is_closing) {                                                                                     // 1623\n            that._schedule_recv();                                                                                   // 1624\n        }                                                                                                            // 1625\n    };                                                                                                               // 1626\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',                                                // 1627\n                                           jsonPGenericReceiver, callback);                                          // 1628\n};                                                                                                                   // 1629\n                                                                                                                     // 1630\nJsonPTransport.enabled = function() {                                                                                // 1631\n    return true;                                                                                                     // 1632\n};                                                                                                                   // 1633\n                                                                                                                     // 1634\nJsonPTransport.need_body = true;                                                                                     // 1635\n                                                                                                                     // 1636\n                                                                                                                     // 1637\nJsonPTransport.prototype.doCleanup = function() {                                                                    // 1638\n    var that = this;                                                                                                 // 1639\n    that._is_closing = true;                                                                                         // 1640\n    if (that._recv_stop) {                                                                                           // 1641\n        that._recv_stop();                                                                                           // 1642\n    }                                                                                                                // 1643\n    that.ri = that._recv_stop = null;                                                                                // 1644\n    that.send_destructor();                                                                                          // 1645\n};                                                                                                                   // 1646\n                                                                                                                     // 1647\n                                                                                                                     // 1648\n// Abstract away code that handles global namespace pollution.                                                       // 1649\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {                                         // 1650\n    var id = 'a' + utils.random_string(6);                                                                           // 1651\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);                                                           // 1652\n                                                                                                                     // 1653\n    // Unfortunately it is not possible to abort loading of the                                                      // 1654\n    // script. We need to keep track of frake close frames.                                                          // 1655\n    var aborting = 0;                                                                                                // 1656\n                                                                                                                     // 1657\n    // Callback will be called exactly once.                                                                         // 1658\n    var callback = function(frame) {                                                                                 // 1659\n        switch(aborting) {                                                                                           // 1660\n        case 0:                                                                                                      // 1661\n            // Normal behaviour - delete hook _and_ emit message.                                                    // 1662\n            delete _window[WPrefix][id];                                                                             // 1663\n            user_callback(frame);                                                                                    // 1664\n            break;                                                                                                   // 1665\n        case 1:                                                                                                      // 1666\n            // Fake close frame - emit but don't delete hook.                                                        // 1667\n            user_callback(frame);                                                                                    // 1668\n            aborting = 2;                                                                                            // 1669\n            break;                                                                                                   // 1670\n        case 2:                                                                                                      // 1671\n            // Got frame after connection was closed, delete hook, don't emit.                                       // 1672\n            delete _window[WPrefix][id];                                                                             // 1673\n            break;                                                                                                   // 1674\n        }                                                                                                            // 1675\n    };                                                                                                               // 1676\n                                                                                                                     // 1677\n    var close_script = constructReceiver(url_id, callback);                                                          // 1678\n    _window[WPrefix][id] = close_script;                                                                             // 1679\n    var stop = function() {                                                                                          // 1680\n        if (_window[WPrefix][id]) {                                                                                  // 1681\n            aborting = 1;                                                                                            // 1682\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));                                 // 1683\n        }                                                                                                            // 1684\n    };                                                                                                               // 1685\n    return stop;                                                                                                     // 1686\n};                                                                                                                   // 1687\n//         [*] End of lib/trans-jsonp-polling.js                                                                     // 1688\n                                                                                                                     // 1689\n                                                                                                                     // 1690\n//         [*] Including lib/trans-xhr.js                                                                            // 1691\n/*                                                                                                                   // 1692\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1693\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1694\n *                                                                                                                   // 1695\n * For the license see COPYING.                                                                                      // 1696\n * ***** END LICENSE BLOCK *****                                                                                     // 1697\n */                                                                                                                  // 1698\n                                                                                                                     // 1699\nvar AjaxBasedTransport = function() {};                                                                              // 1700\nAjaxBasedTransport.prototype = new BufferedSender();                                                                 // 1701\n                                                                                                                     // 1702\nAjaxBasedTransport.prototype.run = function(ri, trans_url,                                                           // 1703\n                                            url_suffix, Receiver, AjaxObject) {                                      // 1704\n    var that = this;                                                                                                 // 1705\n    that.ri = ri;                                                                                                    // 1706\n    that.trans_url = trans_url;                                                                                      // 1707\n    that.send_constructor(createAjaxSender(AjaxObject));                                                             // 1708\n    that.poll = new Polling(ri, Receiver,                                                                            // 1709\n                            trans_url + url_suffix, AjaxObject);                                                     // 1710\n};                                                                                                                   // 1711\n                                                                                                                     // 1712\nAjaxBasedTransport.prototype.doCleanup = function() {                                                                // 1713\n    var that = this;                                                                                                 // 1714\n    if (that.poll) {                                                                                                 // 1715\n        that.poll.abort();                                                                                           // 1716\n        that.poll = null;                                                                                            // 1717\n    }                                                                                                                // 1718\n};                                                                                                                   // 1719\n                                                                                                                     // 1720\n// xhr-streaming                                                                                                     // 1721\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {                                      // 1722\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);                                     // 1723\n};                                                                                                                   // 1724\n                                                                                                                     // 1725\nXhrStreamingTransport.prototype = new AjaxBasedTransport();                                                          // 1726\n                                                                                                                     // 1727\nXhrStreamingTransport.enabled = function() {                                                                         // 1728\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but                                                     // 1729\n    // doesn't do streaming.                                                                                         // 1730\n    return (_window.XMLHttpRequest &&                                                                                // 1731\n            'withCredentials' in new XMLHttpRequest() &&                                                             // 1732\n            (!/opera/i.test(navigator.userAgent)));                                                                  // 1733\n};                                                                                                                   // 1734\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax                                                             // 1735\n                                                                                                                     // 1736\n// Safari gets confused when a streaming ajax request is started                                                     // 1737\n// before onload. This causes the load indicator to spin indefinetely.                                               // 1738\nXhrStreamingTransport.need_body = true;                                                                              // 1739\n                                                                                                                     // 1740\n                                                                                                                     // 1741\n// According to:                                                                                                     // 1742\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests              // 1743\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/                                           // 1744\n                                                                                                                     // 1745\n                                                                                                                     // 1746\n// xdr-streaming                                                                                                     // 1747\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {                                      // 1748\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);                                         // 1749\n};                                                                                                                   // 1750\n                                                                                                                     // 1751\nXdrStreamingTransport.prototype = new AjaxBasedTransport();                                                          // 1752\n                                                                                                                     // 1753\nXdrStreamingTransport.enabled = function() {                                                                         // 1754\n    return !!_window.XDomainRequest;                                                                                 // 1755\n};                                                                                                                   // 1756\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax                                                             // 1757\n                                                                                                                     // 1758\n                                                                                                                     // 1759\n                                                                                                                     // 1760\n// xhr-polling                                                                                                       // 1761\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {                                          // 1762\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);                                               // 1763\n};                                                                                                                   // 1764\n                                                                                                                     // 1765\nXhrPollingTransport.prototype = new AjaxBasedTransport();                                                            // 1766\n                                                                                                                     // 1767\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;                                                         // 1768\nXhrPollingTransport.roundTrips = 2; // preflight, ajax                                                               // 1769\n                                                                                                                     // 1770\n                                                                                                                     // 1771\n// xdr-polling                                                                                                       // 1772\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {                                          // 1773\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);                                                   // 1774\n};                                                                                                                   // 1775\n                                                                                                                     // 1776\nXdrPollingTransport.prototype = new AjaxBasedTransport();                                                            // 1777\n                                                                                                                     // 1778\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;                                                         // 1779\nXdrPollingTransport.roundTrips = 2; // preflight, ajax                                                               // 1780\n//         [*] End of lib/trans-xhr.js                                                                               // 1781\n                                                                                                                     // 1782\n                                                                                                                     // 1783\n//         [*] Including lib/trans-iframe.js                                                                         // 1784\n/*                                                                                                                   // 1785\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1786\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1787\n *                                                                                                                   // 1788\n * For the license see COPYING.                                                                                      // 1789\n * ***** END LICENSE BLOCK *****                                                                                     // 1790\n */                                                                                                                  // 1791\n                                                                                                                     // 1792\n// Few cool transports do work only for same-origin. In order to make                                                // 1793\n// them working cross-domain we shall use iframe, served form the                                                    // 1794\n// remote domain. New browsers, have capabilities to communicate with                                                // 1795\n// cross domain iframe, using postMessage(). In IE it was implemented                                                // 1796\n// from IE 8+, but of course, IE got some details wrong:                                                             // 1797\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx                                                 // 1798\n//    http://stevesouders.com/misc/test-postmessage.php                                                              // 1799\n                                                                                                                     // 1800\nvar IframeTransport = function() {};                                                                                 // 1801\n                                                                                                                     // 1802\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {                                        // 1803\n    var that = this;                                                                                                 // 1804\n    that.ri = ri;                                                                                                    // 1805\n    that.origin = utils.getOrigin(base_url);                                                                         // 1806\n    that.base_url = base_url;                                                                                        // 1807\n    that.trans_url = trans_url;                                                                                      // 1808\n                                                                                                                     // 1809\n    var iframe_url = base_url + '/iframe.html';                                                                      // 1810\n    if (that.ri._options.devel) {                                                                                    // 1811\n        iframe_url += '?t=' + (+new Date);                                                                           // 1812\n    }                                                                                                                // 1813\n    that.window_id = utils.random_string(8);                                                                         // 1814\n    iframe_url += '#' + that.window_id;                                                                              // 1815\n                                                                                                                     // 1816\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {                                                    // 1817\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");         // 1818\n                                        });                                                                          // 1819\n                                                                                                                     // 1820\n    that.onmessage_cb = utils.bind(that.onmessage, that);                                                            // 1821\n    utils.attachMessage(that.onmessage_cb);                                                                          // 1822\n};                                                                                                                   // 1823\n                                                                                                                     // 1824\nIframeTransport.prototype.doCleanup = function() {                                                                   // 1825\n    var that = this;                                                                                                 // 1826\n    if (that.iframeObj) {                                                                                            // 1827\n        utils.detachMessage(that.onmessage_cb);                                                                      // 1828\n        try {                                                                                                        // 1829\n            // When the iframe is not loaded, IE raises an exception                                                 // 1830\n            // on 'contentWindow'.                                                                                   // 1831\n            if (that.iframeObj.iframe.contentWindow) {                                                               // 1832\n                that.postMessage('c');                                                                               // 1833\n            }                                                                                                        // 1834\n        } catch (x) {}                                                                                               // 1835\n        that.iframeObj.cleanup();                                                                                    // 1836\n        that.iframeObj = null;                                                                                       // 1837\n        that.onmessage_cb = that.iframeObj = null;                                                                   // 1838\n    }                                                                                                                // 1839\n};                                                                                                                   // 1840\n                                                                                                                     // 1841\nIframeTransport.prototype.onmessage = function(e) {                                                                  // 1842\n    var that = this;                                                                                                 // 1843\n    if (e.origin !== that.origin) return;                                                                            // 1844\n    var window_id = e.data.slice(0, 8);                                                                              // 1845\n    var type = e.data.slice(8, 9);                                                                                   // 1846\n    var data = e.data.slice(9);                                                                                      // 1847\n                                                                                                                     // 1848\n    if (window_id !== that.window_id) return;                                                                        // 1849\n                                                                                                                     // 1850\n    switch(type) {                                                                                                   // 1851\n    case 's':                                                                                                        // 1852\n        that.iframeObj.loaded();                                                                                     // 1853\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));       // 1854\n        break;                                                                                                       // 1855\n    case 't':                                                                                                        // 1856\n        that.ri._didMessage(data);                                                                                   // 1857\n        break;                                                                                                       // 1858\n    }                                                                                                                // 1859\n};                                                                                                                   // 1860\n                                                                                                                     // 1861\nIframeTransport.prototype.postMessage = function(type, data) {                                                       // 1862\n    var that = this;                                                                                                 // 1863\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);                                          // 1864\n};                                                                                                                   // 1865\n                                                                                                                     // 1866\nIframeTransport.prototype.doSend = function (message) {                                                              // 1867\n    this.postMessage('m', message);                                                                                  // 1868\n};                                                                                                                   // 1869\n                                                                                                                     // 1870\nIframeTransport.enabled = function() {                                                                               // 1871\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with                                   // 1872\n    // huge delay, or not at all.                                                                                    // 1873\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;             // 1874\n    return ((typeof _window.postMessage === 'function' ||                                                            // 1875\n            typeof _window.postMessage === 'object') && (!konqueror));                                               // 1876\n};                                                                                                                   // 1877\n//         [*] End of lib/trans-iframe.js                                                                            // 1878\n                                                                                                                     // 1879\n                                                                                                                     // 1880\n//         [*] Including lib/trans-iframe-within.js                                                                  // 1881\n/*                                                                                                                   // 1882\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1883\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1884\n *                                                                                                                   // 1885\n * For the license see COPYING.                                                                                      // 1886\n * ***** END LICENSE BLOCK *****                                                                                     // 1887\n */                                                                                                                  // 1888\n                                                                                                                     // 1889\nvar curr_window_id;                                                                                                  // 1890\n                                                                                                                     // 1891\nvar postMessage = function (type, data) {                                                                            // 1892\n    if(parent !== _window) {                                                                                         // 1893\n        parent.postMessage(curr_window_id + type + (data || ''), '*');                                               // 1894\n    } else {                                                                                                         // 1895\n        utils.log(\"Can't postMessage, no parent window.\", type, data);                                               // 1896\n    }                                                                                                                // 1897\n};                                                                                                                   // 1898\n                                                                                                                     // 1899\nvar FacadeJS = function() {};                                                                                        // 1900\nFacadeJS.prototype._didClose = function (code, reason) {                                                             // 1901\n    postMessage('t', utils.closeFrame(code, reason));                                                                // 1902\n};                                                                                                                   // 1903\nFacadeJS.prototype._didMessage = function (frame) {                                                                  // 1904\n    postMessage('t', frame);                                                                                         // 1905\n};                                                                                                                   // 1906\nFacadeJS.prototype._doSend = function (data) {                                                                       // 1907\n    this._transport.doSend(data);                                                                                    // 1908\n};                                                                                                                   // 1909\nFacadeJS.prototype._doCleanup = function () {                                                                        // 1910\n    this._transport.doCleanup();                                                                                     // 1911\n};                                                                                                                   // 1912\n                                                                                                                     // 1913\nutils.parent_origin = undefined;                                                                                     // 1914\n                                                                                                                     // 1915\nSockJS.bootstrap_iframe = function() {                                                                               // 1916\n    var facade;                                                                                                      // 1917\n    curr_window_id = _document.location.hash.slice(1);                                                               // 1918\n    var onMessage = function(e) {                                                                                    // 1919\n        if(e.source !== parent) return;                                                                              // 1920\n        if(typeof utils.parent_origin === 'undefined')                                                               // 1921\n            utils.parent_origin = e.origin;                                                                          // 1922\n        if (e.origin !== utils.parent_origin) return;                                                                // 1923\n                                                                                                                     // 1924\n        var window_id = e.data.slice(0, 8);                                                                          // 1925\n        var type = e.data.slice(8, 9);                                                                               // 1926\n        var data = e.data.slice(9);                                                                                  // 1927\n        if (window_id !== curr_window_id) return;                                                                    // 1928\n        switch(type) {                                                                                               // 1929\n        case 's':                                                                                                    // 1930\n            var p = JSON.parse(data);                                                                                // 1931\n            var version = p[0];                                                                                      // 1932\n            var protocol = p[1];                                                                                     // 1933\n            var trans_url = p[2];                                                                                    // 1934\n            var base_url = p[3];                                                                                     // 1935\n            if (version !== SockJS.version) {                                                                        // 1936\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +                                                  // 1937\n                          \" \\\"\" + version + \"\\\", the iframe:\" +                                                      // 1938\n                          \" \\\"\" + SockJS.version + \"\\\".\");                                                           // 1939\n            }                                                                                                        // 1940\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {                                             // 1941\n                utils.log(\"Only basic urls are supported in SockJS\");                                                // 1942\n                return;                                                                                              // 1943\n            }                                                                                                        // 1944\n                                                                                                                     // 1945\n            if (!utils.isSameOriginUrl(trans_url) ||                                                                 // 1946\n                !utils.isSameOriginUrl(base_url)) {                                                                  // 1947\n                utils.log(\"Can't connect to different domain from within an \" +                                      // 1948\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +               // 1949\n                          \")\");                                                                                      // 1950\n                return;                                                                                              // 1951\n            }                                                                                                        // 1952\n            facade = new FacadeJS();                                                                                 // 1953\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);                                 // 1954\n            break;                                                                                                   // 1955\n        case 'm':                                                                                                    // 1956\n            facade._doSend(data);                                                                                    // 1957\n            break;                                                                                                   // 1958\n        case 'c':                                                                                                    // 1959\n            if (facade)                                                                                              // 1960\n                facade._doCleanup();                                                                                 // 1961\n            facade = null;                                                                                           // 1962\n            break;                                                                                                   // 1963\n        }                                                                                                            // 1964\n    };                                                                                                               // 1965\n                                                                                                                     // 1966\n    // alert('test ticker');                                                                                         // 1967\n    // facade = new FacadeJS();                                                                                      // 1968\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');      // 1969\n                                                                                                                     // 1970\n    utils.attachMessage(onMessage);                                                                                  // 1971\n                                                                                                                     // 1972\n    // Start                                                                                                         // 1973\n    postMessage('s');                                                                                                // 1974\n};                                                                                                                   // 1975\n//         [*] End of lib/trans-iframe-within.js                                                                     // 1976\n                                                                                                                     // 1977\n                                                                                                                     // 1978\n//         [*] Including lib/info.js                                                                                 // 1979\n/*                                                                                                                   // 1980\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 1981\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 1982\n *                                                                                                                   // 1983\n * For the license see COPYING.                                                                                      // 1984\n * ***** END LICENSE BLOCK *****                                                                                     // 1985\n */                                                                                                                  // 1986\n                                                                                                                     // 1987\nvar InfoReceiver = function(base_url, AjaxObject) {                                                                  // 1988\n    var that = this;                                                                                                 // 1989\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});                                                      // 1990\n};                                                                                                                   // 1991\n                                                                                                                     // 1992\nInfoReceiver.prototype = new EventEmitter(['finish']);                                                               // 1993\n                                                                                                                     // 1994\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {                                                      // 1995\n    var that = this;                                                                                                 // 1996\n    var t0 = (new Date()).getTime();                                                                                 // 1997\n                                                                                                                     // 1998\n// <METEOR>                                                                                                          // 1999\n  // https://github.com/sockjs/sockjs-client/pull/129                                                                // 2000\n  // var xo = new AjaxObject('GET', base_url + '/info');                                                             // 2001\n                                                                                                                     // 2002\n    var xo = new AjaxObject(                                                                                         // 2003\n      // add cachebusting parameter to url to work around a chrome bug:                                              // 2004\n      // https://code.google.com/p/chromium/issues/detail?id=263981                                                  // 2005\n      // or misbehaving proxies.                                                                                     // 2006\n      'GET', base_url + '/info?cb=' + utils.random_string(10))                                                       // 2007\n// </METEOR>                                                                                                         // 2008\n                                                                                                                     // 2009\n    var tref = utils.delay(8000,                                                                                     // 2010\n                           function(){xo.ontimeout();});                                                             // 2011\n                                                                                                                     // 2012\n    xo.onfinish = function(status, text) {                                                                           // 2013\n        clearTimeout(tref);                                                                                          // 2014\n        tref = null;                                                                                                 // 2015\n        if (status === 200) {                                                                                        // 2016\n            var rtt = (new Date()).getTime() - t0;                                                                   // 2017\n            var info = JSON.parse(text);                                                                             // 2018\n            if (typeof info !== 'object') info = {};                                                                 // 2019\n            that.emit('finish', info, rtt);                                                                          // 2020\n        } else {                                                                                                     // 2021\n            that.emit('finish');                                                                                     // 2022\n        }                                                                                                            // 2023\n    };                                                                                                               // 2024\n    xo.ontimeout = function() {                                                                                      // 2025\n        xo.close();                                                                                                  // 2026\n        that.emit('finish');                                                                                         // 2027\n    };                                                                                                               // 2028\n};                                                                                                                   // 2029\n                                                                                                                     // 2030\nvar InfoReceiverIframe = function(base_url) {                                                                        // 2031\n    var that = this;                                                                                                 // 2032\n    var go = function() {                                                                                            // 2033\n        var ifr = new IframeTransport();                                                                             // 2034\n        ifr.protocol = 'w-iframe-info-receiver';                                                                     // 2035\n        var fun = function(r) {                                                                                      // 2036\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {                                                    // 2037\n                var d = JSON.parse(r.substr(1));                                                                     // 2038\n                var info = d[0], rtt = d[1];                                                                         // 2039\n                that.emit('finish', info, rtt);                                                                      // 2040\n            } else {                                                                                                 // 2041\n                that.emit('finish');                                                                                 // 2042\n            }                                                                                                        // 2043\n            ifr.doCleanup();                                                                                         // 2044\n            ifr = null;                                                                                              // 2045\n        };                                                                                                           // 2046\n        var mock_ri = {                                                                                              // 2047\n            _options: {},                                                                                            // 2048\n            _didClose: fun,                                                                                          // 2049\n            _didMessage: fun                                                                                         // 2050\n        };                                                                                                           // 2051\n        ifr.i_constructor(mock_ri, base_url, base_url);                                                              // 2052\n    }                                                                                                                // 2053\n    if(!_document.body) {                                                                                            // 2054\n        utils.attachEvent('load', go);                                                                               // 2055\n    } else {                                                                                                         // 2056\n        go();                                                                                                        // 2057\n    }                                                                                                                // 2058\n};                                                                                                                   // 2059\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);                                                         // 2060\n                                                                                                                     // 2061\n                                                                                                                     // 2062\nvar InfoReceiverFake = function() {                                                                                  // 2063\n    // It may not be possible to do cross domain AJAX to get the info                                                // 2064\n    // data, for example for IE7. But we want to run JSONP, so let's                                                 // 2065\n    // fake the response, with rtt=2s (rto=6s).                                                                      // 2066\n    var that = this;                                                                                                 // 2067\n    utils.delay(function() {                                                                                         // 2068\n        that.emit('finish', {}, 2000);                                                                               // 2069\n    });                                                                                                              // 2070\n};                                                                                                                   // 2071\nInfoReceiverFake.prototype = new EventEmitter(['finish']);                                                           // 2072\n                                                                                                                     // 2073\nvar createInfoReceiver = function(base_url) {                                                                        // 2074\n    if (utils.isSameOriginUrl(base_url)) {                                                                           // 2075\n        // If, for some reason, we have SockJS locally - there's no                                                  // 2076\n        // need to start up the complex machinery. Just use ajax.                                                    // 2077\n        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                     // 2078\n    }                                                                                                                // 2079\n    switch (utils.isXHRCorsCapable()) {                                                                              // 2080\n    case 1:                                                                                                          // 2081\n        // XHRLocalObject -> no_credentials=true                                                                     // 2082\n        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                     // 2083\n    case 2:                                                                                                          // 2084\n// <METEOR>                                                                                                          // 2085\n// https://github.com/sockjs/sockjs-client/issues/79                                                                 // 2086\n        // XDR doesn't work across different schemes                                                                 // 2087\n        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n        if (utils.isSameOriginScheme(base_url))                                                                      // 2089\n            return new InfoReceiver(base_url, utils.XDRObject);                                                      // 2090\n        else                                                                                                         // 2091\n            return new InfoReceiverFake();                                                                           // 2092\n// </METEOR>                                                                                                         // 2093\n    case 3:                                                                                                          // 2094\n        // Opera                                                                                                     // 2095\n        return new InfoReceiverIframe(base_url);                                                                     // 2096\n    default:                                                                                                         // 2097\n        // IE 7                                                                                                      // 2098\n        return new InfoReceiverFake();                                                                               // 2099\n    };                                                                                                               // 2100\n};                                                                                                                   // 2101\n                                                                                                                     // 2102\n                                                                                                                     // 2103\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {                  // 2104\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);                                                       // 2105\n    ir.onfinish = function(info, rtt) {                                                                              // 2106\n        ri._didMessage('m'+JSON.stringify([info, rtt]));                                                             // 2107\n        ri._didClose();                                                                                              // 2108\n    }                                                                                                                // 2109\n};                                                                                                                   // 2110\nWInfoReceiverIframe.prototype.doCleanup = function() {};                                                             // 2111\n//         [*] End of lib/info.js                                                                                    // 2112\n                                                                                                                     // 2113\n                                                                                                                     // 2114\n//         [*] Including lib/trans-iframe-eventsource.js                                                             // 2115\n/*                                                                                                                   // 2116\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2117\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2118\n *                                                                                                                   // 2119\n * For the license see COPYING.                                                                                      // 2120\n * ***** END LICENSE BLOCK *****                                                                                     // 2121\n */                                                                                                                  // 2122\n                                                                                                                     // 2123\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {                                        // 2124\n    var that = this;                                                                                                 // 2125\n    that.protocol = 'w-iframe-eventsource';                                                                          // 2126\n    that.i_constructor.apply(that, arguments);                                                                       // 2127\n};                                                                                                                   // 2128\n                                                                                                                     // 2129\nEventSourceIframeTransport.prototype = new IframeTransport();                                                        // 2130\n                                                                                                                     // 2131\nEventSourceIframeTransport.enabled = function () {                                                                   // 2132\n    return ('EventSource' in _window) && IframeTransport.enabled();                                                  // 2133\n};                                                                                                                   // 2134\n                                                                                                                     // 2135\nEventSourceIframeTransport.need_body = true;                                                                         // 2136\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource                                          // 2137\n                                                                                                                     // 2138\n                                                                                                                     // 2139\n// w-iframe-eventsource                                                                                              // 2140\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {                              // 2141\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);                              // 2142\n}                                                                                                                    // 2143\nEventSourceTransport.prototype = new AjaxBasedTransport();                                                           // 2144\n//         [*] End of lib/trans-iframe-eventsource.js                                                                // 2145\n                                                                                                                     // 2146\n                                                                                                                     // 2147\n//         [*] Including lib/trans-iframe-xhr-polling.js                                                             // 2148\n/*                                                                                                                   // 2149\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2150\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2151\n *                                                                                                                   // 2152\n * For the license see COPYING.                                                                                      // 2153\n * ***** END LICENSE BLOCK *****                                                                                     // 2154\n */                                                                                                                  // 2155\n                                                                                                                     // 2156\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {                                         // 2157\n    var that = this;                                                                                                 // 2158\n    that.protocol = 'w-iframe-xhr-polling';                                                                          // 2159\n    that.i_constructor.apply(that, arguments);                                                                       // 2160\n};                                                                                                                   // 2161\n                                                                                                                     // 2162\nXhrPollingIframeTransport.prototype = new IframeTransport();                                                         // 2163\n                                                                                                                     // 2164\nXhrPollingIframeTransport.enabled = function () {                                                                    // 2165\n    return _window.XMLHttpRequest && IframeTransport.enabled();                                                      // 2166\n};                                                                                                                   // 2167\n                                                                                                                     // 2168\nXhrPollingIframeTransport.need_body = true;                                                                          // 2169\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr                                                   // 2170\n                                                                                                                     // 2171\n                                                                                                                     // 2172\n// w-iframe-xhr-polling                                                                                              // 2173\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {                              // 2174\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);                                              // 2175\n};                                                                                                                   // 2176\n                                                                                                                     // 2177\nXhrPollingITransport.prototype = new AjaxBasedTransport();                                                           // 2178\n//         [*] End of lib/trans-iframe-xhr-polling.js                                                                // 2179\n                                                                                                                     // 2180\n                                                                                                                     // 2181\n//         [*] Including lib/trans-iframe-htmlfile.js                                                                // 2182\n/*                                                                                                                   // 2183\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2184\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2185\n *                                                                                                                   // 2186\n * For the license see COPYING.                                                                                      // 2187\n * ***** END LICENSE BLOCK *****                                                                                     // 2188\n */                                                                                                                  // 2189\n                                                                                                                     // 2190\n// This transport generally works in any browser, but will cause a                                                   // 2191\n// spinning cursor to appear in any browser other than IE.                                                           // 2192\n// We may test this transport in all browsers - why not, but in                                                      // 2193\n// production it should be only run in IE.                                                                           // 2194\n                                                                                                                     // 2195\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {                                              // 2196\n    var that = this;                                                                                                 // 2197\n    that.protocol = 'w-iframe-htmlfile';                                                                             // 2198\n    that.i_constructor.apply(that, arguments);                                                                       // 2199\n};                                                                                                                   // 2200\n                                                                                                                     // 2201\n// Inheritance.                                                                                                      // 2202\nHtmlFileIframeTransport.prototype = new IframeTransport();                                                           // 2203\n                                                                                                                     // 2204\nHtmlFileIframeTransport.enabled = function() {                                                                       // 2205\n    return IframeTransport.enabled();                                                                                // 2206\n};                                                                                                                   // 2207\n                                                                                                                     // 2208\nHtmlFileIframeTransport.need_body = true;                                                                            // 2209\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile                                                // 2210\n                                                                                                                     // 2211\n                                                                                                                     // 2212\n// w-iframe-htmlfile                                                                                                 // 2213\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {                                    // 2214\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);                                    // 2215\n};                                                                                                                   // 2216\nHtmlFileTransport.prototype = new AjaxBasedTransport();                                                              // 2217\n//         [*] End of lib/trans-iframe-htmlfile.js                                                                   // 2218\n                                                                                                                     // 2219\n                                                                                                                     // 2220\n//         [*] Including lib/trans-polling.js                                                                        // 2221\n/*                                                                                                                   // 2222\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2223\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2224\n *                                                                                                                   // 2225\n * For the license see COPYING.                                                                                      // 2226\n * ***** END LICENSE BLOCK *****                                                                                     // 2227\n */                                                                                                                  // 2228\n                                                                                                                     // 2229\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {                                                         // 2230\n    var that = this;                                                                                                 // 2231\n    that.ri = ri;                                                                                                    // 2232\n    that.Receiver = Receiver;                                                                                        // 2233\n    that.recv_url = recv_url;                                                                                        // 2234\n    that.AjaxObject = AjaxObject;                                                                                    // 2235\n    that._scheduleRecv();                                                                                            // 2236\n};                                                                                                                   // 2237\n                                                                                                                     // 2238\nPolling.prototype._scheduleRecv = function() {                                                                       // 2239\n    var that = this;                                                                                                 // 2240\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);                                        // 2241\n    var msg_counter = 0;                                                                                             // 2242\n    poll.onmessage = function(e) {                                                                                   // 2243\n        msg_counter += 1;                                                                                            // 2244\n        that.ri._didMessage(e.data);                                                                                 // 2245\n    };                                                                                                               // 2246\n    poll.onclose = function(e) {                                                                                     // 2247\n        that.poll = poll = poll.onmessage = poll.onclose = null;                                                     // 2248\n        if (!that.poll_is_closing) {                                                                                 // 2249\n            if (e.reason === 'permanent') {                                                                          // 2250\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');                                         // 2251\n            } else {                                                                                                 // 2252\n                that._scheduleRecv();                                                                                // 2253\n            }                                                                                                        // 2254\n        }                                                                                                            // 2255\n    };                                                                                                               // 2256\n};                                                                                                                   // 2257\n                                                                                                                     // 2258\nPolling.prototype.abort = function() {                                                                               // 2259\n    var that = this;                                                                                                 // 2260\n    that.poll_is_closing = true;                                                                                     // 2261\n    if (that.poll) {                                                                                                 // 2262\n        that.poll.abort();                                                                                           // 2263\n    }                                                                                                                // 2264\n};                                                                                                                   // 2265\n//         [*] End of lib/trans-polling.js                                                                           // 2266\n                                                                                                                     // 2267\n                                                                                                                     // 2268\n//         [*] Including lib/trans-receiver-eventsource.js                                                           // 2269\n/*                                                                                                                   // 2270\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2271\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2272\n *                                                                                                                   // 2273\n * For the license see COPYING.                                                                                      // 2274\n * ***** END LICENSE BLOCK *****                                                                                     // 2275\n */                                                                                                                  // 2276\n                                                                                                                     // 2277\nvar EventSourceReceiver = function(url) {                                                                            // 2278\n    var that = this;                                                                                                 // 2279\n    var es = new EventSource(url);                                                                                   // 2280\n    es.onmessage = function(e) {                                                                                     // 2281\n        that.dispatchEvent(new SimpleEvent('message',                                                                // 2282\n                                           {'data': unescape(e.data)}));                                             // 2283\n    };                                                                                                               // 2284\n    that.es_close = es.onerror = function(e, abort_reason) {                                                         // 2285\n        // ES on reconnection has readyState = 0 or 1.                                                               // 2286\n        // on network error it's CLOSED = 2                                                                          // 2287\n        var reason = abort_reason ? 'user' :                                                                         // 2288\n            (es.readyState !== 2 ? 'network' : 'permanent');                                                         // 2289\n        that.es_close = es.onmessage = es.onerror = null;                                                            // 2290\n        // EventSource reconnects automatically.                                                                     // 2291\n        es.close();                                                                                                  // 2292\n        es = null;                                                                                                   // 2293\n        // Safari and chrome < 15 crash if we close window before                                                    // 2294\n        // waiting for ES cleanup. See:                                                                              // 2295\n        //   https://code.google.com/p/chromium/issues/detail?id=89155                                               // 2296\n        utils.delay(200, function() {                                                                                // 2297\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                              // 2298\n                    });                                                                                              // 2299\n    };                                                                                                               // 2300\n};                                                                                                                   // 2301\n                                                                                                                     // 2302\nEventSourceReceiver.prototype = new REventTarget();                                                                  // 2303\n                                                                                                                     // 2304\nEventSourceReceiver.prototype.abort = function() {                                                                   // 2305\n    var that = this;                                                                                                 // 2306\n    if (that.es_close) {                                                                                             // 2307\n        that.es_close({}, true);                                                                                     // 2308\n    }                                                                                                                // 2309\n};                                                                                                                   // 2310\n//         [*] End of lib/trans-receiver-eventsource.js                                                              // 2311\n                                                                                                                     // 2312\n                                                                                                                     // 2313\n//         [*] Including lib/trans-receiver-htmlfile.js                                                              // 2314\n/*                                                                                                                   // 2315\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2316\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2317\n *                                                                                                                   // 2318\n * For the license see COPYING.                                                                                      // 2319\n * ***** END LICENSE BLOCK *****                                                                                     // 2320\n */                                                                                                                  // 2321\n                                                                                                                     // 2322\nvar _is_ie_htmlfile_capable;                                                                                         // 2323\nvar isIeHtmlfileCapable = function() {                                                                               // 2324\n    if (_is_ie_htmlfile_capable === undefined) {                                                                     // 2325\n        if ('ActiveXObject' in _window) {                                                                            // 2326\n            try {                                                                                                    // 2327\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');                                           // 2328\n            } catch (x) {}                                                                                           // 2329\n        } else {                                                                                                     // 2330\n            _is_ie_htmlfile_capable = false;                                                                         // 2331\n        }                                                                                                            // 2332\n    }                                                                                                                // 2333\n    return _is_ie_htmlfile_capable;                                                                                  // 2334\n};                                                                                                                   // 2335\n                                                                                                                     // 2336\n                                                                                                                     // 2337\nvar HtmlfileReceiver = function(url) {                                                                               // 2338\n    var that = this;                                                                                                 // 2339\n    utils.polluteGlobalNamespace();                                                                                  // 2340\n                                                                                                                     // 2341\n    that.id = 'a' + utils.random_string(6, 26);                                                                      // 2342\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +                                                                 // 2343\n        'c=' + escape(WPrefix + '.' + that.id);                                                                      // 2344\n                                                                                                                     // 2345\n    var constructor = isIeHtmlfileCapable() ?                                                                        // 2346\n        utils.createHtmlfile : utils.createIframe;                                                                   // 2347\n                                                                                                                     // 2348\n    var iframeObj;                                                                                                   // 2349\n    _window[WPrefix][that.id] = {                                                                                    // 2350\n        start: function () {                                                                                         // 2351\n            iframeObj.loaded();                                                                                      // 2352\n        },                                                                                                           // 2353\n        message: function (data) {                                                                                   // 2354\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));                                          // 2355\n        },                                                                                                           // 2356\n        stop: function () {                                                                                          // 2357\n            that.iframe_close({}, 'network');                                                                        // 2358\n        }                                                                                                            // 2359\n    };                                                                                                               // 2360\n    that.iframe_close = function(e, abort_reason) {                                                                  // 2361\n        iframeObj.cleanup();                                                                                         // 2362\n        that.iframe_close = iframeObj = null;                                                                        // 2363\n        delete _window[WPrefix][that.id];                                                                            // 2364\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));                                        // 2365\n    };                                                                                                               // 2366\n    iframeObj = constructor(url, function(e) {                                                                       // 2367\n                                that.iframe_close({}, 'permanent');                                                  // 2368\n                            });                                                                                      // 2369\n};                                                                                                                   // 2370\n                                                                                                                     // 2371\nHtmlfileReceiver.prototype = new REventTarget();                                                                     // 2372\n                                                                                                                     // 2373\nHtmlfileReceiver.prototype.abort = function() {                                                                      // 2374\n    var that = this;                                                                                                 // 2375\n    if (that.iframe_close) {                                                                                         // 2376\n        that.iframe_close({}, 'user');                                                                               // 2377\n    }                                                                                                                // 2378\n};                                                                                                                   // 2379\n//         [*] End of lib/trans-receiver-htmlfile.js                                                                 // 2380\n                                                                                                                     // 2381\n                                                                                                                     // 2382\n//         [*] Including lib/trans-receiver-xhr.js                                                                   // 2383\n/*                                                                                                                   // 2384\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2385\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2386\n *                                                                                                                   // 2387\n * For the license see COPYING.                                                                                      // 2388\n * ***** END LICENSE BLOCK *****                                                                                     // 2389\n */                                                                                                                  // 2390\n                                                                                                                     // 2391\nvar XhrReceiver = function(url, AjaxObject) {                                                                        // 2392\n    var that = this;                                                                                                 // 2393\n    var buf_pos = 0;                                                                                                 // 2394\n                                                                                                                     // 2395\n    that.xo = new AjaxObject('POST', url, null);                                                                     // 2396\n    that.xo.onchunk = function(status, text) {                                                                       // 2397\n        if (status !== 200) return;                                                                                  // 2398\n        while (1) {                                                                                                  // 2399\n            var buf = text.slice(buf_pos);                                                                           // 2400\n            var p = buf.indexOf('\\n');                                                                               // 2401\n            if (p === -1) break;                                                                                     // 2402\n            buf_pos += p+1;                                                                                          // 2403\n            var msg = buf.slice(0, p);                                                                               // 2404\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));                                             // 2405\n        }                                                                                                            // 2406\n    };                                                                                                               // 2407\n    that.xo.onfinish = function(status, text) {                                                                      // 2408\n        that.xo.onchunk(status, text);                                                                               // 2409\n        that.xo = null;                                                                                              // 2410\n        var reason = status === 200 ? 'network' : 'permanent';                                                       // 2411\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                                              // 2412\n    }                                                                                                                // 2413\n};                                                                                                                   // 2414\n                                                                                                                     // 2415\nXhrReceiver.prototype = new REventTarget();                                                                          // 2416\n                                                                                                                     // 2417\nXhrReceiver.prototype.abort = function() {                                                                           // 2418\n    var that = this;                                                                                                 // 2419\n    if (that.xo) {                                                                                                   // 2420\n        that.xo.close();                                                                                             // 2421\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));                                              // 2422\n        that.xo = null;                                                                                              // 2423\n    }                                                                                                                // 2424\n};                                                                                                                   // 2425\n//         [*] End of lib/trans-receiver-xhr.js                                                                      // 2426\n                                                                                                                     // 2427\n                                                                                                                     // 2428\n//         [*] Including lib/test-hooks.js                                                                           // 2429\n/*                                                                                                                   // 2430\n * ***** BEGIN LICENSE BLOCK *****                                                                                   // 2431\n * Copyright (c) 2011-2012 VMware, Inc.                                                                              // 2432\n *                                                                                                                   // 2433\n * For the license see COPYING.                                                                                      // 2434\n * ***** END LICENSE BLOCK *****                                                                                     // 2435\n */                                                                                                                  // 2436\n                                                                                                                     // 2437\n// For testing                                                                                                       // 2438\nSockJS.getUtils = function(){                                                                                        // 2439\n    return utils;                                                                                                    // 2440\n};                                                                                                                   // 2441\n                                                                                                                     // 2442\nSockJS.getIframeTransport = function(){                                                                              // 2443\n    return IframeTransport;                                                                                          // 2444\n};                                                                                                                   // 2445\n//         [*] End of lib/test-hooks.js                                                                              // 2446\n                                                                                                                     // 2447\n                  return SockJS;                                                                                     // 2448\n          })();                                                                                                      // 2449\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);                                                       // 2450\n                                                                                                                     // 2451\n// AMD compliance                                                                                                    // 2452\nif (typeof define === 'function' && define.amd) {                                                                    // 2453\n    define('sockjs', [], function(){return SockJS;});                                                                // 2454\n}                                                                                                                    // 2455\n//     [*] End of lib/index.js                                                                                       // 2456\n                                                                                                                     // 2457\n// [*] End of lib/all.js                                                                                             // 2458\n                                                                                                                     // 2459\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/stream_client_sockjs.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// @param url {String} URL to Meteor app                                                                             // 1\n//   \"http://subdomain.meteor.com/\" or \"/\" or                                                                        // 2\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                         // 3\nLivedataTest.ClientStream = function (url, options) {                                                                // 4\n  var self = this;                                                                                                   // 5\n  self.options = _.extend({                                                                                          // 6\n    retry: true                                                                                                      // 7\n  }, options);                                                                                                       // 8\n  self._initCommon(self.options);                                                                                    // 9\n                                                                                                                     // 10\n  //// Constants                                                                                                     // 11\n                                                                                                                     // 12\n                                                                                                                     // 13\n  // how long between hearing heartbeat from the server until we declare                                             // 14\n  // the connection dead. heartbeats come every 45s (stream_server.js)                                               // 15\n  //                                                                                                                 // 16\n  // NOTE: this is a older timeout mechanism. We now send heartbeats at                                              // 17\n  // the DDP level (https://github.com/meteor/meteor/pull/1865), and                                                 // 18\n  // expect those timeouts to kill a non-responsive connection before                                                // 19\n  // this timeout fires. This is kept around for compatibility (when                                                 // 20\n  // talking to a server that doesn't support DDP heartbeats) and can be                                             // 21\n  // removed later.                                                                                                  // 22\n  self.HEARTBEAT_TIMEOUT = 100*1000;                                                                                 // 23\n                                                                                                                     // 24\n  self.rawUrl = url;                                                                                                 // 25\n  self.socket = null;                                                                                                // 26\n                                                                                                                     // 27\n  self.heartbeatTimer = null;                                                                                        // 28\n                                                                                                                     // 29\n  // Listen to global 'online' event if we are running in a browser.                                                 // 30\n  // (IE8 does not support addEventListener)                                                                         // 31\n  if (typeof window !== 'undefined' && window.addEventListener)                                                      // 32\n    window.addEventListener(\"online\", _.bind(self._online, self),                                                    // 33\n                            false /* useCapture. make FF3.6 happy. */);                                              // 34\n                                                                                                                     // 35\n  //// Kickoff!                                                                                                      // 36\n  self._launchConnection();                                                                                          // 37\n};                                                                                                                   // 38\n                                                                                                                     // 39\n_.extend(LivedataTest.ClientStream.prototype, {                                                                      // 40\n                                                                                                                     // 41\n  // data is a utf8 string. Data sent while not connected is dropped on                                              // 42\n  // the floor, and it is up the user of this API to retransmit lost                                                 // 43\n  // messages on 'reset'                                                                                             // 44\n  send: function (data) {                                                                                            // 45\n    var self = this;                                                                                                 // 46\n    if (self.currentStatus.connected) {                                                                              // 47\n      self.socket.send(data);                                                                                        // 48\n    }                                                                                                                // 49\n  },                                                                                                                 // 50\n                                                                                                                     // 51\n  // Changes where this connection points                                                                            // 52\n  _changeUrl: function (url) {                                                                                       // 53\n    var self = this;                                                                                                 // 54\n    self.rawUrl = url;                                                                                               // 55\n  },                                                                                                                 // 56\n                                                                                                                     // 57\n  _connected: function () {                                                                                          // 58\n    var self = this;                                                                                                 // 59\n                                                                                                                     // 60\n    if (self.connectionTimer) {                                                                                      // 61\n      clearTimeout(self.connectionTimer);                                                                            // 62\n      self.connectionTimer = null;                                                                                   // 63\n    }                                                                                                                // 64\n                                                                                                                     // 65\n    if (self.currentStatus.connected) {                                                                              // 66\n      // already connected. do nothing. this probably shouldn't happen.                                              // 67\n      return;                                                                                                        // 68\n    }                                                                                                                // 69\n                                                                                                                     // 70\n    // update status                                                                                                 // 71\n    self.currentStatus.status = \"connected\";                                                                         // 72\n    self.currentStatus.connected = true;                                                                             // 73\n    self.currentStatus.retryCount = 0;                                                                               // 74\n    self.statusChanged();                                                                                            // 75\n                                                                                                                     // 76\n    // fire resets. This must come after status change so that clients                                               // 77\n    // can call send from within a reset callback.                                                                   // 78\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });                                          // 79\n                                                                                                                     // 80\n  },                                                                                                                 // 81\n                                                                                                                     // 82\n  _cleanup: function (maybeError) {                                                                                  // 83\n    var self = this;                                                                                                 // 84\n                                                                                                                     // 85\n    self._clearConnectionAndHeartbeatTimers();                                                                       // 86\n    if (self.socket) {                                                                                               // 87\n      self.socket.onmessage = self.socket.onclose                                                                    // 88\n        = self.socket.onerror = self.socket.onheartbeat = function () {};                                            // 89\n      self.socket.close();                                                                                           // 90\n      self.socket = null;                                                                                            // 91\n    }                                                                                                                // 92\n                                                                                                                     // 93\n    _.each(self.eventCallbacks.disconnect, function (callback) {                                                     // 94\n      callback(maybeError);                                                                                          // 95\n    });                                                                                                              // 96\n  },                                                                                                                 // 97\n                                                                                                                     // 98\n  _clearConnectionAndHeartbeatTimers: function () {                                                                  // 99\n    var self = this;                                                                                                 // 100\n    if (self.connectionTimer) {                                                                                      // 101\n      clearTimeout(self.connectionTimer);                                                                            // 102\n      self.connectionTimer = null;                                                                                   // 103\n    }                                                                                                                // 104\n    if (self.heartbeatTimer) {                                                                                       // 105\n      clearTimeout(self.heartbeatTimer);                                                                             // 106\n      self.heartbeatTimer = null;                                                                                    // 107\n    }                                                                                                                // 108\n  },                                                                                                                 // 109\n                                                                                                                     // 110\n  _heartbeat_timeout: function () {                                                                                  // 111\n    var self = this;                                                                                                 // 112\n    Meteor._debug(\"Connection timeout. No sockjs heartbeat received.\");                                              // 113\n    self._lostConnection(new DDP.ConnectionError(\"Heartbeat timed out\"));                                            // 114\n  },                                                                                                                 // 115\n                                                                                                                     // 116\n  _heartbeat_received: function () {                                                                                 // 117\n    var self = this;                                                                                                 // 118\n    // If we've already permanently shut down this stream, the timeout is                                            // 119\n    // already cleared, and we don't need to set it again.                                                           // 120\n    if (self._forcedToDisconnect)                                                                                    // 121\n      return;                                                                                                        // 122\n    if (self.heartbeatTimer)                                                                                         // 123\n      clearTimeout(self.heartbeatTimer);                                                                             // 124\n    self.heartbeatTimer = setTimeout(                                                                                // 125\n      _.bind(self._heartbeat_timeout, self),                                                                         // 126\n      self.HEARTBEAT_TIMEOUT);                                                                                       // 127\n  },                                                                                                                 // 128\n                                                                                                                     // 129\n  _sockjsProtocolsWhitelist: function () {                                                                           // 130\n    // only allow polling protocols. no streaming.  streaming                                                        // 131\n    // makes safari spin.                                                                                            // 132\n    var protocolsWhitelist = [                                                                                       // 133\n      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];                                          // 134\n                                                                                                                     // 135\n    // iOS 4 and 5 and below crash when using websockets over certain                                                // 136\n    // proxies. this seems to be resolved with iOS 6. eg                                                             // 137\n    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.                                      // 138\n    //                                                                                                               // 139\n    // iOS <4 doesn't support websockets at all so sockjs will just                                                  // 140\n    // immediately fall back to http                                                                                 // 141\n    var noWebsockets = navigator &&                                                                                  // 142\n          /iPhone|iPad|iPod/.test(navigator.userAgent) &&                                                            // 143\n          /OS 4_|OS 5_/.test(navigator.userAgent);                                                                   // 144\n                                                                                                                     // 145\n    if (!noWebsockets)                                                                                               // 146\n      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);                                                 // 147\n                                                                                                                     // 148\n    return protocolsWhitelist;                                                                                       // 149\n  },                                                                                                                 // 150\n                                                                                                                     // 151\n  _launchConnection: function () {                                                                                   // 152\n    var self = this;                                                                                                 // 153\n    self._cleanup(); // cleanup the old socket, if there was one.                                                    // 154\n                                                                                                                     // 155\n    var options = _.extend({                                                                                         // 156\n      protocols_whitelist:self._sockjsProtocolsWhitelist()                                                           // 157\n    }, self.options._sockjsOptions);                                                                                 // 158\n                                                                                                                     // 159\n    // Convert raw URL to SockJS URL each time we open a connection, so that we                                      // 160\n    // can connect to random hostnames and get around browser per-host                                               // 161\n    // connection limits.                                                                                            // 162\n    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);                                          // 163\n    self.socket.onopen = function (data) {                                                                           // 164\n      self._connected();                                                                                             // 165\n    };                                                                                                               // 166\n    self.socket.onmessage = function (data) {                                                                        // 167\n      self._heartbeat_received();                                                                                    // 168\n                                                                                                                     // 169\n      if (self.currentStatus.connected)                                                                              // 170\n        _.each(self.eventCallbacks.message, function (callback) {                                                    // 171\n          callback(data.data);                                                                                       // 172\n        });                                                                                                          // 173\n    };                                                                                                               // 174\n    self.socket.onclose = function () {                                                                              // 175\n      self._lostConnection();                                                                                        // 176\n    };                                                                                                               // 177\n    self.socket.onerror = function () {                                                                              // 178\n      // XXX is this ever called?                                                                                    // 179\n      Meteor._debug(\"stream error\", _.toArray(arguments), (new Date()).toDateString());                              // 180\n    };                                                                                                               // 181\n                                                                                                                     // 182\n    self.socket.onheartbeat =  function () {                                                                         // 183\n      self._heartbeat_received();                                                                                    // 184\n    };                                                                                                               // 185\n                                                                                                                     // 186\n    if (self.connectionTimer)                                                                                        // 187\n      clearTimeout(self.connectionTimer);                                                                            // 188\n    self.connectionTimer = setTimeout(function () {                                                                  // 189\n      self._lostConnection(                                                                                          // 190\n        new DDP.ConnectionError(\"DDP connection timed out\"));                                                        // 191\n    }, self.CONNECT_TIMEOUT);                                                                                        // 192\n  }                                                                                                                  // 193\n});                                                                                                                  // 194\n                                                                                                                     // 195\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/stream_client_common.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                           // 1\nvar startsWith = function(str, starts) {                                                                             // 2\n  return str.length >= starts.length &&                                                                              // 3\n    str.substring(0, starts.length) === starts;                                                                      // 4\n};                                                                                                                   // 5\nvar endsWith = function(str, ends) {                                                                                 // 6\n  return str.length >= ends.length &&                                                                                // 7\n    str.substring(str.length - ends.length) === ends;                                                                // 8\n};                                                                                                                   // 9\n                                                                                                                     // 10\n// @param url {String} URL to Meteor app, eg:                                                                        // 11\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                        // 12\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                               // 13\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                                  // 14\n// for scheme \"http\" and subPath \"sockjs\"                                                                            // 15\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                               // 16\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                    // 17\nvar translateUrl =  function(url, newSchemeBase, subPath) {                                                          // 18\n  if (! newSchemeBase) {                                                                                             // 19\n    newSchemeBase = \"http\";                                                                                          // 20\n  }                                                                                                                  // 21\n                                                                                                                     // 22\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                              // 23\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                    // 24\n  var newScheme;                                                                                                     // 25\n  if (ddpUrlMatch) {                                                                                                 // 26\n    // Remove scheme and split off the host.                                                                         // 27\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                             // 28\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";                                        // 29\n    var slashPos = urlAfterDDP.indexOf('/');                                                                         // 30\n    var host =                                                                                                       // 31\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                           // 32\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);                                                  // 33\n                                                                                                                     // 34\n    // In the host (ONLY!), change '*' characters into random digits. This                                           // 35\n    // allows different stream connections to connect to different hostnames                                         // 36\n    // and avoid browser per-hostname connection limits.                                                             // 37\n    host = host.replace(/\\*/g, function () {                                                                         // 38\n      return Math.floor(Random.fraction()*10);                                                                       // 39\n    });                                                                                                              // 40\n                                                                                                                     // 41\n    return newScheme + '://' + host + rest;                                                                          // 42\n  } else if (httpUrlMatch) {                                                                                         // 43\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";                                              // 44\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                           // 45\n    url = newScheme + \"://\" + urlAfterHttp;                                                                          // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  // Prefix FQDNs but not relative URLs                                                                              // 49\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {                                                          // 50\n    url = newSchemeBase + \"://\" + url;                                                                               // 51\n  }                                                                                                                  // 52\n                                                                                                                     // 53\n  // XXX This is not what we should be doing: if I have a site                                                       // 54\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect                                               // 55\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if                                                   // 56\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")                                               // 57\n  // to connect to \"/foo/bar\").                                                                                      // 58\n  //                                                                                                                 // 59\n  // We should make this properly honor absolute paths rather than                                                   // 60\n  // forcing the path to be relative to the site root. Simultaneously,                                               // 61\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site                                                    // 62\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs                                              // 63\n  url = Meteor._relativeToSiteRootUrl(url);                                                                          // 64\n                                                                                                                     // 65\n  if (endsWith(url, \"/\"))                                                                                            // 66\n    return url + subPath;                                                                                            // 67\n  else                                                                                                               // 68\n    return url + \"/\" + subPath;                                                                                      // 69\n};                                                                                                                   // 70\n                                                                                                                     // 71\ntoSockjsUrl = function (url) {                                                                                       // 72\n  return translateUrl(url, \"http\", \"sockjs\");                                                                        // 73\n};                                                                                                                   // 74\n                                                                                                                     // 75\ntoWebsocketUrl = function (url) {                                                                                    // 76\n  var ret = translateUrl(url, \"ws\", \"websocket\");                                                                    // 77\n  return ret;                                                                                                        // 78\n};                                                                                                                   // 79\n                                                                                                                     // 80\nLivedataTest.toSockjsUrl = toSockjsUrl;                                                                              // 81\n                                                                                                                     // 82\n                                                                                                                     // 83\n_.extend(LivedataTest.ClientStream.prototype, {                                                                      // 84\n                                                                                                                     // 85\n  // Register for callbacks.                                                                                         // 86\n  on: function (name, callback) {                                                                                    // 87\n    var self = this;                                                                                                 // 88\n                                                                                                                     // 89\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')                                             // 90\n      throw new Error(\"unknown event type: \" + name);                                                                // 91\n                                                                                                                     // 92\n    if (!self.eventCallbacks[name])                                                                                  // 93\n      self.eventCallbacks[name] = [];                                                                                // 94\n    self.eventCallbacks[name].push(callback);                                                                        // 95\n  },                                                                                                                 // 96\n                                                                                                                     // 97\n                                                                                                                     // 98\n  _initCommon: function (options) {                                                                                  // 99\n    var self = this;                                                                                                 // 100\n    options = options || {};                                                                                         // 101\n                                                                                                                     // 102\n    //// Constants                                                                                                   // 103\n                                                                                                                     // 104\n    // how long to wait until we declare the connection attempt                                                      // 105\n    // failed.                                                                                                       // 106\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;                                                        // 107\n                                                                                                                     // 108\n    self.eventCallbacks = {}; // name -> [callback]                                                                  // 109\n                                                                                                                     // 110\n    self._forcedToDisconnect = false;                                                                                // 111\n                                                                                                                     // 112\n    //// Reactive status                                                                                             // 113\n    self.currentStatus = {                                                                                           // 114\n      status: \"connecting\",                                                                                          // 115\n      connected: false,                                                                                              // 116\n      retryCount: 0                                                                                                  // 117\n    };                                                                                                               // 118\n                                                                                                                     // 119\n                                                                                                                     // 120\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;                                 // 121\n    self.statusChanged = function () {                                                                               // 122\n      if (self.statusListeners)                                                                                      // 123\n        self.statusListeners.changed();                                                                              // 124\n    };                                                                                                               // 125\n                                                                                                                     // 126\n    //// Retry logic                                                                                                 // 127\n    self._retry = new Retry;                                                                                         // 128\n    self.connectionTimer = null;                                                                                     // 129\n                                                                                                                     // 130\n  },                                                                                                                 // 131\n                                                                                                                     // 132\n  // Trigger a reconnect.                                                                                            // 133\n  reconnect: function (options) {                                                                                    // 134\n    var self = this;                                                                                                 // 135\n    options = options || {};                                                                                         // 136\n                                                                                                                     // 137\n    if (options.url) {                                                                                               // 138\n      self._changeUrl(options.url);                                                                                  // 139\n    }                                                                                                                // 140\n                                                                                                                     // 141\n    if (options._sockjsOptions) {                                                                                    // 142\n      self.options._sockjsOptions = options._sockjsOptions;                                                          // 143\n    }                                                                                                                // 144\n                                                                                                                     // 145\n    if (self.currentStatus.connected) {                                                                              // 146\n      if (options._force || options.url) {                                                                           // 147\n        // force reconnect.                                                                                          // 148\n        self._lostConnection(new DDP.ForcedReconnectError);                                                          // 149\n      } // else, noop.                                                                                               // 150\n      return;                                                                                                        // 151\n    }                                                                                                                // 152\n                                                                                                                     // 153\n    // if we're mid-connection, stop it.                                                                             // 154\n    if (self.currentStatus.status === \"connecting\") {                                                                // 155\n      // Pretend it's a clean close.                                                                                 // 156\n      self._lostConnection();                                                                                        // 157\n    }                                                                                                                // 158\n                                                                                                                     // 159\n    self._retry.clear();                                                                                             // 160\n    self.currentStatus.retryCount -= 1; // don't count manual retries                                                // 161\n    self._retryNow();                                                                                                // 162\n  },                                                                                                                 // 163\n                                                                                                                     // 164\n  disconnect: function (options) {                                                                                   // 165\n    var self = this;                                                                                                 // 166\n    options = options || {};                                                                                         // 167\n                                                                                                                     // 168\n    // Failed is permanent. If we're failed, don't let people go back                                                // 169\n    // online by calling 'disconnect' then 'reconnect'.                                                              // 170\n    if (self._forcedToDisconnect)                                                                                    // 171\n      return;                                                                                                        // 172\n                                                                                                                     // 173\n    // If _permanent is set, permanently disconnect a stream. Once a stream                                          // 174\n    // is forced to disconnect, it can never reconnect. This is for                                                  // 175\n    // error cases such as ddp version mismatch, where trying again                                                  // 176\n    // won't fix the problem.                                                                                        // 177\n    if (options._permanent) {                                                                                        // 178\n      self._forcedToDisconnect = true;                                                                               // 179\n    }                                                                                                                // 180\n                                                                                                                     // 181\n    self._cleanup();                                                                                                 // 182\n    self._retry.clear();                                                                                             // 183\n                                                                                                                     // 184\n    self.currentStatus = {                                                                                           // 185\n      status: (options._permanent ? \"failed\" : \"offline\"),                                                           // 186\n      connected: false,                                                                                              // 187\n      retryCount: 0                                                                                                  // 188\n    };                                                                                                               // 189\n                                                                                                                     // 190\n    if (options._permanent && options._error)                                                                        // 191\n      self.currentStatus.reason = options._error;                                                                    // 192\n                                                                                                                     // 193\n    self.statusChanged();                                                                                            // 194\n  },                                                                                                                 // 195\n                                                                                                                     // 196\n  // maybeError is set unless it's a clean protocol-level close.                                                     // 197\n  _lostConnection: function (maybeError) {                                                                           // 198\n    var self = this;                                                                                                 // 199\n                                                                                                                     // 200\n    self._cleanup(maybeError);                                                                                       // 201\n    self._retryLater(maybeError); // sets status. no need to do it here.                                             // 202\n  },                                                                                                                 // 203\n                                                                                                                     // 204\n  // fired when we detect that we've gone online. try to reconnect                                                   // 205\n  // immediately.                                                                                                    // 206\n  _online: function () {                                                                                             // 207\n    // if we've requested to be offline by disconnecting, don't reconnect.                                           // 208\n    if (this.currentStatus.status != \"offline\")                                                                      // 209\n      this.reconnect();                                                                                              // 210\n  },                                                                                                                 // 211\n                                                                                                                     // 212\n  _retryLater: function (maybeError) {                                                                               // 213\n    var self = this;                                                                                                 // 214\n                                                                                                                     // 215\n    var timeout = 0;                                                                                                 // 216\n    if (self.options.retry ||                                                                                        // 217\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {                                       // 218\n      timeout = self._retry.retryLater(                                                                              // 219\n        self.currentStatus.retryCount,                                                                               // 220\n        _.bind(self._retryNow, self)                                                                                 // 221\n      );                                                                                                             // 222\n      self.currentStatus.status = \"waiting\";                                                                         // 223\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;                                               // 224\n    } else {                                                                                                         // 225\n      self.currentStatus.status = \"failed\";                                                                          // 226\n      delete self.currentStatus.retryTime;                                                                           // 227\n    }                                                                                                                // 228\n                                                                                                                     // 229\n    self.currentStatus.connected = false;                                                                            // 230\n    self.statusChanged();                                                                                            // 231\n  },                                                                                                                 // 232\n                                                                                                                     // 233\n  _retryNow: function () {                                                                                           // 234\n    var self = this;                                                                                                 // 235\n                                                                                                                     // 236\n    if (self._forcedToDisconnect)                                                                                    // 237\n      return;                                                                                                        // 238\n                                                                                                                     // 239\n    self.currentStatus.retryCount += 1;                                                                              // 240\n    self.currentStatus.status = \"connecting\";                                                                        // 241\n    self.currentStatus.connected = false;                                                                            // 242\n    delete self.currentStatus.retryTime;                                                                             // 243\n    self.statusChanged();                                                                                            // 244\n                                                                                                                     // 245\n    self._launchConnection();                                                                                        // 246\n  },                                                                                                                 // 247\n                                                                                                                     // 248\n                                                                                                                     // 249\n  // Get current status. Reactive.                                                                                   // 250\n  status: function () {                                                                                              // 251\n    var self = this;                                                                                                 // 252\n    if (self.statusListeners)                                                                                        // 253\n      self.statusListeners.depend();                                                                                 // 254\n    return self.currentStatus;                                                                                       // 255\n  }                                                                                                                  // 256\n});                                                                                                                  // 257\n                                                                                                                     // 258\nDDP.ConnectionError = Meteor.makeErrorType(                                                                          // 259\n  \"DDP.ConnectionError\", function (message) {                                                                        // 260\n    var self = this;                                                                                                 // 261\n    self.message = message;                                                                                          // 262\n});                                                                                                                  // 263\n                                                                                                                     // 264\nDDP.ForcedReconnectError = Meteor.makeErrorType(                                                                     // 265\n  \"DDP.ForcedReconnectError\", function () {});                                                                       // 266\n                                                                                                                     // 267\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/livedata_common.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nLivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;                                              // 1\n                                                                                                                     // 2\n// This is private but it's used in a few places. accounts-base uses                                                 // 3\n// it to get the current user. Meteor.setTimeout and friends clear                                                   // 4\n// it. We can probably find a better way to factor this.                                                             // 5\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;                                                             // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/random_stream.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Returns the named sequence of pseudo-random values.                                                               // 1\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce                                        // 2\n// consistent values for method calls on the client and server.                                                      // 3\nDDP.randomStream = function (name) {                                                                                 // 4\n  var scope = DDP._CurrentInvocation.get();                                                                          // 5\n  return DDPCommon.RandomStream.get(scope, name);                                                                    // 6\n};                                                                                                                   // 7\n                                                                                                                     // 8\n                                                                                                                     // 9\n                                                                                                                     // 10\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/livedata_connection.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (Meteor.isServer) {                                                                                               // 1\n  var path = Npm.require('path');                                                                                    // 2\n  var Fiber = Npm.require('fibers');                                                                                 // 3\n  var Future = Npm.require(path.join('fibers', 'future'));                                                           // 4\n}                                                                                                                    // 5\n                                                                                                                     // 6\n// @param url {String|Object} URL to Meteor app,                                                                     // 7\n//   or an object as a test hook (see code)                                                                          // 8\n// Options:                                                                                                          // 9\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                     // 10\n//   headers: extra headers to send on the websockets connection, for                                                // 11\n//     server-to-server DDP only                                                                                     // 12\n//   _sockjsOptions: Specifies options to pass through to the sockjs client                                          // 13\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                        // 14\n//                                                                                                                   // 15\n// XXX There should be a way to destroy a DDP connection, causing all                                                // 16\n// outstanding method calls to fail.                                                                                 // 17\n//                                                                                                                   // 18\n// XXX Our current way of handling failure and reconnection is great                                                 // 19\n// for an app (where we want to tolerate being disconnected as an                                                    // 20\n// expect state, and keep trying forever to reconnect) but cumbersome                                                // 21\n// for something like a command line tool that wants to make a                                                       // 22\n// connection, call a method, and print an error if connection                                                       // 23\n// fails. We should have better usability in the latter case (while                                                  // 24\n// still transparently reconnecting if it's just a transient failure                                                 // 25\n// or the server migrating us).                                                                                      // 26\nvar Connection = function (url, options) {                                                                           // 27\n  var self = this;                                                                                                   // 28\n  options = _.extend({                                                                                               // 29\n    onConnected: function () {},                                                                                     // 30\n    onDDPVersionNegotiationFailure: function (description) {                                                         // 31\n      Meteor._debug(description);                                                                                    // 32\n    },                                                                                                               // 33\n    heartbeatInterval: 17500,                                                                                        // 34\n    heartbeatTimeout: 15000,                                                                                         // 35\n    npmFayeOptions: {},                                                                                              // 36\n    // These options are only for testing.                                                                           // 37\n    reloadWithOutstanding: false,                                                                                    // 38\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,                                                          // 39\n    retry: true,                                                                                                     // 40\n    respondToPings: true                                                                                             // 41\n  }, options);                                                                                                       // 42\n                                                                                                                     // 43\n  // If set, called when we reconnect, queuing method calls _before_ the                                             // 44\n  // existing outstanding ones. This is the only data member that is part of the                                     // 45\n  // public API!                                                                                                     // 46\n  self.onReconnect = null;                                                                                           // 47\n                                                                                                                     // 48\n  // as a test hook, allow passing a stream instead of a url.                                                        // 49\n  if (typeof url === \"object\") {                                                                                     // 50\n    self._stream = url;                                                                                              // 51\n  } else {                                                                                                           // 52\n    self._stream = new LivedataTest.ClientStream(url, {                                                              // 53\n      retry: options.retry,                                                                                          // 54\n      headers: options.headers,                                                                                      // 55\n      _sockjsOptions: options._sockjsOptions,                                                                        // 56\n      // Used to keep some tests quiet, or for other cases in which                                                  // 57\n      // the right thing to do with connection errors is to silently                                                 // 58\n      // fail (e.g. sending package usage stats). At some point we                                                   // 59\n      // should have a real API for handling client-stream-level                                                     // 60\n      // errors.                                                                                                     // 61\n      _dontPrintErrors: options._dontPrintErrors,                                                                    // 62\n      connectTimeoutMs: options.connectTimeoutMs,                                                                    // 63\n      npmFayeOptions: options.npmFayeOptions                                                                         // 64\n    });                                                                                                              // 65\n  }                                                                                                                  // 66\n                                                                                                                     // 67\n  self._lastSessionId = null;                                                                                        // 68\n  self._versionSuggestion = null;  // The last proposed DDP version.                                                 // 69\n  self._version = null;   // The DDP version agreed on by client and server.                                         // 70\n  self._stores = {}; // name -> object with methods                                                                  // 71\n  self._methodHandlers = {}; // name -> func                                                                         // 72\n  self._nextMethodId = 1;                                                                                            // 73\n  self._supportedDDPVersions = options.supportedDDPVersions;                                                         // 74\n                                                                                                                     // 75\n  self._heartbeatInterval = options.heartbeatInterval;                                                               // 76\n  self._heartbeatTimeout = options.heartbeatTimeout;                                                                 // 77\n                                                                                                                     // 78\n  // Tracks methods which the user has tried to call but which have not yet                                          // 79\n  // called their user callback (ie, they are waiting on their result or for all                                     // 80\n  // of their writes to be written to the local cache). Map from method ID to                                        // 81\n  // MethodInvoker object.                                                                                           // 82\n  self._methodInvokers = {};                                                                                         // 83\n                                                                                                                     // 84\n  // Tracks methods which the user has called but whose result messages have not                                     // 85\n  // arrived yet.                                                                                                    // 86\n  //                                                                                                                 // 87\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                           // 88\n  // represents a set of methods that can run at the same time. The first block                                      // 89\n  // represents the methods which are currently in flight; subsequent blocks                                         // 90\n  // must wait for previous blocks to be fully finished before they can be sent                                      // 91\n  // to the server.                                                                                                  // 92\n  //                                                                                                                 // 93\n  // Each block is an object with the following fields:                                                              // 94\n  // - methods: a list of MethodInvoker objects                                                                      // 95\n  // - wait: a boolean; if true, this block had a single method invoked with                                         // 96\n  //         the \"wait\" option                                                                                       // 97\n  //                                                                                                                 // 98\n  // There will never be adjacent blocks with wait=false, because the only thing                                     // 99\n  // that makes methods need to be serialized is a wait method.                                                      // 100\n  //                                                                                                                 // 101\n  // Methods are removed from the first block when their \"result\" is                                                 // 102\n  // received. The entire first block is only removed when all of the in-flight                                      // 103\n  // methods have received their results (so the \"methods\" list is empty) *AND*                                      // 104\n  // all of the data written by those methods are visible in the local cache. So                                     // 105\n  // it is possible for the first block's methods list to be empty, if we are                                        // 106\n  // still waiting for some objects to quiesce.                                                                      // 107\n  //                                                                                                                 // 108\n  // Example:                                                                                                        // 109\n  //  _outstandingMethodBlocks = [                                                                                   // 110\n  //    {wait: false, methods: []},                                                                                  // 111\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                        // 112\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                           // 113\n  //                            <MethodInvoker for 'bar'>]}]                                                         // 114\n  // This means that there were some methods which were sent to the server and                                       // 115\n  // which have returned their results, but some of the data written by                                              // 116\n  // the methods may not be visible in the local cache. Once all that data is                                        // 117\n  // visible, we will send a 'login' method. Once the login method has returned                                      // 118\n  // and all the data is visible (including re-running subs if userId changes),                                      // 119\n  // we will send the 'foo' and 'bar' methods in parallel.                                                           // 120\n  self._outstandingMethodBlocks = [];                                                                                // 121\n                                                                                                                     // 122\n  // method ID -> array of objects with keys 'collection' and 'id', listing                                          // 123\n  // documents written by a given method's stub. keys are associated with                                            // 124\n  // methods whose stub wrote at least one document, and whose data-done message                                     // 125\n  // has not yet been received.                                                                                      // 126\n  self._documentsWrittenByStub = {};                                                                                 // 127\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:                                       // 128\n  // - \"document\": the version of the document according the                                                         // 129\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                       // 130\n  //   received from the server)                                                                                     // 131\n  //   It is undefined if we think the document does not exist                                                       // 132\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document                                       // 133\n  //   whose \"data done\" messages have not yet been processed                                                        // 134\n  self._serverDocuments = {};                                                                                        // 135\n                                                                                                                     // 136\n  // Array of callbacks to be called after the next update of the local                                              // 137\n  // cache. Used for:                                                                                                // 138\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                              // 139\n  //    the relevant data is flushed.                                                                                // 140\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect                                            // 141\n  //    quiescence. Specifically, methods whose result was received over the old                                     // 142\n  //    connection (so we don't re-send it) but whose data had not been made                                         // 143\n  //    visible.                                                                                                     // 144\n  self._afterUpdateCallbacks = [];                                                                                   // 145\n                                                                                                                     // 146\n  // In two contexts, we buffer all incoming data messages and then process them                                     // 147\n  // all at once in a single update:                                                                                 // 148\n  //   - During reconnect, we buffer all data messages until all subs that had                                       // 149\n  //     been ready before reconnect are ready again, and all methods that are                                       // 150\n  //     active have returned their \"data done message\"; then                                                        // 151\n  //   - During the execution of a \"wait\" method, we buffer all data messages                                        // 152\n  //     until the wait method gets its \"data done\" message. (If the wait method                                     // 153\n  //     occurs during reconnect, it doesn't get any special handling.)                                              // 154\n  // all data messages are processed in one update.                                                                  // 155\n  //                                                                                                                 // 156\n  // The following fields are used for this \"quiescence\" process.                                                    // 157\n                                                                                                                     // 158\n  // This buffers the messages that aren't being processed yet.                                                      // 159\n  self._messagesBufferedUntilQuiescence = [];                                                                        // 160\n  // Map from method ID -> true. Methods are removed from this when their                                            // 161\n  // \"data done\" message is received, and we will not quiesce until it is                                            // 162\n  // empty.                                                                                                          // 163\n  self._methodsBlockingQuiescence = {};                                                                              // 164\n  // map from sub ID -> true for subs that were ready (ie, called the sub                                            // 165\n  // ready callback) before reconnect but haven't become ready again yet                                             // 166\n  self._subsBeingRevived = {}; // map from sub._id -> true                                                           // 167\n  // if true, the next data update should reset all stores. (set during                                              // 168\n  // reconnect.)                                                                                                     // 169\n  self._resetStores = false;                                                                                         // 170\n                                                                                                                     // 171\n  // name -> array of updates for (yet to be created) collections                                                    // 172\n  self._updatesForUnknownStores = {};                                                                                // 173\n  // if we're blocking a migration, the retry func                                                                   // 174\n  self._retryMigrate = null;                                                                                         // 175\n                                                                                                                     // 176\n  // metadata for subscriptions.  Map from sub ID to object with keys:                                               // 177\n  //   - id                                                                                                          // 178\n  //   - name                                                                                                        // 179\n  //   - params                                                                                                      // 180\n  //   - inactive (if true, will be cleaned up if not reused in re-run)                                              // 181\n  //   - ready (has the 'ready' message been received?)                                                              // 182\n  //   - readyCallback (an optional callback to call when ready)                                                     // 183\n  //   - errorCallback (an optional callback to call if the sub terminates with                                      // 184\n  //                    an error, XXX COMPAT WITH 1.0.3.1)                                                           // 185\n  //   - stopCallback (an optional callback to call when the sub terminates                                          // 186\n  //     for any reason, with an error argument if an error triggered the stop)                                      // 187\n  self._subscriptions = {};                                                                                          // 188\n                                                                                                                     // 189\n  // Reactive userId.                                                                                                // 190\n  self._userId = null;                                                                                               // 191\n  self._userIdDeps = new Tracker.Dependency;                                                                         // 192\n                                                                                                                     // 193\n  // Block auto-reload while we're waiting for method responses.                                                     // 194\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                         // 195\n    Package.reload.Reload._onMigrate(function (retry) {                                                              // 196\n      if (!self._readyToMigrate()) {                                                                                 // 197\n        if (self._retryMigrate)                                                                                      // 198\n          throw new Error(\"Two migrations in progress?\");                                                            // 199\n        self._retryMigrate = retry;                                                                                  // 200\n        return false;                                                                                                // 201\n      } else {                                                                                                       // 202\n        return [true];                                                                                               // 203\n      }                                                                                                              // 204\n    });                                                                                                              // 205\n  }                                                                                                                  // 206\n                                                                                                                     // 207\n  var onMessage = function (raw_msg) {                                                                               // 208\n    try {                                                                                                            // 209\n      var msg = DDPCommon.parseDDP(raw_msg);                                                                         // 210\n    } catch (e) {                                                                                                    // 211\n      Meteor._debug(\"Exception while parsing DDP\", e);                                                               // 212\n      return;                                                                                                        // 213\n    }                                                                                                                // 214\n                                                                                                                     // 215\n    // Any message counts as receiving a pong, as it demonstrates that                                               // 216\n    // the server is still alive.                                                                                    // 217\n    if (self._heartbeat) {                                                                                           // 218\n      self._heartbeat.messageReceived();                                                                             // 219\n    }                                                                                                                // 220\n                                                                                                                     // 221\n    if (msg === null || !msg.msg) {                                                                                  // 222\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back                                              // 223\n      // compat.  Remove this 'if' once the server stops sending welcome                                             // 224\n      // messages (stream_server.js).                                                                                // 225\n      if (! (msg && msg.server_id))                                                                                  // 226\n        Meteor._debug(\"discarding invalid livedata message\", msg);                                                   // 227\n      return;                                                                                                        // 228\n    }                                                                                                                // 229\n                                                                                                                     // 230\n    if (msg.msg === 'connected') {                                                                                   // 231\n      self._version = self._versionSuggestion;                                                                       // 232\n      self._livedata_connected(msg);                                                                                 // 233\n      options.onConnected();                                                                                         // 234\n    }                                                                                                                // 235\n    else if (msg.msg === 'failed') {                                                                                 // 236\n      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                     // 237\n        self._versionSuggestion = msg.version;                                                                       // 238\n        self._stream.reconnect({_force: true});                                                                      // 239\n      } else {                                                                                                       // 240\n        var description =                                                                                            // 241\n              \"DDP version negotiation failed; server requested version \" + msg.version;                             // 242\n        self._stream.disconnect({_permanent: true, _error: description});                                            // 243\n        options.onDDPVersionNegotiationFailure(description);                                                         // 244\n      }                                                                                                              // 245\n    }                                                                                                                // 246\n    else if (msg.msg === 'ping' && options.respondToPings) {                                                         // 247\n      self._send({msg: \"pong\", id: msg.id});                                                                         // 248\n    }                                                                                                                // 249\n    else if (msg.msg === 'pong') {                                                                                   // 250\n      // noop, as we assume everything's a pong                                                                      // 251\n    }                                                                                                                // 252\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))                                // 253\n      self._livedata_data(msg);                                                                                      // 254\n    else if (msg.msg === 'nosub')                                                                                    // 255\n      self._livedata_nosub(msg);                                                                                     // 256\n    else if (msg.msg === 'result')                                                                                   // 257\n      self._livedata_result(msg);                                                                                    // 258\n    else if (msg.msg === 'error')                                                                                    // 259\n      self._livedata_error(msg);                                                                                     // 260\n    else                                                                                                             // 261\n      Meteor._debug(\"discarding unknown livedata message type\", msg);                                                // 262\n  };                                                                                                                 // 263\n                                                                                                                     // 264\n  var onReset = function () {                                                                                        // 265\n    // Send a connect message at the beginning of the stream.                                                        // 266\n    // NOTE: reset is called even on the first connection, so this is                                                // 267\n    // the only place we send this message.                                                                          // 268\n    var msg = {msg: 'connect'};                                                                                      // 269\n    if (self._lastSessionId)                                                                                         // 270\n      msg.session = self._lastSessionId;                                                                             // 271\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                          // 272\n    self._versionSuggestion = msg.version;                                                                           // 273\n    msg.support = self._supportedDDPVersions;                                                                        // 274\n    self._send(msg);                                                                                                 // 275\n                                                                                                                     // 276\n    // Mark non-retry calls as failed. This has to be done early as getting these methods out of the                 // 277\n    // current block is pretty important to making sure that quiescence is properly calculated, as                   // 278\n    // well as possibly moving on to another useful block.                                                           // 279\n                                                                                                                     // 280\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if                  // 281\n    // we are connecting for the first time.                                                                         // 282\n    if (self._outstandingMethodBlocks.length > 0) {                                                                  // 283\n      // If there is an outstanding method block, we only care about the first one as that is the                    // 284\n      // one that could have already sent messages with no response, that are not allowed to retry.                  // 285\n      _.each(self._outstandingMethodBlocks[0].methods, function(methodInvoker) {                                     // 286\n        // If the message wasn't sent or it's allowed to retry, do nothing.                                          // 287\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {                                                    // 288\n          // The next loop serves to get the index in the current method block of this method.                       // 289\n          var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                         // 290\n          var loopMethod;                                                                                            // 291\n          for (var i = 0; i < currentMethodBlock.length; i++) {                                                      // 292\n            loopMethod = currentMethodBlock[i];                                                                      // 293\n            if (loopMethod.methodId === methodInvoker.methodId) {                                                    // 294\n              break;                                                                                                 // 295\n            }                                                                                                        // 296\n          }                                                                                                          // 297\n                                                                                                                     // 298\n          // Remove from current method block. This may leave the block empty, but we                                // 299\n          // don't move on to the next block until the callback has been delivered, in                               // 300\n          // _outstandingMethodFinished.                                                                             // 301\n          currentMethodBlock.splice(i, 1);                                                                           // 302\n                                                                                                                     // 303\n          // Make sure that the method is told that it failed.                                                       // 304\n          methodInvoker.receiveResult(Meteor.Error('invocation-failed',                                              // 305\n            'Method invocation might have failed due to dropped connection. ' +                                      // 306\n            'Failing because `noRetry` option was passed to Meteor.apply.'));                                        // 307\n        }                                                                                                            // 308\n      });                                                                                                            // 309\n    }                                                                                                                // 310\n                                                                                                                     // 311\n    // Now, to minimize setup latency, go ahead and blast out all of                                                 // 312\n    // our pending methods ands subscriptions before we've even taken                                                // 313\n    // the necessary RTT to know if we successfully reconnected. (1)                                                 // 314\n    // They're supposed to be idempotent, and where they are not,                                                    // 315\n    // they can block retry in apply; (2) even if we did reconnect,                                                  // 316\n    // we're not sure what messages might have gotten lost                                                           // 317\n    // (in either direction) since we were disconnected (TCP being                                                   // 318\n    // sloppy about that.)                                                                                           // 319\n                                                                                                                     // 320\n    // If the current block of methods all got their results (but didn't all get                                     // 321\n    // their data visible), discard the empty block now.                                                             // 322\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&                                                                // 323\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {                                                       // 324\n      self._outstandingMethodBlocks.shift();                                                                         // 325\n    }                                                                                                                // 326\n                                                                                                                     // 327\n    // Mark all messages as unsent, they have not yet been sent on this                                              // 328\n    // connection.                                                                                                   // 329\n    _.each(self._methodInvokers, function (m) {                                                                      // 330\n      m.sentMessage = false;                                                                                         // 331\n    });                                                                                                              // 332\n                                                                                                                     // 333\n    // If an `onReconnect` handler is set, call it first. Go through                                                 // 334\n    // some hoops to ensure that methods that are called from within                                                 // 335\n    // `onReconnect` get executed _before_ ones that were originally                                                 // 336\n    // outstanding (since `onReconnect` is used to re-establish auth                                                 // 337\n    // certificates)                                                                                                 // 338\n    if (self.onReconnect)                                                                                            // 339\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();                                                   // 340\n    else                                                                                                             // 341\n      self._sendOutstandingMethods();                                                                                // 342\n                                                                                                                     // 343\n    // add new subscriptions at the end. this way they take effect after                                             // 344\n    // the handlers and we don't see flicker.                                                                        // 345\n    _.each(self._subscriptions, function (sub, id) {                                                                 // 346\n      self._send({                                                                                                   // 347\n        msg: 'sub',                                                                                                  // 348\n        id: id,                                                                                                      // 349\n        name: sub.name,                                                                                              // 350\n        params: sub.params                                                                                           // 351\n      });                                                                                                            // 352\n    });                                                                                                              // 353\n  };                                                                                                                 // 354\n                                                                                                                     // 355\n  var onDisconnect = function () {                                                                                   // 356\n    if (self._heartbeat) {                                                                                           // 357\n      self._heartbeat.stop();                                                                                        // 358\n      self._heartbeat = null;                                                                                        // 359\n    }                                                                                                                // 360\n  };                                                                                                                 // 361\n                                                                                                                     // 362\n  if (Meteor.isServer) {                                                                                             // 363\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));                           // 364\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));                                 // 365\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));                  // 366\n  } else {                                                                                                           // 367\n    self._stream.on('message', onMessage);                                                                           // 368\n    self._stream.on('reset', onReset);                                                                               // 369\n    self._stream.on('disconnect', onDisconnect);                                                                     // 370\n  }                                                                                                                  // 371\n};                                                                                                                   // 372\n                                                                                                                     // 373\n// A MethodInvoker manages sending a method to the server and calling the user's                                     // 374\n// callbacks. On construction, it registers itself in the connection's                                               // 375\n// _methodInvokers map; it removes itself once the method is fully finished and                                      // 376\n// the callback is invoked. This occurs when it has both received a result,                                          // 377\n// and the data written by it is fully visible.                                                                      // 378\nvar MethodInvoker = function (options) {                                                                             // 379\n  var self = this;                                                                                                   // 380\n                                                                                                                     // 381\n  // Public (within this file) fields.                                                                               // 382\n  self.methodId = options.methodId;                                                                                  // 383\n  self.sentMessage = false;                                                                                          // 384\n                                                                                                                     // 385\n  self._callback = options.callback;                                                                                 // 386\n  self._connection = options.connection;                                                                             // 387\n  self._message = options.message;                                                                                   // 388\n  self._onResultReceived = options.onResultReceived || function () {};                                               // 389\n  self._wait = options.wait;                                                                                         // 390\n  self.noRetry = options.noRetry;                                                                                    // 391\n  self._methodResult = null;                                                                                         // 392\n  self._dataVisible = false;                                                                                         // 393\n                                                                                                                     // 394\n  // Register with the connection.                                                                                   // 395\n  self._connection._methodInvokers[self.methodId] = self;                                                            // 396\n};                                                                                                                   // 397\n_.extend(MethodInvoker.prototype, {                                                                                  // 398\n  // Sends the method message to the server. May be called additional times if                                       // 399\n  // we lose the connection and reconnect before receiving a result.                                                 // 400\n  sendMessage: function () {                                                                                         // 401\n    var self = this;                                                                                                 // 402\n    // This function is called before sending a method (including resending on                                       // 403\n    // reconnect). We should only (re)send methods where we don't already have a                                     // 404\n    // result!                                                                                                       // 405\n    if (self.gotResult())                                                                                            // 406\n      throw new Error(\"sendingMethod is called on method with result\");                                              // 407\n                                                                                                                     // 408\n                                                                                                                     // 409\n    // If we're re-sending it, it doesn't matter if data was written the first                                       // 410\n    // time.                                                                                                         // 411\n    self._dataVisible = false;                                                                                       // 412\n    self.sentMessage = true;                                                                                         // 413\n                                                                                                                     // 414\n    // If this is a wait method, make all data messages be buffered until it is                                      // 415\n    // done.                                                                                                         // 416\n    if (self._wait)                                                                                                  // 417\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;                                             // 418\n                                                                                                                     // 419\n    // Actually send the message.                                                                                    // 420\n    self._connection._send(self._message);                                                                           // 421\n  },                                                                                                                 // 422\n  // Invoke the callback, if we have both a result and know that all data has                                        // 423\n  // been written to the local cache.                                                                                // 424\n  _maybeInvokeCallback: function () {                                                                                // 425\n    var self = this;                                                                                                 // 426\n    if (self._methodResult && self._dataVisible) {                                                                   // 427\n      // Call the callback. (This won't throw: the callback was wrapped with                                         // 428\n      // bindEnvironment.)                                                                                           // 429\n      self._callback(self._methodResult[0], self._methodResult[1]);                                                  // 430\n                                                                                                                     // 431\n      // Forget about this method.                                                                                   // 432\n      delete self._connection._methodInvokers[self.methodId];                                                        // 433\n                                                                                                                     // 434\n      // Let the connection know that this method is finished, so it can try to                                      // 435\n      // move on to the next block of methods.                                                                       // 436\n      self._connection._outstandingMethodFinished();                                                                 // 437\n    }                                                                                                                // 438\n  },                                                                                                                 // 439\n  // Call with the result of the method from the server. Only may be called                                          // 440\n  // once; once it is called, you should not call sendMessage again.                                                 // 441\n  // If the user provided an onResultReceived callback, call it immediately.                                         // 442\n  // Then invoke the main callback if data is also visible.                                                          // 443\n  receiveResult: function (err, result) {                                                                            // 444\n    var self = this;                                                                                                 // 445\n    if (self.gotResult())                                                                                            // 446\n      throw new Error(\"Methods should only receive results once\");                                                   // 447\n    self._methodResult = [err, result];                                                                              // 448\n    self._onResultReceived(err, result);                                                                             // 449\n    self._maybeInvokeCallback();                                                                                     // 450\n  },                                                                                                                 // 451\n  // Call this when all data written by the method is visible. This means that                                       // 452\n  // the method has returns its \"data is done\" message *AND* all server                                              // 453\n  // documents that are buffered at that time have been written to the local                                         // 454\n  // cache. Invokes the main callback if the result has been received.                                               // 455\n  dataVisible: function () {                                                                                         // 456\n    var self = this;                                                                                                 // 457\n    self._dataVisible = true;                                                                                        // 458\n    self._maybeInvokeCallback();                                                                                     // 459\n  },                                                                                                                 // 460\n  // True if receiveResult has been called.                                                                          // 461\n  gotResult: function () {                                                                                           // 462\n    var self = this;                                                                                                 // 463\n    return !!self._methodResult;                                                                                     // 464\n  }                                                                                                                  // 465\n});                                                                                                                  // 466\n                                                                                                                     // 467\n_.extend(Connection.prototype, {                                                                                     // 468\n  // 'name' is the name of the data on the wire that should go in the                                                // 469\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                     // 470\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                     // 471\n  registerStore: function (name, wrappedStore) {                                                                     // 472\n    var self = this;                                                                                                 // 473\n                                                                                                                     // 474\n    if (name in self._stores)                                                                                        // 475\n      return false;                                                                                                  // 476\n                                                                                                                     // 477\n    // Wrap the input object in an object which makes any store method not                                           // 478\n    // implemented by 'store' into a no-op.                                                                          // 479\n    var store = {};                                                                                                  // 480\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',                                                   // 481\n            'retrieveOriginals', 'getDoc',                                                                           // 482\n\t\t\t'_getCollection'], function (method) {                                                                            // 483\n              store[method] = function () {                                                                          // 484\n                return (wrappedStore[method]                                                                         // 485\n                        ? wrappedStore[method].apply(wrappedStore, arguments)                                        // 486\n                        : undefined);                                                                                // 487\n              };                                                                                                     // 488\n            });                                                                                                      // 489\n                                                                                                                     // 490\n    self._stores[name] = store;                                                                                      // 491\n                                                                                                                     // 492\n    var queued = self._updatesForUnknownStores[name];                                                                // 493\n    if (queued) {                                                                                                    // 494\n      store.beginUpdate(queued.length, false);                                                                       // 495\n      _.each(queued, function (msg) {                                                                                // 496\n        store.update(msg);                                                                                           // 497\n      });                                                                                                            // 498\n      store.endUpdate();                                                                                             // 499\n      delete self._updatesForUnknownStores[name];                                                                    // 500\n    }                                                                                                                // 501\n                                                                                                                     // 502\n    return true;                                                                                                     // 503\n  },                                                                                                                 // 504\n                                                                                                                     // 505\n  /**                                                                                                                // 506\n   * @memberOf Meteor                                                                                                // 507\n   * @importFromPackage meteor                                                                                       // 508\n   * @summary Subscribe to a record set.  Returns a handle that provides                                             // 509\n   * `stop()` and `ready()` methods.                                                                                 // 510\n   * @locus Client                                                                                                   // 511\n   * @param {String} name Name of the subscription.  Matches the name of the                                         // 512\n   * server's `publish()` call.                                                                                      // 513\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher                                        // 514\n   * function on server.                                                                                             // 515\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`                                             // 516\n   * and `onReady` callbacks. If there is an error, it is passed as an                                               // 517\n   * argument to `onStop`. If a function is passed instead of an object, it                                          // 518\n   * is interpreted as an `onReady` callback.                                                                        // 519\n   */                                                                                                                // 520\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                          // 521\n    var self = this;                                                                                                 // 522\n                                                                                                                     // 523\n    var params = Array.prototype.slice.call(arguments, 1);                                                           // 524\n    var callbacks = {};                                                                                              // 525\n    if (params.length) {                                                                                             // 526\n      var lastParam = params[params.length - 1];                                                                     // 527\n      if (_.isFunction(lastParam)) {                                                                                 // 528\n        callbacks.onReady = params.pop();                                                                            // 529\n      } else if (lastParam &&                                                                                        // 530\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                                             // 531\n        // onStop with an error callback instead.                                                                    // 532\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],                                              // 533\n          _.isFunction)) {                                                                                           // 534\n        callbacks = params.pop();                                                                                    // 535\n      }                                                                                                              // 536\n    }                                                                                                                // 537\n                                                                                                                     // 538\n    // Is there an existing sub with the same name and param, run in an                                              // 539\n    // invalidated Computation? This will happen if we are rerunning an                                              // 540\n    // existing computation.                                                                                         // 541\n    //                                                                                                               // 542\n    // For example, consider a rerun of:                                                                             // 543\n    //                                                                                                               // 544\n    //     Tracker.autorun(function () {                                                                             // 545\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));                                                            // 546\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));                                                            // 547\n    //     });                                                                                                       // 548\n    //                                                                                                               // 549\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"                                               // 550\n    // subcribe to an existing inactive subscription in order to not                                                 // 551\n    // unsub and resub the subscription unnecessarily.                                                               // 552\n    //                                                                                                               // 553\n    // We only look for one such sub; if there are N apparently-identical subs                                       // 554\n    // being invalidated, we will require N matching subscribe calls to keep                                         // 555\n    // them all active.                                                                                              // 556\n    var existing = _.find(self._subscriptions, function (sub) {                                                      // 557\n      return sub.inactive && sub.name === name &&                                                                    // 558\n        EJSON.equals(sub.params, params);                                                                            // 559\n    });                                                                                                              // 560\n                                                                                                                     // 561\n    var id;                                                                                                          // 562\n    if (existing) {                                                                                                  // 563\n      id = existing.id;                                                                                              // 564\n      existing.inactive = false; // reactivate                                                                       // 565\n                                                                                                                     // 566\n      if (callbacks.onReady) {                                                                                       // 567\n        // If the sub is not already ready, replace any ready callback with the                                      // 568\n        // one provided now. (It's not really clear what users would expect for                                      // 569\n        // an onReady callback inside an autorun; the semantics we provide is                                        // 570\n        // that at the time the sub first becomes ready, we call the last                                            // 571\n        // onReady callback provided, if any.)                                                                       // 572\n        if (!existing.ready)                                                                                         // 573\n          existing.readyCallback = callbacks.onReady;                                                                // 574\n      }                                                                                                              // 575\n                                                                                                                     // 576\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call                                             // 577\n      // onStop with an optional error argument                                                                      // 578\n      if (callbacks.onError) {                                                                                       // 579\n        // Replace existing callback if any, so that errors aren't                                                   // 580\n        // double-reported.                                                                                          // 581\n        existing.errorCallback = callbacks.onError;                                                                  // 582\n      }                                                                                                              // 583\n                                                                                                                     // 584\n      if (callbacks.onStop) {                                                                                        // 585\n        existing.stopCallback = callbacks.onStop;                                                                    // 586\n      }                                                                                                              // 587\n    } else {                                                                                                         // 588\n      // New sub! Generate an id, save it locally, and send message.                                                 // 589\n      id = Random.id();                                                                                              // 590\n      self._subscriptions[id] = {                                                                                    // 591\n        id: id,                                                                                                      // 592\n        name: name,                                                                                                  // 593\n        params: EJSON.clone(params),                                                                                 // 594\n        inactive: false,                                                                                             // 595\n        ready: false,                                                                                                // 596\n        readyDeps: new Tracker.Dependency,                                                                           // 597\n        readyCallback: callbacks.onReady,                                                                            // 598\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                    // 599\n        errorCallback: callbacks.onError,                                                                            // 600\n        stopCallback: callbacks.onStop,                                                                              // 601\n        connection: self,                                                                                            // 602\n        remove: function() {                                                                                         // 603\n          delete this.connection._subscriptions[this.id];                                                            // 604\n          this.ready && this.readyDeps.changed();                                                                    // 605\n        },                                                                                                           // 606\n        stop: function() {                                                                                           // 607\n          this.connection._send({msg: 'unsub', id: id});                                                             // 608\n          this.remove();                                                                                             // 609\n                                                                                                                     // 610\n          if (callbacks.onStop) {                                                                                    // 611\n            callbacks.onStop();                                                                                      // 612\n          }                                                                                                          // 613\n        }                                                                                                            // 614\n      };                                                                                                             // 615\n      self._send({msg: 'sub', id: id, name: name, params: params});                                                  // 616\n    }                                                                                                                // 617\n                                                                                                                     // 618\n    // return a handle to the application.                                                                           // 619\n    var handle = {                                                                                                   // 620\n      stop: function () {                                                                                            // 621\n        if (!_.has(self._subscriptions, id))                                                                         // 622\n          return;                                                                                                    // 623\n                                                                                                                     // 624\n        self._subscriptions[id].stop();                                                                              // 625\n      },                                                                                                             // 626\n      ready: function () {                                                                                           // 627\n        // return false if we've unsubscribed.                                                                       // 628\n        if (!_.has(self._subscriptions, id))                                                                         // 629\n          return false;                                                                                              // 630\n        var record = self._subscriptions[id];                                                                        // 631\n        record.readyDeps.depend();                                                                                   // 632\n        return record.ready;                                                                                         // 633\n      },                                                                                                             // 634\n      subscriptionId: id                                                                                             // 635\n    };                                                                                                               // 636\n                                                                                                                     // 637\n    if (Tracker.active) {                                                                                            // 638\n      // We're in a reactive computation, so we'd like to unsubscribe when the                                       // 639\n      // computation is invalidated... but not if the rerun just re-subscribes                                       // 640\n      // to the same subscription!  When a rerun happens, we use onInvalidate                                        // 641\n      // as a change to mark the subscription \"inactive\" so that it can                                              // 642\n      // be reused from the rerun.  If it isn't reused, it's killed from                                             // 643\n      // an afterFlush.                                                                                              // 644\n      Tracker.onInvalidate(function (c) {                                                                            // 645\n        if (_.has(self._subscriptions, id))                                                                          // 646\n          self._subscriptions[id].inactive = true;                                                                   // 647\n                                                                                                                     // 648\n        Tracker.afterFlush(function () {                                                                             // 649\n          if (_.has(self._subscriptions, id) &&                                                                      // 650\n              self._subscriptions[id].inactive)                                                                      // 651\n            handle.stop();                                                                                           // 652\n        });                                                                                                          // 653\n      });                                                                                                            // 654\n    }                                                                                                                // 655\n                                                                                                                     // 656\n    return handle;                                                                                                   // 657\n  },                                                                                                                 // 658\n                                                                                                                     // 659\n  // options:                                                                                                        // 660\n  // - onLateError {Function(error)} called if an error was received after the ready event.                          // 661\n  //     (errors received before ready cause an error to be thrown)                                                  // 662\n  _subscribeAndWait: function (name, args, options) {                                                                // 663\n    var self = this;                                                                                                 // 664\n    var f = new Future();                                                                                            // 665\n    var ready = false;                                                                                               // 666\n    var handle;                                                                                                      // 667\n    args = args || [];                                                                                               // 668\n    args.push({                                                                                                      // 669\n      onReady: function () {                                                                                         // 670\n        ready = true;                                                                                                // 671\n        f['return']();                                                                                               // 672\n      },                                                                                                             // 673\n      onError: function (e) {                                                                                        // 674\n        if (!ready)                                                                                                  // 675\n          f['throw'](e);                                                                                             // 676\n        else                                                                                                         // 677\n          options && options.onLateError && options.onLateError(e);                                                  // 678\n      }                                                                                                              // 679\n    });                                                                                                              // 680\n                                                                                                                     // 681\n    handle = self.subscribe.apply(self, [name].concat(args));                                                        // 682\n    f.wait();                                                                                                        // 683\n    return handle;                                                                                                   // 684\n  },                                                                                                                 // 685\n                                                                                                                     // 686\n  methods: function (methods) {                                                                                      // 687\n    var self = this;                                                                                                 // 688\n    _.each(methods, function (func, name) {                                                                          // 689\n      if (typeof func !== 'function')                                                                                // 690\n        throw new Error(\"Method '\" + name + \"' must be a function\");                                                 // 691\n      if (self._methodHandlers[name])                                                                                // 692\n        throw new Error(\"A method named '\" + name + \"' is already defined\");                                         // 693\n      self._methodHandlers[name] = func;                                                                             // 694\n    });                                                                                                              // 695\n  },                                                                                                                 // 696\n                                                                                                                     // 697\n  /**                                                                                                                // 698\n   * @memberOf Meteor                                                                                                // 699\n   * @importFromPackage meteor                                                                                       // 700\n   * @summary Invokes a method passing any number of arguments.                                                      // 701\n   * @locus Anywhere                                                                                                 // 702\n   * @param {String} name Name of method to invoke                                                                   // 703\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments                                                     // 704\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */                                                                                                                // 706\n  call: function (name /* .. [arguments] .. callback */) {                                                           // 707\n    // if it's a function, the last argument is the result callback,                                                 // 708\n    // not a parameter to the remote method.                                                                         // 709\n    var args = Array.prototype.slice.call(arguments, 1);                                                             // 710\n    if (args.length && typeof args[args.length - 1] === \"function\")                                                  // 711\n      var callback = args.pop();                                                                                     // 712\n    return this.apply(name, args, callback);                                                                         // 713\n  },                                                                                                                 // 714\n                                                                                                                     // 715\n  // @param options {Optional Object}                                                                                // 716\n  //   wait: Boolean - Should we wait to call this until all current methods                                         // 717\n  //                   are fully finished, and block subsequent method calls                                         // 718\n  //                   until this method is fully finished?                                                          // 719\n  //                   (does not affect methods called from within this method)                                      // 720\n  //   onResultReceived: Function - a callback to call as soon as the method                                         // 721\n  //                                result is received. the data written by                                          // 722\n  //                                the method may not yet be in the cache!                                          // 723\n  //   returnStubValue: Boolean - If true then in cases where we would have                                          // 724\n  //                              otherwise discarded the stub's return value                                        // 725\n  //                              and returned undefined, instead we go ahead                                        // 726\n  //                              and return it.  Specifically, this is any                                          // 727\n  //                              time other than when (a) we are already                                            // 728\n  //                              inside a stub or (b) we are in Node and no                                         // 729\n  //                              callback was provided.  Currently we require                                       // 730\n  //                              this flag to be explicitly passed to reduce                                        // 731\n  //                              the likelihood that stub return values will                                        // 732\n  //                              be confused with server return values; we                                          // 733\n  //                              may improve this in future.                                                        // 734\n  // @param callback {Optional Function}                                                                             // 735\n                                                                                                                     // 736\n  /**                                                                                                                // 737\n   * @memberOf Meteor                                                                                                // 738\n   * @importFromPackage meteor                                                                                       // 739\n   * @summary Invoke a method passing an array of arguments.                                                         // 740\n   * @locus Anywhere                                                                                                 // 741\n   * @param {String} name Name of method to invoke                                                                   // 742\n   * @param {EJSONable[]} args Method arguments                                                                      // 743\n   * @param {Object} [options]                                                                                       // 744\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param (Boolean) options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).        // 748\n   */                                                                                                                // 749\n  apply: function (name, args, options, callback) {                                                                  // 750\n    var self = this;                                                                                                 // 751\n                                                                                                                     // 752\n    // We were passed 3 arguments. They may be either (name, args, options)                                          // 753\n    // or (name, args, callback)                                                                                     // 754\n    if (!callback && typeof options === 'function') {                                                                // 755\n      callback = options;                                                                                            // 756\n      options = {};                                                                                                  // 757\n    }                                                                                                                // 758\n    options = options || {};                                                                                         // 759\n                                                                                                                     // 760\n    if (callback) {                                                                                                  // 761\n      // XXX would it be better form to do the binding in stream.on,                                                 // 762\n      // or caller, instead of here?                                                                                 // 763\n      // XXX improve error message (and how we report it)                                                            // 764\n      callback = Meteor.bindEnvironment(                                                                             // 765\n        callback,                                                                                                    // 766\n        \"delivering result of invoking '\" + name + \"'\"                                                               // 767\n      );                                                                                                             // 768\n    }                                                                                                                // 769\n                                                                                                                     // 770\n    // Keep our args safe from mutation (eg if we don't send the message for a                                       // 771\n    // while because of a wait method).                                                                              // 772\n    args = EJSON.clone(args);                                                                                        // 773\n                                                                                                                     // 774\n    // Lazily allocate method ID once we know that it'll be needed.                                                  // 775\n    var methodId = (function () {                                                                                    // 776\n      var id;                                                                                                        // 777\n      return function () {                                                                                           // 778\n        if (id === undefined)                                                                                        // 779\n          id = '' + (self._nextMethodId++);                                                                          // 780\n        return id;                                                                                                   // 781\n      };                                                                                                             // 782\n    })();                                                                                                            // 783\n                                                                                                                     // 784\n    var enclosing = DDP._CurrentInvocation.get();                                                                    // 785\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                   // 786\n                                                                                                                     // 787\n    // Lazily generate a randomSeed, only if it is requested by the stub.                                            // 788\n    // The random streams only have utility if they're used on both the client                                       // 789\n    // and the server; if the client doesn't generate any 'random' values                                            // 790\n    // then we don't expect the server to generate any either.                                                       // 791\n    // Less commonly, the server may perform different actions from the client,                                      // 792\n    // and may in fact generate values where the client did not, but we don't                                        // 793\n    // have any client-side values to match, so even here we may as well just                                        // 794\n    // use a random seed on the server.  In that case, we don't pass the                                             // 795\n    // randomSeed to save bandwidth, and we don't even generate it to save a                                         // 796\n    // bit of CPU and to avoid consuming entropy.                                                                    // 797\n    var randomSeed = null;                                                                                           // 798\n    var randomSeedGenerator = function () {                                                                          // 799\n      if (randomSeed === null) {                                                                                     // 800\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);                                                         // 801\n      }                                                                                                              // 802\n      return randomSeed;                                                                                             // 803\n    };                                                                                                               // 804\n                                                                                                                     // 805\n    // Run the stub, if we have one. The stub is supposed to make some                                               // 806\n    // temporary writes to the database to give the user a smooth experience                                         // 807\n    // until the actual result of executing the method comes back from the                                           // 808\n    // server (whereupon the temporary writes to the database will be reversed                                       // 809\n    // during the beginUpdate/endUpdate process.)                                                                    // 810\n    //                                                                                                               // 811\n    // Normally, we ignore the return value of the stub (even if it is an                                            // 812\n    // exception), in favor of the real return value from the server. The                                            // 813\n    // exception is if the *caller* is a stub. In that case, we're not going                                         // 814\n    // to do a RPC, so we use the return value of the stub as our return                                             // 815\n    // value.                                                                                                        // 816\n                                                                                                                     // 817\n    var stub = self._methodHandlers[name];                                                                           // 818\n    if (stub) {                                                                                                      // 819\n      var setUserId = function(userId) {                                                                             // 820\n        self.setUserId(userId);                                                                                      // 821\n      };                                                                                                             // 822\n                                                                                                                     // 823\n      var invocation = new DDPCommon.MethodInvocation({                                                              // 824\n        isSimulation: true,                                                                                          // 825\n        userId: self.userId(),                                                                                       // 826\n        setUserId: setUserId,                                                                                        // 827\n        randomSeed: function () { return randomSeedGenerator(); }                                                    // 828\n      });                                                                                                            // 829\n                                                                                                                     // 830\n      if (!alreadyInSimulation)                                                                                      // 831\n        self._saveOriginals();                                                                                       // 832\n                                                                                                                     // 833\n      try {                                                                                                          // 834\n        // Note that unlike in the corresponding server code, we never audit                                         // 835\n        // that stubs check() their arguments.                                                                       // 836\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {                             // 837\n          if (Meteor.isServer) {                                                                                     // 838\n            // Because saveOriginals and retrieveOriginals aren't reentrant,                                         // 839\n            // don't allow stubs to yield.                                                                           // 840\n            return Meteor._noYieldsAllowed(function () {                                                             // 841\n              // re-clone, so that the stub can't affect our caller's values                                         // 842\n              return stub.apply(invocation, EJSON.clone(args));                                                      // 843\n            });                                                                                                      // 844\n          } else {                                                                                                   // 845\n            return stub.apply(invocation, EJSON.clone(args));                                                        // 846\n          }                                                                                                          // 847\n        });                                                                                                          // 848\n      }                                                                                                              // 849\n      catch (e) {                                                                                                    // 850\n        var exception = e;                                                                                           // 851\n      }                                                                                                              // 852\n                                                                                                                     // 853\n      if (!alreadyInSimulation)                                                                                      // 854\n        self._retrieveAndStoreOriginals(methodId());                                                                 // 855\n    }                                                                                                                // 856\n                                                                                                                     // 857\n    // If we're in a simulation, stop and return the result we have,                                                 // 858\n    // rather than going on to do an RPC. If there was no stub,                                                      // 859\n    // we'll end up returning undefined.                                                                             // 860\n    if (alreadyInSimulation) {                                                                                       // 861\n      if (callback) {                                                                                                // 862\n        callback(exception, stubReturnValue);                                                                        // 863\n        return undefined;                                                                                            // 864\n      }                                                                                                              // 865\n      if (exception)                                                                                                 // 866\n        throw exception;                                                                                             // 867\n      return stubReturnValue;                                                                                        // 868\n    }                                                                                                                // 869\n                                                                                                                     // 870\n    // If an exception occurred in a stub, and we're ignoring it                                                     // 871\n    // because we're doing an RPC and want to use what the server                                                    // 872\n    // returns instead, log it so the developer knows                                                                // 873\n    // (unless they explicitly ask to see the error).                                                                // 874\n    //                                                                                                               // 875\n    // Tests can set the 'expected' flag on an exception so it won't                                                 // 876\n    // go to log.                                                                                                    // 877\n    if (exception) {                                                                                                 // 878\n      if (options.throwStubExceptions) {                                                                             // 879\n        throw exception;                                                                                             // 880\n      } else if (!exception.expected) {                                                                              // 881\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +                                        // 882\n          name + \"'\", exception, exception.stack);                                                                   // 883\n      }                                                                                                              // 884\n    }                                                                                                                // 885\n                                                                                                                     // 886\n                                                                                                                     // 887\n    // At this point we're definitely doing an RPC, and we're going to                                               // 888\n    // return the value of the RPC to the caller.                                                                    // 889\n                                                                                                                     // 890\n    // If the caller didn't give a callback, decide what to do.                                                      // 891\n    if (!callback) {                                                                                                 // 892\n      if (Meteor.isClient) {                                                                                         // 893\n        // On the client, we don't have fibers, so we can't block. The                                               // 894\n        // only thing we can do is to return undefined and discard the                                               // 895\n        // result of the RPC. If an error occurred then print the error                                              // 896\n        // to the console.                                                                                           // 897\n        callback = function (err) {                                                                                  // 898\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",                                              // 899\n                               err.message);                                                                         // 900\n        };                                                                                                           // 901\n      } else {                                                                                                       // 902\n        // On the server, make the function synchronous. Throw on                                                    // 903\n        // errors, return on success.                                                                                // 904\n        var future = new Future;                                                                                     // 905\n        callback = future.resolver();                                                                                // 906\n      }                                                                                                              // 907\n    }                                                                                                                // 908\n    // Send the RPC. Note that on the client, it is important that the                                               // 909\n    // stub have finished before we send the RPC, so that we know we have                                            // 910\n    // a complete list of which local documents the stub wrote.                                                      // 911\n    var message = {                                                                                                  // 912\n      msg: 'method',                                                                                                 // 913\n      method: name,                                                                                                  // 914\n      params: args,                                                                                                  // 915\n      id: methodId()                                                                                                 // 916\n    };                                                                                                               // 917\n                                                                                                                     // 918\n    // Send the randomSeed only if we used it                                                                        // 919\n    if (randomSeed !== null) {                                                                                       // 920\n      message.randomSeed = randomSeed;                                                                               // 921\n    }                                                                                                                // 922\n                                                                                                                     // 923\n    var methodInvoker = new MethodInvoker({                                                                          // 924\n      methodId: methodId(),                                                                                          // 925\n      callback: callback,                                                                                            // 926\n      connection: self,                                                                                              // 927\n      onResultReceived: options.onResultReceived,                                                                    // 928\n      wait: !!options.wait,                                                                                          // 929\n      message: message,                                                                                              // 930\n      noRetry: !!options.noRetry                                                                                     // 931\n    });                                                                                                              // 932\n                                                                                                                     // 933\n    if (options.wait) {                                                                                              // 934\n      // It's a wait method! Wait methods go in their own block.                                                     // 935\n      self._outstandingMethodBlocks.push(                                                                            // 936\n        {wait: true, methods: [methodInvoker]});                                                                     // 937\n    } else {                                                                                                         // 938\n      // Not a wait method. Start a new block if the previous block was a wait                                       // 939\n      // block, and add it to the last block of methods.                                                             // 940\n      if (_.isEmpty(self._outstandingMethodBlocks) ||                                                                // 941\n          _.last(self._outstandingMethodBlocks).wait)                                                                // 942\n        self._outstandingMethodBlocks.push({wait: false, methods: []});                                              // 943\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                             // 944\n    }                                                                                                                // 945\n                                                                                                                     // 946\n    // If we added it to the first block, send it out now.                                                           // 947\n    if (self._outstandingMethodBlocks.length === 1)                                                                  // 948\n      methodInvoker.sendMessage();                                                                                   // 949\n                                                                                                                     // 950\n    // If we're using the default callback on the server,                                                            // 951\n    // block waiting for the result.                                                                                 // 952\n    if (future) {                                                                                                    // 953\n      return future.wait();                                                                                          // 954\n    }                                                                                                                // 955\n    return options.returnStubValue ? stubReturnValue : undefined;                                                    // 956\n  },                                                                                                                 // 957\n                                                                                                                     // 958\n  // Before calling a method stub, prepare all stores to track changes and allow                                     // 959\n  // _retrieveAndStoreOriginals to get the original versions of changed                                              // 960\n  // documents.                                                                                                      // 961\n  _saveOriginals: function () {                                                                                      // 962\n    var self = this;                                                                                                 // 963\n    _.each(self._stores, function (s) {                                                                              // 964\n      s.saveOriginals();                                                                                             // 965\n    });                                                                                                              // 966\n  },                                                                                                                 // 967\n  // Retrieves the original versions of all documents modified by the stub for                                       // 968\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                     // 969\n  // by document) and _documentsWrittenByStub (keyed by method ID).                                                  // 970\n  _retrieveAndStoreOriginals: function (methodId) {                                                                  // 971\n    var self = this;                                                                                                 // 972\n    if (self._documentsWrittenByStub[methodId])                                                                      // 973\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");                                           // 974\n                                                                                                                     // 975\n    var docsWritten = [];                                                                                            // 976\n    _.each(self._stores, function (s, collection) {                                                                  // 977\n      var originals = s.retrieveOriginals();                                                                         // 978\n      // not all stores define retrieveOriginals                                                                     // 979\n      if (!originals)                                                                                                // 980\n        return;                                                                                                      // 981\n      originals.forEach(function (doc, id) {                                                                         // 982\n        docsWritten.push({collection: collection, id: id});                                                          // 983\n        if (!_.has(self._serverDocuments, collection))                                                               // 984\n          self._serverDocuments[collection] = new MongoIDMap;                                                        // 985\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});                                        // 986\n        if (serverDoc.writtenByStubs) {                                                                              // 987\n          // We're not the first stub to write this doc. Just add our method ID                                      // 988\n          // to the record.                                                                                          // 989\n          serverDoc.writtenByStubs[methodId] = true;                                                                 // 990\n        } else {                                                                                                     // 991\n          // First stub! Save the original value and our method ID.                                                  // 992\n          serverDoc.document = doc;                                                                                  // 993\n          serverDoc.flushCallbacks = [];                                                                             // 994\n          serverDoc.writtenByStubs = {};                                                                             // 995\n          serverDoc.writtenByStubs[methodId] = true;                                                                 // 996\n        }                                                                                                            // 997\n      });                                                                                                            // 998\n    });                                                                                                              // 999\n    if (!_.isEmpty(docsWritten)) {                                                                                   // 1000\n      self._documentsWrittenByStub[methodId] = docsWritten;                                                          // 1001\n    }                                                                                                                // 1002\n  },                                                                                                                 // 1003\n                                                                                                                     // 1004\n  // This is very much a private function we use to make the tests                                                   // 1005\n  // take up fewer server resources after they complete.                                                             // 1006\n  _unsubscribeAll: function () {                                                                                     // 1007\n    var self = this;                                                                                                 // 1008\n    _.each(_.clone(self._subscriptions), function (sub, id) {                                                        // 1009\n      // Avoid killing the autoupdate subscription so that developers                                                // 1010\n      // still get hot code pushes when writing tests.                                                               // 1011\n      //                                                                                                             // 1012\n      // XXX it's a hack to encode knowledge about autoupdate here,                                                  // 1013\n      // but it doesn't seem worth it yet to have a special API for                                                  // 1014\n      // subscriptions to preserve after unit tests.                                                                 // 1015\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {                                                         // 1016\n        self._subscriptions[id].stop();                                                                              // 1017\n      }                                                                                                              // 1018\n    });                                                                                                              // 1019\n  },                                                                                                                 // 1020\n                                                                                                                     // 1021\n  // Sends the DDP stringification of the given message object                                                       // 1022\n  _send: function (obj) {                                                                                            // 1023\n    var self = this;                                                                                                 // 1024\n    self._stream.send(DDPCommon.stringifyDDP(obj));                                                                  // 1025\n  },                                                                                                                 // 1026\n                                                                                                                     // 1027\n  // We detected via DDP-level heartbeats that we've lost the                                                        // 1028\n  // connection.  Unlike `disconnect` or `close`, a lost connection                                                  // 1029\n  // will be automatically retried.                                                                                  // 1030\n  _lostConnection: function (error) {                                                                                // 1031\n    var self = this;                                                                                                 // 1032\n    self._stream._lostConnection(error);                                                                             // 1033\n  },                                                                                                                 // 1034\n                                                                                                                     // 1035\n  /**                                                                                                                // 1036\n   * @summary Get the current connection status. A reactive data source.                                             // 1037\n   * @locus Client                                                                                                   // 1038\n   * @memberOf Meteor                                                                                                // 1039\n   * @importFromPackage meteor                                                                                       // 1040\n   */                                                                                                                // 1041\n  status: function (/*passthrough args*/) {                                                                          // 1042\n    var self = this;                                                                                                 // 1043\n    return self._stream.status.apply(self._stream, arguments);                                                       // 1044\n  },                                                                                                                 // 1045\n                                                                                                                     // 1046\n  /**                                                                                                                // 1047\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.                  // 1048\n                                                                                                                     // 1049\n  This method does nothing if the client is already connected.                                                       // 1050\n   * @locus Client                                                                                                   // 1051\n   * @memberOf Meteor                                                                                                // 1052\n   * @importFromPackage meteor                                                                                       // 1053\n   */                                                                                                                // 1054\n  reconnect: function (/*passthrough args*/) {                                                                       // 1055\n    var self = this;                                                                                                 // 1056\n    return self._stream.reconnect.apply(self._stream, arguments);                                                    // 1057\n  },                                                                                                                 // 1058\n                                                                                                                     // 1059\n  /**                                                                                                                // 1060\n   * @summary Disconnect the client from the server.                                                                 // 1061\n   * @locus Client                                                                                                   // 1062\n   * @memberOf Meteor                                                                                                // 1063\n   * @importFromPackage meteor                                                                                       // 1064\n   */                                                                                                                // 1065\n  disconnect: function (/*passthrough args*/) {                                                                      // 1066\n    var self = this;                                                                                                 // 1067\n    return self._stream.disconnect.apply(self._stream, arguments);                                                   // 1068\n  },                                                                                                                 // 1069\n                                                                                                                     // 1070\n  close: function () {                                                                                               // 1071\n    var self = this;                                                                                                 // 1072\n    return self._stream.disconnect({_permanent: true});                                                              // 1073\n  },                                                                                                                 // 1074\n                                                                                                                     // 1075\n  ///                                                                                                                // 1076\n  /// Reactive user system                                                                                           // 1077\n  ///                                                                                                                // 1078\n  userId: function () {                                                                                              // 1079\n    var self = this;                                                                                                 // 1080\n    if (self._userIdDeps)                                                                                            // 1081\n      self._userIdDeps.depend();                                                                                     // 1082\n    return self._userId;                                                                                             // 1083\n  },                                                                                                                 // 1084\n                                                                                                                     // 1085\n  setUserId: function (userId) {                                                                                     // 1086\n    var self = this;                                                                                                 // 1087\n    // Avoid invalidating dependents if setUserId is called with current value.                                      // 1088\n    if (self._userId === userId)                                                                                     // 1089\n      return;                                                                                                        // 1090\n    self._userId = userId;                                                                                           // 1091\n    if (self._userIdDeps)                                                                                            // 1092\n      self._userIdDeps.changed();                                                                                    // 1093\n  },                                                                                                                 // 1094\n                                                                                                                     // 1095\n  // Returns true if we are in a state after reconnect of waiting for subs to be                                     // 1096\n  // revived or early methods to finish their data, or we are waiting for a                                          // 1097\n  // \"wait\" method to finish.                                                                                        // 1098\n  _waitingForQuiescence: function () {                                                                               // 1099\n    var self = this;                                                                                                 // 1100\n    return (! _.isEmpty(self._subsBeingRevived) ||                                                                   // 1101\n            ! _.isEmpty(self._methodsBlockingQuiescence));                                                           // 1102\n  },                                                                                                                 // 1103\n                                                                                                                     // 1104\n  // Returns true if any method whose message has been sent to the server has                                        // 1105\n  // not yet invoked its user callback.                                                                              // 1106\n  _anyMethodsAreOutstanding: function () {                                                                           // 1107\n    var self = this;                                                                                                 // 1108\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                      // 1109\n  },                                                                                                                 // 1110\n                                                                                                                     // 1111\n  _livedata_connected: function (msg) {                                                                              // 1112\n    var self = this;                                                                                                 // 1113\n                                                                                                                     // 1114\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {                                                 // 1115\n      self._heartbeat = new DDPCommon.Heartbeat({                                                                    // 1116\n        heartbeatInterval: self._heartbeatInterval,                                                                  // 1117\n        heartbeatTimeout: self._heartbeatTimeout,                                                                    // 1118\n        onTimeout: function () {                                                                                     // 1119\n          self._lostConnection(                                                                                      // 1120\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));                                                     // 1121\n        },                                                                                                           // 1122\n        sendPing: function () {                                                                                      // 1123\n          self._send({msg: 'ping'});                                                                                 // 1124\n        }                                                                                                            // 1125\n      });                                                                                                            // 1126\n      self._heartbeat.start();                                                                                       // 1127\n    }                                                                                                                // 1128\n                                                                                                                     // 1129\n    // If this is a reconnect, we'll have to reset all stores.                                                       // 1130\n    if (self._lastSessionId)                                                                                         // 1131\n      self._resetStores = true;                                                                                      // 1132\n                                                                                                                     // 1133\n    if (typeof (msg.session) === \"string\") {                                                                         // 1134\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);                                      // 1135\n      self._lastSessionId = msg.session;                                                                             // 1136\n    }                                                                                                                // 1137\n                                                                                                                     // 1138\n    if (reconnectedToPreviousSession) {                                                                              // 1139\n      // Successful reconnection -- pick up where we left off.  Note that right                                      // 1140\n      // now, this never happens: the server never connects us to a previous                                         // 1141\n      // session, because DDP doesn't provide enough data for the server to know                                     // 1142\n      // what messages the client has processed. We need to improve DDP to make                                      // 1143\n      // this possible, at which point we'll probably need more code here.                                           // 1144\n      return;                                                                                                        // 1145\n    }                                                                                                                // 1146\n                                                                                                                     // 1147\n    // Server doesn't have our data any more. Re-sync a new session.                                                 // 1148\n                                                                                                                     // 1149\n    // Forget about messages we were buffering for unknown collections. They'll                                      // 1150\n    // be resent if still relevant.                                                                                  // 1151\n    self._updatesForUnknownStores = {};                                                                              // 1152\n                                                                                                                     // 1153\n    if (self._resetStores) {                                                                                         // 1154\n      // Forget about the effects of stubs. We'll be resetting all collections                                       // 1155\n      // anyway.                                                                                                     // 1156\n      self._documentsWrittenByStub = {};                                                                             // 1157\n      self._serverDocuments = {};                                                                                    // 1158\n    }                                                                                                                // 1159\n                                                                                                                     // 1160\n    // Clear _afterUpdateCallbacks.                                                                                  // 1161\n    self._afterUpdateCallbacks = [];                                                                                 // 1162\n                                                                                                                     // 1163\n    // Mark all named subscriptions which are ready (ie, we already called the                                       // 1164\n    // ready callback) as needing to be revived.                                                                     // 1165\n    // XXX We should also block reconnect quiescence until unnamed subscriptions                                     // 1166\n    //     (eg, autopublish) are done re-publishing to avoid flicker!                                                // 1167\n    self._subsBeingRevived = {};                                                                                     // 1168\n    _.each(self._subscriptions, function (sub, id) {                                                                 // 1169\n      if (sub.ready)                                                                                                 // 1170\n        self._subsBeingRevived[id] = true;                                                                           // 1171\n    });                                                                                                              // 1172\n                                                                                                                     // 1173\n    // Arrange for \"half-finished\" methods to have their callbacks run, and                                          // 1174\n    // track methods that were sent on this connection so that we don't                                              // 1175\n    // quiesce until they are all done.                                                                              // 1176\n    //                                                                                                               // 1177\n    // Start by clearing _methodsBlockingQuiescence: methods sent before                                             // 1178\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection                                     // 1179\n    // that we drop here will be restored by the loop below.                                                         // 1180\n    self._methodsBlockingQuiescence = {};                                                                            // 1181\n    if (self._resetStores) {                                                                                         // 1182\n      _.each(self._methodInvokers, function (invoker) {                                                              // 1183\n        if (invoker.gotResult()) {                                                                                   // 1184\n          // This method already got its result, but it didn't call its callback                                     // 1185\n          // because its data didn't become visible. We did not resend the                                           // 1186\n          // method RPC. We'll call its callback when we get a full quiesce,                                         // 1187\n          // since that's as close as we'll get to \"data must be visible\".                                           // 1188\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                     // 1189\n        } else if (invoker.sentMessage) {                                                                            // 1190\n          // This method has been sent on this connection (maybe as a resend                                         // 1191\n          // from the last connection, maybe from onReconnect, maybe just very                                       // 1192\n          // quickly before processing the connected message).                                                       // 1193\n          //                                                                                                         // 1194\n          // We don't need to do anything special to ensure its callbacks get                                        // 1195\n          // called, but we'll count it as a method which is preventing                                              // 1196\n          // reconnect quiescence. (eg, it might be a login method that was run                                      // 1197\n          // from onReconnect, and we don't want to see flicker by seeing a                                          // 1198\n          // logged-out state.)                                                                                      // 1199\n          self._methodsBlockingQuiescence[invoker.methodId] = true;                                                  // 1200\n        }                                                                                                            // 1201\n      });                                                                                                            // 1202\n    }                                                                                                                // 1203\n                                                                                                                     // 1204\n    self._messagesBufferedUntilQuiescence = [];                                                                      // 1205\n                                                                                                                     // 1206\n    // If we're not waiting on any methods or subs, we can reset the stores and                                      // 1207\n    // call the callbacks immediately.                                                                               // 1208\n    if (!self._waitingForQuiescence()) {                                                                             // 1209\n      if (self._resetStores) {                                                                                       // 1210\n        _.each(self._stores, function (s) {                                                                          // 1211\n          s.beginUpdate(0, true);                                                                                    // 1212\n          s.endUpdate();                                                                                             // 1213\n        });                                                                                                          // 1214\n        self._resetStores = false;                                                                                   // 1215\n      }                                                                                                              // 1216\n      self._runAfterUpdateCallbacks();                                                                               // 1217\n    }                                                                                                                // 1218\n  },                                                                                                                 // 1219\n                                                                                                                     // 1220\n                                                                                                                     // 1221\n  _processOneDataMessage: function (msg, updates) {                                                                  // 1222\n    var self = this;                                                                                                 // 1223\n    // Using underscore here so as not to need to capitalize.                                                        // 1224\n    self['_process_' + msg.msg](msg, updates);                                                                       // 1225\n  },                                                                                                                 // 1226\n                                                                                                                     // 1227\n                                                                                                                     // 1228\n  _livedata_data: function (msg) {                                                                                   // 1229\n    var self = this;                                                                                                 // 1230\n                                                                                                                     // 1231\n    // collection name -> array of messages                                                                          // 1232\n    var updates = {};                                                                                                // 1233\n                                                                                                                     // 1234\n    if (self._waitingForQuiescence()) {                                                                              // 1235\n      self._messagesBufferedUntilQuiescence.push(msg);                                                               // 1236\n                                                                                                                     // 1237\n      if (msg.msg === \"nosub\")                                                                                       // 1238\n        delete self._subsBeingRevived[msg.id];                                                                       // 1239\n                                                                                                                     // 1240\n      _.each(msg.subs || [], function (subId) {                                                                      // 1241\n        delete self._subsBeingRevived[subId];                                                                        // 1242\n      });                                                                                                            // 1243\n      _.each(msg.methods || [], function (methodId) {                                                                // 1244\n        delete self._methodsBlockingQuiescence[methodId];                                                            // 1245\n      });                                                                                                            // 1246\n                                                                                                                     // 1247\n      if (self._waitingForQuiescence())                                                                              // 1248\n        return;                                                                                                      // 1249\n                                                                                                                     // 1250\n      // No methods or subs are blocking quiescence!                                                                 // 1251\n      // We'll now process and all of our buffered messages, reset all stores,                                       // 1252\n      // and apply them all at once.                                                                                 // 1253\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                         // 1254\n        self._processOneDataMessage(bufferedMsg, updates);                                                           // 1255\n      });                                                                                                            // 1256\n      self._messagesBufferedUntilQuiescence = [];                                                                    // 1257\n    } else {                                                                                                         // 1258\n      self._processOneDataMessage(msg, updates);                                                                     // 1259\n    }                                                                                                                // 1260\n                                                                                                                     // 1261\n    if (self._resetStores || !_.isEmpty(updates)) {                                                                  // 1262\n      // Begin a transactional update of each store.                                                                 // 1263\n      _.each(self._stores, function (s, storeName) {                                                                 // 1264\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,                                     // 1265\n                      self._resetStores);                                                                            // 1266\n      });                                                                                                            // 1267\n      self._resetStores = false;                                                                                     // 1268\n                                                                                                                     // 1269\n      _.each(updates, function (updateMessages, storeName) {                                                         // 1270\n        var store = self._stores[storeName];                                                                         // 1271\n        if (store) {                                                                                                 // 1272\n          _.each(updateMessages, function (updateMessage) {                                                          // 1273\n            store.update(updateMessage);                                                                             // 1274\n          });                                                                                                        // 1275\n        } else {                                                                                                     // 1276\n          // Nobody's listening for this data. Queue it up until                                                     // 1277\n          // someone wants it.                                                                                       // 1278\n          // XXX memory use will grow without bound if you forget to                                                 // 1279\n          // create a collection or just don't care about it... going                                                // 1280\n          // to have to do something about that.                                                                     // 1281\n          if (!_.has(self._updatesForUnknownStores, storeName))                                                      // 1282\n            self._updatesForUnknownStores[storeName] = [];                                                           // 1283\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],                                       // 1284\n                                     updateMessages);                                                                // 1285\n        }                                                                                                            // 1286\n      });                                                                                                            // 1287\n                                                                                                                     // 1288\n      // End update transaction.                                                                                     // 1289\n      _.each(self._stores, function (s) { s.endUpdate(); });                                                         // 1290\n    }                                                                                                                // 1291\n                                                                                                                     // 1292\n    self._runAfterUpdateCallbacks();                                                                                 // 1293\n  },                                                                                                                 // 1294\n                                                                                                                     // 1295\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                          // 1296\n  // relevant docs have been flushed, as well as dataVisible callbacks at                                            // 1297\n  // reconnect-quiescence time.                                                                                      // 1298\n  _runAfterUpdateCallbacks: function () {                                                                            // 1299\n    var self = this;                                                                                                 // 1300\n    var callbacks = self._afterUpdateCallbacks;                                                                      // 1301\n    self._afterUpdateCallbacks = [];                                                                                 // 1302\n    _.each(callbacks, function (c) {                                                                                 // 1303\n      c();                                                                                                           // 1304\n    });                                                                                                              // 1305\n  },                                                                                                                 // 1306\n                                                                                                                     // 1307\n  _pushUpdate: function (updates, collection, msg) {                                                                 // 1308\n    var self = this;                                                                                                 // 1309\n    if (!_.has(updates, collection)) {                                                                               // 1310\n      updates[collection] = [];                                                                                      // 1311\n    }                                                                                                                // 1312\n    updates[collection].push(msg);                                                                                   // 1313\n  },                                                                                                                 // 1314\n                                                                                                                     // 1315\n  _getServerDoc: function (collection, id) {                                                                         // 1316\n    var self = this;                                                                                                 // 1317\n    if (!_.has(self._serverDocuments, collection))                                                                   // 1318\n      return null;                                                                                                   // 1319\n    var serverDocsForCollection = self._serverDocuments[collection];                                                 // 1320\n    return serverDocsForCollection.get(id) || null;                                                                  // 1321\n  },                                                                                                                 // 1322\n                                                                                                                     // 1323\n  _process_added: function (msg, updates) {                                                                          // 1324\n    var self = this;                                                                                                 // 1325\n    var id = MongoID.idParse(msg.id);                                                                                // 1326\n    var serverDoc = self._getServerDoc(msg.collection, id);                                                          // 1327\n    if (serverDoc) {                                                                                                 // 1328\n      // Some outstanding stub wrote here.                                                                           // 1329\n      var isExisting = (serverDoc.document !== undefined);                                                           // 1330\n                                                                                                                     // 1331\n      serverDoc.document = msg.fields || {};                                                                         // 1332\n      serverDoc.document._id = id;                                                                                   // 1333\n                                                                                                                     // 1334\n      if (self._resetStores) {                                                                                       // 1335\n        // During reconnect the server is sending adds for existing ids.                                             // 1336\n        // Always push an update so that document stays in the store after                                           // 1337\n        // reset. Use current version of the document for this update, so                                            // 1338\n        // that stub-written values are preserved.                                                                   // 1339\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);                                                // 1340\n        if (currentDoc !== undefined)                                                                                // 1341\n          msg.fields = currentDoc;                                                                                   // 1342\n                                                                                                                     // 1343\n        self._pushUpdate(updates, msg.collection, msg);                                                              // 1344\n      } else if (isExisting) {                                                                                       // 1345\n        throw new Error(\"Server sent add for existing id: \" + msg.id);                                               // 1346\n      }                                                                                                              // 1347\n    } else {                                                                                                         // 1348\n      self._pushUpdate(updates, msg.collection, msg);                                                                // 1349\n    }                                                                                                                // 1350\n  },                                                                                                                 // 1351\n                                                                                                                     // 1352\n  _process_changed: function (msg, updates) {                                                                        // 1353\n    var self = this;                                                                                                 // 1354\n    var serverDoc = self._getServerDoc(                                                                              // 1355\n      msg.collection, MongoID.idParse(msg.id));                                                                      // 1356\n    if (serverDoc) {                                                                                                 // 1357\n      if (serverDoc.document === undefined)                                                                          // 1358\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);                                        // 1359\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);                                                     // 1360\n    } else {                                                                                                         // 1361\n      self._pushUpdate(updates, msg.collection, msg);                                                                // 1362\n    }                                                                                                                // 1363\n  },                                                                                                                 // 1364\n                                                                                                                     // 1365\n  _process_removed: function (msg, updates) {                                                                        // 1366\n    var self = this;                                                                                                 // 1367\n    var serverDoc = self._getServerDoc(                                                                              // 1368\n      msg.collection, MongoID.idParse(msg.id));                                                                      // 1369\n    if (serverDoc) {                                                                                                 // 1370\n      // Some outstanding stub wrote here.                                                                           // 1371\n      if (serverDoc.document === undefined)                                                                          // 1372\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);                                         // 1373\n      serverDoc.document = undefined;                                                                                // 1374\n    } else {                                                                                                         // 1375\n      self._pushUpdate(updates, msg.collection, {                                                                    // 1376\n        msg: 'removed',                                                                                              // 1377\n        collection: msg.collection,                                                                                  // 1378\n        id: msg.id                                                                                                   // 1379\n      });                                                                                                            // 1380\n    }                                                                                                                // 1381\n  },                                                                                                                 // 1382\n                                                                                                                     // 1383\n  _process_updated: function (msg, updates) {                                                                        // 1384\n    var self = this;                                                                                                 // 1385\n    // Process \"method done\" messages.                                                                               // 1386\n    _.each(msg.methods, function (methodId) {                                                                        // 1387\n      _.each(self._documentsWrittenByStub[methodId], function (written) {                                            // 1388\n        var serverDoc = self._getServerDoc(written.collection, written.id);                                          // 1389\n        if (!serverDoc)                                                                                              // 1390\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));                                          // 1391\n        if (!serverDoc.writtenByStubs[methodId])                                                                     // 1392\n          throw new Error(\"Doc \" + JSON.stringify(written) +                                                         // 1393\n                          \" not written by  method \" + methodId);                                                    // 1394\n        delete serverDoc.writtenByStubs[methodId];                                                                   // 1395\n        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                   // 1396\n          // All methods whose stubs wrote this method have completed! We can                                        // 1397\n          // now copy the saved document to the database (reverting the stub's                                       // 1398\n          // change if the server did not write to this object, or applying the                                      // 1399\n          // server's writes if it did).                                                                             // 1400\n                                                                                                                     // 1401\n          // This is a fake ddp 'replace' message.  It's just for talking                                            // 1402\n          // between livedata connections and minimongo.  (We have to stringify                                      // 1403\n          // the ID because it's supposed to look like a wire message.)                                              // 1404\n          self._pushUpdate(updates, written.collection, {                                                            // 1405\n            msg: 'replace',                                                                                          // 1406\n            id: MongoID.idStringify(written.id),                                                                     // 1407\n            replace: serverDoc.document                                                                              // 1408\n          });                                                                                                        // 1409\n          // Call all flush callbacks.                                                                               // 1410\n          _.each(serverDoc.flushCallbacks, function (c) {                                                            // 1411\n            c();                                                                                                     // 1412\n          });                                                                                                        // 1413\n                                                                                                                     // 1414\n          // Delete this completed serverDocument. Don't bother to GC empty                                          // 1415\n          // IdMaps inside self._serverDocuments, since there probably aren't                                        // 1416\n          // many collections and they'll be written repeatedly.                                                     // 1417\n          self._serverDocuments[written.collection].remove(written.id);                                              // 1418\n        }                                                                                                            // 1419\n      });                                                                                                            // 1420\n      delete self._documentsWrittenByStub[methodId];                                                                 // 1421\n                                                                                                                     // 1422\n      // We want to call the data-written callback, but we can't do so until all                                     // 1423\n      // currently buffered messages are flushed.                                                                    // 1424\n      var callbackInvoker = self._methodInvokers[methodId];                                                          // 1425\n      if (!callbackInvoker)                                                                                          // 1426\n        throw new Error(\"No callback invoker for method \" + methodId);                                               // 1427\n      self._runWhenAllServerDocsAreFlushed(                                                                          // 1428\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));                                                       // 1429\n    });                                                                                                              // 1430\n  },                                                                                                                 // 1431\n                                                                                                                     // 1432\n  _process_ready: function (msg, updates) {                                                                          // 1433\n    var self = this;                                                                                                 // 1434\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect                                          // 1435\n    // until all current server documents have been flushed to the local                                             // 1436\n    // database. We can use a write fence to implement this.                                                         // 1437\n    _.each(msg.subs, function (subId) {                                                                              // 1438\n      self._runWhenAllServerDocsAreFlushed(function () {                                                             // 1439\n        var subRecord = self._subscriptions[subId];                                                                  // 1440\n        // Did we already unsubscribe?                                                                               // 1441\n        if (!subRecord)                                                                                              // 1442\n          return;                                                                                                    // 1443\n        // Did we already receive a ready message? (Oops!)                                                           // 1444\n        if (subRecord.ready)                                                                                         // 1445\n          return;                                                                                                    // 1446\n        subRecord.ready = true;                                                                                      // 1447\n        subRecord.readyCallback && subRecord.readyCallback();                                                        // 1448\n        subRecord.readyDeps.changed();                                                                               // 1449\n      });                                                                                                            // 1450\n    });                                                                                                              // 1451\n  },                                                                                                                 // 1452\n                                                                                                                     // 1453\n  // Ensures that \"f\" will be called after all documents currently in                                                // 1454\n  // _serverDocuments have been written to the local cache. f will not be called                                     // 1455\n  // if the connection is lost before then!                                                                          // 1456\n  _runWhenAllServerDocsAreFlushed: function (f) {                                                                    // 1457\n    var self = this;                                                                                                 // 1458\n    var runFAfterUpdates = function () {                                                                             // 1459\n      self._afterUpdateCallbacks.push(f);                                                                            // 1460\n    };                                                                                                               // 1461\n    var unflushedServerDocCount = 0;                                                                                 // 1462\n    var onServerDocFlush = function () {                                                                             // 1463\n      --unflushedServerDocCount;                                                                                     // 1464\n      if (unflushedServerDocCount === 0) {                                                                           // 1465\n        // This was the last doc to flush! Arrange to run f after the updates                                        // 1466\n        // have been applied.                                                                                        // 1467\n        runFAfterUpdates();                                                                                          // 1468\n      }                                                                                                              // 1469\n    };                                                                                                               // 1470\n    _.each(self._serverDocuments, function (collectionDocs) {                                                        // 1471\n      collectionDocs.forEach(function (serverDoc) {                                                                  // 1472\n        var writtenByStubForAMethodWithSentMessage = _.any(                                                          // 1473\n          serverDoc.writtenByStubs, function (dummy, methodId) {                                                     // 1474\n            var invoker = self._methodInvokers[methodId];                                                            // 1475\n            return invoker && invoker.sentMessage;                                                                   // 1476\n          });                                                                                                        // 1477\n        if (writtenByStubForAMethodWithSentMessage) {                                                                // 1478\n          ++unflushedServerDocCount;                                                                                 // 1479\n          serverDoc.flushCallbacks.push(onServerDocFlush);                                                           // 1480\n        }                                                                                                            // 1481\n      });                                                                                                            // 1482\n    });                                                                                                              // 1483\n    if (unflushedServerDocCount === 0) {                                                                             // 1484\n      // There aren't any buffered docs --- we can call f as soon as the current                                     // 1485\n      // round of updates is applied!                                                                                // 1486\n      runFAfterUpdates();                                                                                            // 1487\n    }                                                                                                                // 1488\n  },                                                                                                                 // 1489\n                                                                                                                     // 1490\n  _livedata_nosub: function (msg) {                                                                                  // 1491\n    var self = this;                                                                                                 // 1492\n                                                                                                                     // 1493\n    // First pass it through _livedata_data, which only uses it to help get                                          // 1494\n    // towards quiescence.                                                                                           // 1495\n    self._livedata_data(msg);                                                                                        // 1496\n                                                                                                                     // 1497\n    // Do the rest of our processing immediately, with no                                                            // 1498\n    // buffering-until-quiescence.                                                                                   // 1499\n                                                                                                                     // 1500\n    // we weren't subbed anyway, or we initiated the unsub.                                                          // 1501\n    if (!_.has(self._subscriptions, msg.id))                                                                         // 1502\n      return;                                                                                                        // 1503\n                                                                                                                     // 1504\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                        // 1505\n    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                   // 1506\n    var stopCallback = self._subscriptions[msg.id].stopCallback;                                                     // 1507\n                                                                                                                     // 1508\n    self._subscriptions[msg.id].remove();                                                                            // 1509\n                                                                                                                     // 1510\n    var meteorErrorFromMsg = function (msgArg) {                                                                     // 1511\n      return msgArg && msgArg.error && new Meteor.Error(                                                             // 1512\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);                                              // 1513\n    }                                                                                                                // 1514\n                                                                                                                     // 1515\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                        // 1516\n    if (errorCallback && msg.error) {                                                                                // 1517\n      errorCallback(meteorErrorFromMsg(msg));                                                                        // 1518\n    }                                                                                                                // 1519\n                                                                                                                     // 1520\n    if (stopCallback) {                                                                                              // 1521\n      stopCallback(meteorErrorFromMsg(msg));                                                                         // 1522\n    }                                                                                                                // 1523\n  },                                                                                                                 // 1524\n                                                                                                                     // 1525\n  _process_nosub: function () {                                                                                      // 1526\n    // This is called as part of the \"buffer until quiescence\" process, but                                          // 1527\n    // nosub's effect is always immediate. It only goes in the buffer at all                                         // 1528\n    // because it's possible for a nosub to be the thing that triggers                                               // 1529\n    // quiescence, if we were waiting for a sub to be revived and it dies                                            // 1530\n    // instead.                                                                                                      // 1531\n  },                                                                                                                 // 1532\n                                                                                                                     // 1533\n  _livedata_result: function (msg) {                                                                                 // 1534\n    // id, result or error. error has error (code), reason, details                                                  // 1535\n                                                                                                                     // 1536\n    var self = this;                                                                                                 // 1537\n                                                                                                                     // 1538\n    // find the outstanding request                                                                                  // 1539\n    // should be O(1) in nearly all realistic use cases                                                              // 1540\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                  // 1541\n      Meteor._debug(\"Received method result but no methods outstanding\");                                            // 1542\n      return;                                                                                                        // 1543\n    }                                                                                                                // 1544\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                               // 1545\n    var m;                                                                                                           // 1546\n    for (var i = 0; i < currentMethodBlock.length; i++) {                                                            // 1547\n      m = currentMethodBlock[i];                                                                                     // 1548\n      if (m.methodId === msg.id)                                                                                     // 1549\n        break;                                                                                                       // 1550\n    }                                                                                                                // 1551\n                                                                                                                     // 1552\n    if (!m) {                                                                                                        // 1553\n      Meteor._debug(\"Can't match method response to original method call\", msg);                                     // 1554\n      return;                                                                                                        // 1555\n    }                                                                                                                // 1556\n                                                                                                                     // 1557\n    // Remove from current method block. This may leave the block empty, but we                                      // 1558\n    // don't move on to the next block until the callback has been delivered, in                                     // 1559\n    // _outstandingMethodFinished.                                                                                   // 1560\n    currentMethodBlock.splice(i, 1);                                                                                 // 1561\n                                                                                                                     // 1562\n    if (_.has(msg, 'error')) {                                                                                       // 1563\n      m.receiveResult(new Meteor.Error(                                                                              // 1564\n        msg.error.error, msg.error.reason,                                                                           // 1565\n        msg.error.details));                                                                                         // 1566\n    } else {                                                                                                         // 1567\n      // msg.result may be undefined if the method didn't return a                                                   // 1568\n      // value                                                                                                       // 1569\n      m.receiveResult(undefined, msg.result);                                                                        // 1570\n    }                                                                                                                // 1571\n  },                                                                                                                 // 1572\n                                                                                                                     // 1573\n  // Called by MethodInvoker after a method's callback is invoked.  If this was                                      // 1574\n  // the last outstanding method in the current block, runs the next block. If                                       // 1575\n  // there are no more methods, consider accepting a hot code push.                                                  // 1576\n  _outstandingMethodFinished: function () {                                                                          // 1577\n    var self = this;                                                                                                 // 1578\n    if (self._anyMethodsAreOutstanding())                                                                            // 1579\n      return;                                                                                                        // 1580\n                                                                                                                     // 1581\n    // No methods are outstanding. This should mean that the first block of                                          // 1582\n    // methods is empty. (Or it might not exist, if this was a method that                                           // 1583\n    // half-finished before disconnect/reconnect.)                                                                   // 1584\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {                                                                // 1585\n      var firstBlock = self._outstandingMethodBlocks.shift();                                                        // 1586\n      if (! _.isEmpty(firstBlock.methods))                                                                           // 1587\n        throw new Error(\"No methods outstanding but nonempty block: \" +                                              // 1588\n                        JSON.stringify(firstBlock));                                                                 // 1589\n                                                                                                                     // 1590\n      // Send the outstanding methods now in the first block.                                                        // 1591\n      if (!_.isEmpty(self._outstandingMethodBlocks))                                                                 // 1592\n        self._sendOutstandingMethods();                                                                              // 1593\n    }                                                                                                                // 1594\n                                                                                                                     // 1595\n    // Maybe accept a hot code push.                                                                                 // 1596\n    self._maybeMigrate();                                                                                            // 1597\n  },                                                                                                                 // 1598\n                                                                                                                     // 1599\n  // Sends messages for all the methods in the first block in                                                        // 1600\n  // _outstandingMethodBlocks.                                                                                       // 1601\n  _sendOutstandingMethods: function() {                                                                              // 1602\n    var self = this;                                                                                                 // 1603\n    if (_.isEmpty(self._outstandingMethodBlocks))                                                                    // 1604\n      return;                                                                                                        // 1605\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                                  // 1606\n      m.sendMessage();                                                                                               // 1607\n    });                                                                                                              // 1608\n  },                                                                                                                 // 1609\n                                                                                                                     // 1610\n  _livedata_error: function (msg) {                                                                                  // 1611\n    Meteor._debug(\"Received error from server: \", msg.reason);                                                       // 1612\n    if (msg.offendingMessage)                                                                                        // 1613\n      Meteor._debug(\"For: \", msg.offendingMessage);                                                                  // 1614\n  },                                                                                                                 // 1615\n                                                                                                                     // 1616\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {                                                 // 1617\n    var self = this;                                                                                                 // 1618\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                                  // 1619\n    self._outstandingMethodBlocks = [];                                                                              // 1620\n                                                                                                                     // 1621\n    self.onReconnect();                                                                                              // 1622\n                                                                                                                     // 1623\n    if (_.isEmpty(oldOutstandingMethodBlocks))                                                                       // 1624\n      return;                                                                                                        // 1625\n                                                                                                                     // 1626\n    // We have at least one block worth of old outstanding methods to try                                            // 1627\n    // again. First: did onReconnect actually send anything? If not, we just                                         // 1628\n    // restore all outstanding methods and run the first block.                                                      // 1629\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                  // 1630\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                    // 1631\n      self._sendOutstandingMethods();                                                                                // 1632\n      return;                                                                                                        // 1633\n    }                                                                                                                // 1634\n                                                                                                                     // 1635\n    // OK, there are blocks on both sides. Special case: merge the last block of                                     // 1636\n    // the reconnect methods with the first block of the original methods, if                                        // 1637\n    // neither of them are \"wait\" blocks.                                                                            // 1638\n    if (!_.last(self._outstandingMethodBlocks).wait &&                                                               // 1639\n        !oldOutstandingMethodBlocks[0].wait) {                                                                       // 1640\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                   // 1641\n        _.last(self._outstandingMethodBlocks).methods.push(m);                                                       // 1642\n                                                                                                                     // 1643\n        // If this \"last block\" is also the first block, send the message.                                           // 1644\n        if (self._outstandingMethodBlocks.length === 1)                                                              // 1645\n          m.sendMessage();                                                                                           // 1646\n      });                                                                                                            // 1647\n                                                                                                                     // 1648\n      oldOutstandingMethodBlocks.shift();                                                                            // 1649\n    }                                                                                                                // 1650\n                                                                                                                     // 1651\n    // Now add the rest of the original blocks on.                                                                   // 1652\n    _.each(oldOutstandingMethodBlocks, function (block) {                                                            // 1653\n      self._outstandingMethodBlocks.push(block);                                                                     // 1654\n    });                                                                                                              // 1655\n  },                                                                                                                 // 1656\n                                                                                                                     // 1657\n  // We can accept a hot code push if there are no methods in flight.                                                // 1658\n  _readyToMigrate: function() {                                                                                      // 1659\n    var self = this;                                                                                                 // 1660\n    return _.isEmpty(self._methodInvokers);                                                                          // 1661\n  },                                                                                                                 // 1662\n                                                                                                                     // 1663\n  // If we were blocking a migration, see if it's now possible to continue.                                          // 1664\n  // Call whenever the set of outstanding/blocked methods shrinks.                                                   // 1665\n  _maybeMigrate: function () {                                                                                       // 1666\n    var self = this;                                                                                                 // 1667\n    if (self._retryMigrate && self._readyToMigrate()) {                                                              // 1668\n      self._retryMigrate();                                                                                          // 1669\n      self._retryMigrate = null;                                                                                     // 1670\n    }                                                                                                                // 1671\n  }                                                                                                                  // 1672\n});                                                                                                                  // 1673\n                                                                                                                     // 1674\nLivedataTest.Connection = Connection;                                                                                // 1675\n                                                                                                                     // 1676\n// @param url {String} URL to Meteor app,                                                                            // 1677\n//     e.g.:                                                                                                         // 1678\n//     \"subdomain.meteor.com\",                                                                                       // 1679\n//     \"http://subdomain.meteor.com\",                                                                                // 1680\n//     \"/\",                                                                                                          // 1681\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                // 1682\n                                                                                                                     // 1683\n/**                                                                                                                  // 1684\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere                                                                                                   // 1686\n * @param {String} url The URL of another Meteor application.                                                        // 1687\n */                                                                                                                  // 1688\nDDP.connect = function (url, options) {                                                                              // 1689\n  var ret = new Connection(url, options);                                                                            // 1690\n  allConnections.push(ret); // hack. see below.                                                                      // 1691\n  return ret;                                                                                                        // 1692\n};                                                                                                                   // 1693\n                                                                                                                     // 1694\n// Hack for `spiderable` package: a way to see if the page is done                                                   // 1695\n// loading all the data it needs.                                                                                    // 1696\n//                                                                                                                   // 1697\nallConnections = [];                                                                                                 // 1698\nDDP._allSubscriptionsReady = function () {                                                                           // 1699\n  return _.all(allConnections, function (conn) {                                                                     // 1700\n    return _.all(conn._subscriptions, function (sub) {                                                               // 1701\n      return sub.ready;                                                                                              // 1702\n    });                                                                                                              // 1703\n  });                                                                                                                // 1704\n};                                                                                                                   // 1705\n                                                                                                                     // 1706\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/client_convenience.js                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Meteor.refresh can be called on the client (if you're in common code) but it                                      // 1\n// only has an effect on the server.                                                                                 // 2\nMeteor.refresh = function (notification) {                                                                           // 3\n};                                                                                                                   // 4\n                                                                                                                     // 5\nif (Meteor.isClient) {                                                                                               // 6\n  // By default, try to connect back to the same endpoint as the page                                                // 7\n  // was served from.                                                                                                // 8\n  //                                                                                                                 // 9\n  // XXX We should be doing this a different way. Right now we don't                                                 // 10\n  // include ROOT_URL_PATH_PREFIX when computing ddpUrl. (We don't                                                   // 11\n  // include it on the server when computing                                                                         // 12\n  // DDP_DEFAULT_CONNECTION_URL, and we don't include it in our                                                      // 13\n  // default, '/'.) We get by with this because DDP.connect then                                                     // 14\n  // forces the URL passed to it to be interpreted relative to the                                                   // 15\n  // app's deploy path, even if it is absolute. Instead, we should                                                   // 16\n  // make DDP_DEFAULT_CONNECTION_URL, if set, include the path prefix;                                               // 17\n  // make the default ddpUrl be '' rather that '/'; and make                                                         // 18\n  // _translateUrl in stream_client_common.js not force absolute paths                                               // 19\n  // to be treated like relative paths. See also                                                                     // 20\n  // stream_client_common.js #RationalizingRelativeDDPURLs                                                           // 21\n  var ddpUrl = '/';                                                                                                  // 22\n  if (typeof __meteor_runtime_config__ !== \"undefined\") {                                                            // 23\n    if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)                                                        // 24\n      ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;                                                 // 25\n  }                                                                                                                  // 26\n                                                                                                                     // 27\n  var retry = new Retry();                                                                                           // 28\n                                                                                                                     // 29\n  var onDDPVersionNegotiationFailure = function (description) {                                                      // 30\n    Meteor._debug(description);                                                                                      // 31\n    if (Package.reload) {                                                                                            // 32\n      var migrationData = Package.reload.Reload._migrationData('livedata') || {};                                    // 33\n      var failures = migrationData.DDPVersionNegotiationFailures || 0;                                               // 34\n      ++failures;                                                                                                    // 35\n      Package.reload.Reload._onMigrate('livedata', function () {                                                     // 36\n        return [true, {DDPVersionNegotiationFailures: failures}];                                                    // 37\n      });                                                                                                            // 38\n      retry.retryLater(failures, function () {                                                                       // 39\n        Package.reload.Reload._reload();                                                                             // 40\n      });                                                                                                            // 41\n    }                                                                                                                // 42\n  };                                                                                                                 // 43\n                                                                                                                     // 44\n  Meteor.connection =                                                                                                // 45\n    DDP.connect(ddpUrl, {                                                                                            // 46\n      onDDPVersionNegotiationFailure: onDDPVersionNegotiationFailure                                                 // 47\n    });                                                                                                              // 48\n                                                                                                                     // 49\n  // Proxy the public methods of Meteor.connection so they can                                                       // 50\n  // be called directly on Meteor.                                                                                   // 51\n  _.each(['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect',                                            // 52\n          'disconnect'],                                                                                             // 53\n         function (name) {                                                                                           // 54\n           Meteor[name] = _.bind(Meteor.connection[name], Meteor.connection);                                        // 55\n         });                                                                                                         // 56\n} else {                                                                                                             // 57\n  // Never set up a default connection on the server. Don't even map                                                 // 58\n  // subscribe/call/etc onto Meteor.                                                                                 // 59\n  Meteor.connection = null;                                                                                          // 60\n}                                                                                                                    // 61\n                                                                                                                     // 62\n// Meteor.connection used to be called                                                                               // 63\n// Meteor.default_connection. Provide backcompat as a courtesy even                                                  // 64\n// though it was never documented.                                                                                   // 65\n// XXX COMPAT WITH 0.6.4                                                                                             // 66\nMeteor.default_connection = Meteor.connection;                                                                       // 67\n                                                                                                                     // 68\n// We should transition from Meteor.connect to DDP.connect.                                                          // 69\n// XXX COMPAT WITH 0.6.4                                                                                             // 70\nMeteor.connect = DDP.connect;                                                                                        // 71\n                                                                                                                     // 72\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-client'] = {}, {\n  DDP: DDP,\n  LivedataTest: LivedataTest\n});\n\n})();\n","servePath":"/packages/ddp-client.js"}]