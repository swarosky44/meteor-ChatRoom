[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar IdMap;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////\n//                                                                            //\n// packages/id-map/id-map.js                                                  //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n                                                                              //\nIdMap = function (idStringify, idParse) {\n  var self = this;\n  self._map = {};\n  self._idStringify = idStringify || JSON.stringify;\n  self._idParse = idParse || JSON.parse;\n};\n\n// Some of these methods are designed to match methods on OrderedDict, since\n// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\n// (Conceivably, this should be replaced with \"UnorderedDict\" with a specific\n// set of methods that overlap between the two.)\n\n_.extend(IdMap.prototype, {\n  get: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    return self._map[key];\n  },\n  set: function (id, value) {\n    var self = this;\n    var key = self._idStringify(id);\n    self._map[key] = value;\n  },\n  remove: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    delete self._map[key];\n  },\n  has: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    return _.has(self._map, key);\n  },\n  empty: function () {\n    var self = this;\n    return _.isEmpty(self._map);\n  },\n  clear: function () {\n    var self = this;\n    self._map = {};\n  },\n  // Iterates over the items in the map. Return `false` to break the loop.\n  forEach: function (iterator) {\n    var self = this;\n    // don't use _.each, because we can't break out of it.\n    var keys = _.keys(self._map);\n    for (var i = 0; i < keys.length; i++) {\n      var breakIfFalse = iterator.call(null, self._map[keys[i]],\n                                       self._idParse(keys[i]));\n      if (breakIfFalse === false)\n        return;\n    }\n  },\n  size: function () {\n    var self = this;\n    return _.size(self._map);\n  },\n  setDefault: function (id, def) {\n    var self = this;\n    var key = self._idStringify(id);\n    if (_.has(self._map, key))\n      return self._map[key];\n    self._map[key] = def;\n    return def;\n  },\n  // Assumes that values are EJSON-cloneable, and that we don't need to clone\n  // IDs (ie, that nobody is going to mutate an ObjectId).\n  clone: function () {\n    var self = this;\n    var clone = new IdMap(self._idStringify, self._idParse);\n    self.forEach(function (value, id) {\n      clone.set(id, EJSON.clone(value));\n    });\n    return clone;\n  }\n});\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['id-map'] = {}, {\n  IdMap: IdMap\n});\n\n})();\n","servePath":"/packages/id-map.js"}]