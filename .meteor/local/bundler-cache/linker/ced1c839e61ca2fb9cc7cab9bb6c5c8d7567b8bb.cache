[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar DiffSequence;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                           //\n// packages/diff-sequence/diff.js                                                            //\n//                                                                                           //\n///////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                             //\nDiffSequence = {};                                                                           // 1\n                                                                                             // 2\n// ordered: bool.                                                                            // 3\n// old_results and new_results: collections of documents.                                    // 4\n//    if ordered, they are arrays.                                                           // 5\n//    if unordered, they are IdMaps                                                          // 6\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,                   // 7\n                                              observer, options) {                           // 8\n  if (ordered)                                                                               // 9\n    DiffSequence.diffQueryOrderedChanges(                                                    // 10\n      oldResults, newResults, observer, options);                                            // 11\n  else                                                                                       // 12\n    DiffSequence.diffQueryUnorderedChanges(                                                  // 13\n      oldResults, newResults, observer, options);                                            // 14\n};                                                                                           // 15\n                                                                                             // 16\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,                   // 17\n                                                       observer, options) {                  // 18\n  options = options || {};                                                                   // 19\n  var projectionFn = options.projectionFn || EJSON.clone;                                    // 20\n                                                                                             // 21\n  if (observer.movedBefore) {                                                                // 22\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");              // 23\n  }                                                                                          // 24\n                                                                                             // 25\n  newResults.forEach(function (newDoc, id) {                                                 // 26\n    var oldDoc = oldResults.get(id);                                                         // 27\n    if (oldDoc) {                                                                            // 28\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {                               // 29\n        var projectedNew = projectionFn(newDoc);                                             // 30\n        var projectedOld = projectionFn(oldDoc);                                             // 31\n        var changedFields =                                                                  // 32\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);                    // 33\n        if (! _.isEmpty(changedFields)) {                                                    // 34\n          observer.changed(id, changedFields);                                               // 35\n        }                                                                                    // 36\n      }                                                                                      // 37\n    } else if (observer.added) {                                                             // 38\n      var fields = projectionFn(newDoc);                                                     // 39\n      delete fields._id;                                                                     // 40\n      observer.added(newDoc._id, fields);                                                    // 41\n    }                                                                                        // 42\n  });                                                                                        // 43\n                                                                                             // 44\n  if (observer.removed) {                                                                    // 45\n    oldResults.forEach(function (oldDoc, id) {                                               // 46\n      if (!newResults.has(id))                                                               // 47\n        observer.removed(id);                                                                // 48\n    });                                                                                      // 49\n  }                                                                                          // 50\n};                                                                                           // 51\n                                                                                             // 52\n                                                                                             // 53\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,                   // 54\n                                                     observer, options) {                    // 55\n  options = options || {};                                                                   // 56\n  var projectionFn = options.projectionFn || EJSON.clone;                                    // 57\n                                                                                             // 58\n  var new_presence_of_id = {};                                                               // 59\n  _.each(new_results, function (doc) {                                                       // 60\n    if (new_presence_of_id[doc._id])                                                         // 61\n      Meteor._debug(\"Duplicate _id in new_results\");                                         // 62\n    new_presence_of_id[doc._id] = true;                                                      // 63\n  });                                                                                        // 64\n                                                                                             // 65\n  var old_index_of_id = {};                                                                  // 66\n  _.each(old_results, function (doc, i) {                                                    // 67\n    if (doc._id in old_index_of_id)                                                          // 68\n      Meteor._debug(\"Duplicate _id in old_results\");                                         // 69\n    old_index_of_id[doc._id] = i;                                                            // 70\n  });                                                                                        // 71\n                                                                                             // 72\n  // ALGORITHM:                                                                              // 73\n  //                                                                                         // 74\n  // To determine which docs should be considered \"moved\" (and which                         // 75\n  // merely change position because of other docs moving) we run                             // 76\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the                         // 77\n  // old doc IDs and the new doc IDs gives the docs that should NOT be                       // 78\n  // considered moved.                                                                       // 79\n                                                                                             // 80\n  // To actually call the appropriate callbacks to get from the old state to the             // 81\n  // new state:                                                                              // 82\n                                                                                             // 83\n  // First, we call removed() on all the items that only appear in the old                   // 84\n  // state.                                                                                  // 85\n                                                                                             // 86\n  // Then, once we have the items that should not move, we walk through the new              // 87\n  // results array group-by-group, where a \"group\" is a set of items that have               // 88\n  // moved, anchored on the end by an item that should not move.  One by one, we             // 89\n  // move each of those elements into place \"before\" the anchoring end-of-group              // 90\n  // item, and fire changed events on them if necessary.  Then we fire a changed             // 91\n  // event on the anchor, and move on to the next group.  There is always at                 // 92\n  // least one group; the last group is anchored by a virtual \"null\" id at the               // 93\n  // end.                                                                                    // 94\n                                                                                             // 95\n  // Asymptotically: O(N k) where k is number of ops, or potentially                         // 96\n  // O(N log N) if inner loop of LCS were made to be binary search.                          // 97\n                                                                                             // 98\n                                                                                             // 99\n  //////// LCS (longest common sequence, with respect to _id)                                // 100\n  // (see Wikipedia article on Longest Increasing Subsequence,                               // 101\n  // where the LIS is taken of the sequence of old indices of the                            // 102\n  // docs in new_results)                                                                    // 103\n  //                                                                                         // 104\n  // unmoved: the output of the algorithm; members of the LCS,                               // 105\n  // in the form of indices into new_results                                                 // 106\n  var unmoved = [];                                                                          // 107\n  // max_seq_len: length of LCS found so far                                                 // 108\n  var max_seq_len = 0;                                                                       // 109\n  // seq_ends[i]: the index into new_results of the last doc in a                            // 110\n  // common subsequence of length of i+1 <= max_seq_len                                      // 111\n  var N = new_results.length;                                                                // 112\n  var seq_ends = new Array(N);                                                               // 113\n  // ptrs:  the common subsequence ending with new_results[n] extends                        // 114\n  // a common subsequence ending with new_results[ptr[n]], unless                            // 115\n  // ptr[n] is -1.                                                                           // 116\n  var ptrs = new Array(N);                                                                   // 117\n  // virtual sequence of old indices of new results                                          // 118\n  var old_idx_seq = function(i_new) {                                                        // 119\n    return old_index_of_id[new_results[i_new]._id];                                          // 120\n  };                                                                                         // 121\n  // for each item in new_results, use it to extend a common subsequence                     // 122\n  // of length j <= max_seq_len                                                              // 123\n  for(var i=0; i<N; i++) {                                                                   // 124\n    if (old_index_of_id[new_results[i]._id] !== undefined) {                                 // 125\n      var j = max_seq_len;                                                                   // 126\n      // this inner loop would traditionally be a binary search,                             // 127\n      // but scanning backwards we will likely find a subseq to extend                       // 128\n      // pretty soon, bounded for example by the total number of ops.                        // 129\n      // If this were to be changed to a binary search, we'd still want                      // 130\n      // to scan backwards a bit as an optimization.                                         // 131\n      while (j > 0) {                                                                        // 132\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))                                     // 133\n          break;                                                                             // 134\n        j--;                                                                                 // 135\n      }                                                                                      // 136\n                                                                                             // 137\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);                                              // 138\n      seq_ends[j] = i;                                                                       // 139\n      if (j+1 > max_seq_len)                                                                 // 140\n        max_seq_len = j+1;                                                                   // 141\n    }                                                                                        // 142\n  }                                                                                          // 143\n                                                                                             // 144\n  // pull out the LCS/LIS into unmoved                                                       // 145\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);                              // 146\n  while (idx >= 0) {                                                                         // 147\n    unmoved.push(idx);                                                                       // 148\n    idx = ptrs[idx];                                                                         // 149\n  }                                                                                          // 150\n  // the unmoved item list is built backwards, so fix that                                   // 151\n  unmoved.reverse();                                                                         // 152\n                                                                                             // 153\n  // the last group is always anchored by the end of the result list, which is               // 154\n  // an id of \"null\"                                                                         // 155\n  unmoved.push(new_results.length);                                                          // 156\n                                                                                             // 157\n  _.each(old_results, function (doc) {                                                       // 158\n    if (!new_presence_of_id[doc._id])                                                        // 159\n      observer.removed && observer.removed(doc._id);                                         // 160\n  });                                                                                        // 161\n  // for each group of things in the new_results that is anchored by an unmoved              // 162\n  // element, iterate through the things before it.                                          // 163\n  var startOfGroup = 0;                                                                      // 164\n  _.each(unmoved, function (endOfGroup) {                                                    // 165\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;              // 166\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;                                  // 167\n    for (var i = startOfGroup; i < endOfGroup; i++) {                                        // 168\n      newDoc = new_results[i];                                                               // 169\n      if (!_.has(old_index_of_id, newDoc._id)) {                                             // 170\n        fields = projectionFn(newDoc);                                                       // 171\n        delete fields._id;                                                                   // 172\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);           // 173\n        observer.added && observer.added(newDoc._id, fields);                                // 174\n      } else {                                                                               // 175\n        // moved                                                                             // 176\n        oldDoc = old_results[old_index_of_id[newDoc._id]];                                   // 177\n        projectedNew = projectionFn(newDoc);                                                 // 178\n        projectedOld = projectionFn(oldDoc);                                                 // 179\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);                 // 180\n        if (!_.isEmpty(fields)) {                                                            // 181\n          observer.changed && observer.changed(newDoc._id, fields);                          // 182\n        }                                                                                    // 183\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);                   // 184\n      }                                                                                      // 185\n    }                                                                                        // 186\n    if (groupId) {                                                                           // 187\n      newDoc = new_results[endOfGroup];                                                      // 188\n      oldDoc = old_results[old_index_of_id[newDoc._id]];                                     // 189\n      projectedNew = projectionFn(newDoc);                                                   // 190\n      projectedOld = projectionFn(oldDoc);                                                   // 191\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);                   // 192\n      if (!_.isEmpty(fields)) {                                                              // 193\n        observer.changed && observer.changed(newDoc._id, fields);                            // 194\n      }                                                                                      // 195\n    }                                                                                        // 196\n    startOfGroup = endOfGroup+1;                                                             // 197\n  });                                                                                        // 198\n                                                                                             // 199\n                                                                                             // 200\n};                                                                                           // 201\n                                                                                             // 202\n                                                                                             // 203\n// General helper for diff-ing two objects.                                                  // 204\n// callbacks is an object like so:                                                           // 205\n// { leftOnly: function (key, leftValue) {...},                                              // 206\n//   rightOnly: function (key, rightValue) {...},                                            // 207\n//   both: function (key, leftValue, rightValue) {...},                                      // 208\n// }                                                                                         // 209\nDiffSequence.diffObjects = function (left, right, callbacks) {                               // 210\n  _.each(left, function (leftValue, key) {                                                   // 211\n    if (_.has(right, key))                                                                   // 212\n      callbacks.both && callbacks.both(key, leftValue, right[key]);                          // 213\n    else                                                                                     // 214\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);                              // 215\n  });                                                                                        // 216\n  if (callbacks.rightOnly) {                                                                 // 217\n    _.each(right, function(rightValue, key) {                                                // 218\n      if (!_.has(left, key))                                                                 // 219\n        callbacks.rightOnly(key, rightValue);                                                // 220\n    });                                                                                      // 221\n  }                                                                                          // 222\n};                                                                                           // 223\n                                                                                             // 224\n                                                                                             // 225\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {                                 // 226\n  var fields = {};                                                                           // 227\n  DiffSequence.diffObjects(oldDoc, newDoc, {                                                 // 228\n    leftOnly: function (key, value) {                                                        // 229\n      fields[key] = undefined;                                                               // 230\n    },                                                                                       // 231\n    rightOnly: function (key, value) {                                                       // 232\n      fields[key] = value;                                                                   // 233\n    },                                                                                       // 234\n    both: function (key, leftValue, rightValue) {                                            // 235\n      if (!EJSON.equals(leftValue, rightValue))                                              // 236\n        fields[key] = rightValue;                                                            // 237\n    }                                                                                        // 238\n  });                                                                                        // 239\n  return fields;                                                                             // 240\n};                                                                                           // 241\n                                                                                             // 242\nDiffSequence.applyChanges = function (doc, changeFields) {                                   // 243\n  _.each(changeFields, function (value, key) {                                               // 244\n    if (value === undefined)                                                                 // 245\n      delete doc[key];                                                                       // 246\n    else                                                                                     // 247\n      doc[key] = value;                                                                      // 248\n  });                                                                                        // 249\n};                                                                                           // 250\n                                                                                             // 251\n                                                                                             // 252\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['diff-sequence'] = {}, {\n  DiffSequence: DiffSequence\n});\n\n})();\n","servePath":"/packages/diff-sequence.js"}]