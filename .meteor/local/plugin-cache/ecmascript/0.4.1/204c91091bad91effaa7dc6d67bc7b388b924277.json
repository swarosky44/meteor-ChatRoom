{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/oplog_tests.js","filenameRelative":"/packages/mongo/oplog_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/oplog_tests.js.map","sourceFileName":"/packages/mongo/oplog_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"oplog_tests"},"ignored":false,"code":"var OplogCollection = new Mongo.Collection(\"oplog-\" + Random.id());\n\nTinytest.add(\"mongo-livedata - oplog - cursorSupported\", function (test) {\n  var oplogEnabled = !!MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle;\n\n  var supported = function supported(expected, selector, options) {\n    var cursor = OplogCollection.find(selector, options);\n    var handle = cursor.observeChanges({ added: function () {\n        function added() {}\n\n        return added;\n      }() });\n    // If there's no oplog at all, we shouldn't ever use it.\n    if (!oplogEnabled) expected = false;\n    test.equal(!!handle._multiplexer._observeDriver._usesOplog, expected);\n    handle.stop();\n  };\n\n  supported(true, \"asdf\");\n  supported(true, 1234);\n  supported(true, new Mongo.ObjectID());\n\n  supported(true, { _id: \"asdf\" });\n  supported(true, { _id: 1234 });\n  supported(true, { _id: new Mongo.ObjectID() });\n\n  supported(true, { foo: \"asdf\",\n    bar: 1234,\n    baz: new Mongo.ObjectID(),\n    eeney: true,\n    miney: false,\n    moe: null });\n\n  supported(true, {});\n\n  supported(true, { $and: [{ foo: \"asdf\" }, { bar: \"baz\" }] });\n  supported(true, { foo: { x: 1 } });\n  supported(true, { foo: { $gt: 1 } });\n  supported(true, { foo: [1, 2, 3] });\n\n  // No $where.\n  supported(false, { $where: \"xxx\" });\n  supported(false, { $and: [{ foo: \"adsf\" }, { $where: \"xxx\" }] });\n  // No geoqueries.\n  supported(false, { x: { $near: [1, 1] } });\n  // Nothing Minimongo doesn't understand.  (Minimongo happens to fail to\n  // implement $elemMatch inside $all which MongoDB supports.)\n  supported(false, { x: { $all: [{ $elemMatch: { y: 2 } }] } });\n\n  supported(true, {}, { sort: { x: 1 } });\n  supported(true, {}, { sort: { x: 1 }, limit: 5 });\n  supported(false, {}, { sort: { $natural: 1 }, limit: 5 });\n  supported(false, {}, { limit: 5 });\n  supported(false, {}, { skip: 2, limit: 5 });\n  supported(false, {}, { skip: 2 });\n});\n\nprocess.env.MONGO_OPLOG_URL && testAsyncMulti(\"mongo-livedata - oplog - entry skipping\", [function (test, expect) {\n  var self = this;\n  self.collectionName = Random.id();\n  self.collection = new Mongo.Collection(self.collectionName);\n  self.collection._ensureIndex({ species: 1 });\n\n  // Fill collection with lots of irrelevant objects (red cats) and some\n  // relevant ones (blue dogs).\n  self.IRRELEVANT_SIZE = 15000;\n  self.RELEVANT_SIZE = 10;\n  var docs = [];\n  var i;\n  for (i = 0; i < self.IRRELEVANT_SIZE; ++i) {\n    docs.push({\n      name: \"cat \" + i,\n      species: 'cat',\n      color: 'red'\n    });\n  }\n  for (i = 0; i < self.RELEVANT_SIZE; ++i) {\n    docs.push({\n      name: \"dog \" + i,\n      species: 'dog',\n      color: 'blue'\n    });\n  }\n  // XXX implement bulk insert #1255\n  var rawCollection = self.collection.rawCollection();\n  rawCollection.insert(docs, Meteor.bindEnvironment(expect(function (err) {\n    test.isFalse(err);\n  })));\n}, function (test, expect) {\n  var self = this;\n\n  test.equal(self.collection.find().count(), self.IRRELEVANT_SIZE + self.RELEVANT_SIZE);\n\n  var blueDog5Id = null;\n  var gotSpot = false;\n\n  // Watch for blue dogs.\n  self.subHandle = self.collection.find({ species: 'dog', color: 'blue' }).observeChanges({\n    added: function () {\n      function added(id, fields) {\n        if (fields.name === 'dog 5') blueDog5Id = id;\n      }\n\n      return added;\n    }(),\n    changed: function () {\n      function changed(id, fields) {\n        if (EJSON.equals(id, blueDog5Id) && fields.name === 'spot') gotSpot = true;\n      }\n\n      return changed;\n    }()\n  });\n  test.isTrue(self.subHandle._multiplexer._observeDriver._usesOplog);\n  test.isTrue(blueDog5Id);\n  test.isFalse(gotSpot);\n\n  self.skipped = false;\n  self.skipHandle = MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle.onSkippedEntries(function () {\n    self.skipped = true;\n  });\n\n  // Dye all the cats blue. This adds lots of oplog mentries that look like\n  // they might in theory be relevant (since they say \"something you didn't\n  // know about is now blue\", and who knows, maybe it's a dog) which puts\n  // the OplogObserveDriver into FETCHING mode, which performs poorly.\n  self.collection.update({ species: 'cat' }, { $set: { color: 'blue' } }, { multi: true });\n  self.collection.update(blueDog5Id, { $set: { name: 'spot' } });\n\n  // We ought to see the spot change soon!  It's important to keep this\n  // timeout relatively small (ie, small enough that if we set\n  // $METEOR_OPLOG_TOO_FAR_BEHIND to something enormous, say 200000, that\n  // the test fails).\n  pollUntil(expect, function () {\n    return gotSpot;\n  }, 2000);\n}, function (test, expect) {\n  var self = this;\n  test.isTrue(self.skipped);\n\n  self.skipHandle.stop();\n  self.subHandle.stop();\n  self.collection.remove({});\n}]);","ast":null,"map":{"version":3,"sources":["/packages/mongo/oplog_tests.js"],"names":[],"mappings":"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","file":"/packages/mongo/oplog_tests.js.map","sourcesContent":["var OplogCollection = new Mongo.Collection(\"oplog-\" + Random.id());\n\nTinytest.add(\"mongo-livedata - oplog - cursorSupported\", function (test) {\n  var oplogEnabled =\n        !!MongoInternals.defaultRemoteCollectionDriver().mongo._oplogHandle;\n\n  var supported = function (expected, selector, options) {\n    var cursor = OplogCollection.find(selector, options);\n    var handle = cursor.observeChanges({added: function () {}});\n    // If there's no oplog at all, we shouldn't ever use it.\n    if (!oplogEnabled)\n      expected = false;\n    test.equal(!!handle._multiplexer._observeDriver._usesOplog, expected);\n    handle.stop();\n  };\n\n  supported(true, \"asdf\");\n  supported(true, 1234);\n  supported(true, new Mongo.ObjectID());\n\n  supported(true, {_id: \"asdf\"});\n  supported(true, {_id: 1234});\n  supported(true, {_id: new Mongo.ObjectID()});\n\n  supported(true, {foo: \"asdf\",\n                   bar: 1234,\n                   baz: new Mongo.ObjectID(),\n                   eeney: true,\n                   miney: false,\n                   moe: null});\n\n  supported(true, {});\n\n  supported(true, {$and: [{foo: \"asdf\"}, {bar: \"baz\"}]});\n  supported(true, {foo: {x: 1}});\n  supported(true, {foo: {$gt: 1}});\n  supported(true, {foo: [1, 2, 3]});\n\n  // No $where.\n  supported(false, {$where: \"xxx\"});\n  supported(false, {$and: [{foo: \"adsf\"}, {$where: \"xxx\"}]});\n  // No geoqueries.\n  supported(false, {x: {$near: [1,1]}});\n  // Nothing Minimongo doesn't understand.  (Minimongo happens to fail to\n  // implement $elemMatch inside $all which MongoDB supports.)\n  supported(false, {x: {$all: [{$elemMatch: {y: 2}}]}});\n\n  supported(true, {}, { sort: {x:1} });\n  supported(true, {}, { sort: {x:1}, limit: 5 });\n  supported(false, {}, { sort: {$natural:1}, limit: 5 });\n  supported(false, {}, { limit: 5 });\n  supported(false, {}, { skip: 2, limit: 5 });\n  supported(false, {}, { skip: 2 });\n});\n\nprocess.env.MONGO_OPLOG_URL && testAsyncMulti(\n  \"mongo-livedata - oplog - entry skipping\", [\n    function (test, expect) {\n      var self = this;\n      self.collectionName = Random.id();\n      self.collection = new Mongo.Collection(self.collectionName);\n      self.collection._ensureIndex({species: 1});\n\n      // Fill collection with lots of irrelevant objects (red cats) and some\n      // relevant ones (blue dogs).\n      self.IRRELEVANT_SIZE = 15000;\n      self.RELEVANT_SIZE = 10;\n      var docs = [];\n      var i;\n      for (i = 0; i < self.IRRELEVANT_SIZE; ++i) {\n        docs.push({\n          name: \"cat \" + i,\n          species: 'cat',\n          color: 'red'\n        });\n      }\n      for (i = 0; i < self.RELEVANT_SIZE; ++i) {\n        docs.push({\n          name: \"dog \" + i,\n          species: 'dog',\n          color: 'blue'\n        });\n      }\n      // XXX implement bulk insert #1255\n      var rawCollection = self.collection.rawCollection();\n      rawCollection.insert(docs, Meteor.bindEnvironment(expect(function (err) {\n        test.isFalse(err);\n      })));\n    },\n    function (test, expect) {\n      var self = this;\n\n      test.equal(self.collection.find().count(),\n                 self.IRRELEVANT_SIZE + self.RELEVANT_SIZE);\n\n      var blueDog5Id = null;\n      var gotSpot = false;\n\n      // Watch for blue dogs.\n      self.subHandle =\n        self.collection.find({species: 'dog', color: 'blue'}).observeChanges({\n          added: function (id, fields) {\n            if (fields.name === 'dog 5')\n              blueDog5Id = id;\n          },\n          changed: function (id, fields) {\n            if (EJSON.equals(id, blueDog5Id) && fields.name === 'spot')\n              gotSpot = true;\n          }\n        });\n      test.isTrue(self.subHandle._multiplexer._observeDriver._usesOplog);\n      test.isTrue(blueDog5Id);\n      test.isFalse(gotSpot);\n\n      self.skipped = false;\n      self.skipHandle =\n        MongoInternals.defaultRemoteCollectionDriver().mongo\n        ._oplogHandle.onSkippedEntries(function () {\n          self.skipped = true;\n        });\n\n      // Dye all the cats blue. This adds lots of oplog mentries that look like\n      // they might in theory be relevant (since they say \"something you didn't\n      // know about is now blue\", and who knows, maybe it's a dog) which puts\n      // the OplogObserveDriver into FETCHING mode, which performs poorly.\n      self.collection.update({species: 'cat'},\n                             {$set: {color: 'blue'}},\n                             {multi: true});\n      self.collection.update(blueDog5Id, {$set: {name: 'spot'}});\n\n      // We ought to see the spot change soon!  It's important to keep this\n      // timeout relatively small (ie, small enough that if we set\n      // $METEOR_OPLOG_TOO_FAR_BEHIND to something enormous, say 200000, that\n      // the test fails).\n      pollUntil(expect, function () {\n        return gotSpot;\n      }, 2000);\n    },\n    function (test, expect) {\n      var self = this;\n      test.isTrue(self.skipped);\n\n      self.skipHandle.stop();\n      self.subHandle.stop();\n      self.collection.remove({});\n    }\n  ]\n);\n"]},"hash":"204c91091bad91effaa7dc6d67bc7b388b924277"}
