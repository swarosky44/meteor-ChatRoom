{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/accounts-password/password_tests_setup.js","filenameRelative":"/packages/accounts-password/password_tests_setup.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-password/password_tests_setup.js.map","sourceFileName":"/packages/accounts-password/password_tests_setup.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"password_tests_setup"},"ignored":false,"code":"Accounts.validateNewUser(function (user) {\n  if (user.profile && user.profile.invalidAndThrowException) throw new Meteor.Error(403, \"An exception thrown within Accounts.validateNewUser\");\n  return !(user.profile && user.profile.invalid);\n});\n\nAccounts.onCreateUser(function (options, user) {\n  if (options.testOnCreateUserHook) {\n    user.profile = user.profile || {};\n    user.profile.touchedByOnCreateUser = true;\n    return user;\n  } else {\n    return 'TEST DEFAULT HOOK';\n  }\n});\n\n// connection id -> action\nvar invalidateLogins = {};\n\nMeteor.methods({\n  testInvalidateLogins: function () {\n    function testInvalidateLogins(action) {\n      if (action) invalidateLogins[this.connection.id] = action;else delete invalidateLogins[this.connection.id];\n    }\n\n    return testInvalidateLogins;\n  }()\n});\n\nAccounts.validateLoginAttempt(function (attempt) {\n  var action = attempt && attempt.connection && invalidateLogins[attempt.connection.id];\n\n  if (!action) return true;else if (action === 'fail') return false;else if (action === 'hide') throw new Meteor.Error(403, 'hide actual error');else throw new Error('unknown action: ' + action);\n});\n\n// connection id -> [{successful: boolean, attempt: object}]\nvar capturedLogins = {};\n\nMeteor.methods({\n  testCaptureLogins: function () {\n    function testCaptureLogins() {\n      capturedLogins[this.connection.id] = [];\n    }\n\n    return testCaptureLogins;\n  }(),\n\n  testFetchCapturedLogins: function () {\n    function testFetchCapturedLogins() {\n      if (capturedLogins[this.connection.id]) {\n        var logins = capturedLogins[this.connection.id];\n        delete capturedLogins[this.connection.id];\n        return logins;\n      } else return [];\n    }\n\n    return testFetchCapturedLogins;\n  }()\n});\n\nAccounts.onLogin(function (attempt) {\n  if (!attempt.connection) // if login method called from the server\n    return;\n\n  if (capturedLogins[attempt.connection.id]) capturedLogins[attempt.connection.id].push({\n    successful: true,\n    attempt: _.omit(attempt, 'connection')\n  });\n});\n\nAccounts.onLoginFailure(function (attempt) {\n  if (!attempt.connection) // if login method called from the server\n    return;\n\n  if (capturedLogins[attempt.connection.id]) {\n    capturedLogins[attempt.connection.id].push({\n      successful: false,\n      attempt: _.omit(attempt, 'connection')\n    });\n  }\n});\n\n// Because this is global state that affects every client, we can't turn\n// it on and off during the tests. Doing so would mean two simultaneous\n// test runs could collide with each other.\n//\n// We should probably have some sort of server-isolation between\n// multiple test runs. Perhaps a separate server instance per run. This\n// problem isn't unique to this test, there are other places in the code\n// where we do various hacky things to work around the lack of\n// server-side isolation.\n//\n// For now, we just test the one configuration state. You can comment\n// out each configuration option and see that the tests fail.\nAccounts.config({\n  sendVerificationEmail: true\n});\n\nMeteor.methods({\n  testMeteorUser: function () {\n    function testMeteorUser() {\n      return Meteor.user();\n    }\n\n    return testMeteorUser;\n  }(),\n  clearUsernameAndProfile: function () {\n    function clearUsernameAndProfile() {\n      if (!this.userId) throw new Error(\"Not logged in!\");\n      Meteor.users.update(this.userId, { $unset: { profile: 1, username: 1 } });\n    }\n\n    return clearUsernameAndProfile;\n  }(),\n\n  expireTokens: function () {\n    function expireTokens() {\n      Accounts._expireTokens(new Date(), this.userId);\n    }\n\n    return expireTokens;\n  }(),\n  removeUser: function () {\n    function removeUser(username) {\n      Meteor.users.remove({ \"username\": username });\n    }\n\n    return removeUser;\n  }()\n});\n\n// Create a user that had previously logged in with SRP.\n\nMeteor.methods({\n  testCreateSRPUser: function () {\n    function testCreateSRPUser() {\n      var username = Random.id();\n      Meteor.users.remove({ username: username });\n      var userId = Accounts.createUser({ username: username });\n      Meteor.users.update(userId, { '$set': { 'services.password.srp': {\n            \"identity\": \"iPNrshUEcpOSO5fRDu7o4RRDc9OJBCGGljYpcXCuyg9\",\n            \"salt\": \"Dk3lFggdEtcHU3aKm6Odx7sdcaIrMskQxBbqtBtFzt6\",\n            \"verifier\": \"2e8bce266b1357edf6952cc56d979db19f699ced97edfb2854b95972f820b0c7006c1a18e98aad40edf3fe111b87c52ef7dd06b320ce452d01376df2d560fdc4d8e74f7a97bca1f67b3cfaef34dee34dd6c76571c247d762624dc166dab5499da06bc9358528efa75bf74e2e7f5a80d09e60acf8856069ae5cfb080f2239ee76\"\n          } } });\n      return username;\n    }\n\n    return testCreateSRPUser;\n  }(),\n\n  testSRPUpgrade: function () {\n    function testSRPUpgrade(username) {\n      var user = Meteor.users.findOne({ username: username });\n      if (user.services && user.services.password && user.services.password.srp) throw new Error(\"srp wasn't removed\");\n      if (!(user.services && user.services.password && user.services.password.bcrypt)) throw new Error(\"bcrypt wasn't added\");\n    }\n\n    return testSRPUpgrade;\n  }(),\n\n  testNoSRPUpgrade: function () {\n    function testNoSRPUpgrade(username) {\n      var user = Meteor.users.findOne({ username: username });\n      if (user.services && user.services.password && user.services.password.bcrypt) throw new Error(\"bcrypt was added\");\n      if (user.services && user.services.password && !user.services.password.srp) throw new Error(\"srp was removed\");\n    }\n\n    return testNoSRPUpgrade;\n  }()\n});","ast":null,"map":{"version":3,"sources":["/packages/accounts-password/password_tests_setup.js"],"names":[],"mappings":"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","file":"/packages/accounts-password/password_tests_setup.js.map","sourcesContent":["Accounts.validateNewUser(function (user) {\n  if (user.profile && user.profile.invalidAndThrowException)\n    throw new Meteor.Error(403, \"An exception thrown within Accounts.validateNewUser\");\n  return !(user.profile && user.profile.invalid);\n});\n\nAccounts.onCreateUser(function (options, user) {\n  if (options.testOnCreateUserHook) {\n    user.profile = user.profile || {};\n    user.profile.touchedByOnCreateUser = true;\n    return user;\n  } else {\n    return 'TEST DEFAULT HOOK';\n  }\n});\n\n\n// connection id -> action\nvar invalidateLogins = {};\n\n\nMeteor.methods({\n  testInvalidateLogins: function (action) {\n    if (action)\n      invalidateLogins[this.connection.id] = action;\n    else\n      delete invalidateLogins[this.connection.id];\n  }\n});\n\n\nAccounts.validateLoginAttempt(function (attempt) {\n  var action =\n    attempt &&\n    attempt.connection &&\n    invalidateLogins[attempt.connection.id];\n\n  if (! action)\n    return true;\n  else if (action === 'fail')\n    return false;\n  else if (action === 'hide')\n    throw new Meteor.Error(403, 'hide actual error');\n  else\n    throw new Error('unknown action: ' + action);\n});\n\n\n// connection id -> [{successful: boolean, attempt: object}]\nvar capturedLogins = {};\n\nMeteor.methods({\n  testCaptureLogins: function () {\n    capturedLogins[this.connection.id] = [];\n  },\n\n  testFetchCapturedLogins: function () {\n    if (capturedLogins[this.connection.id]) {\n      var logins = capturedLogins[this.connection.id];\n      delete capturedLogins[this.connection.id];\n      return logins;\n    }\n    else\n      return [];\n  }\n});\n\nAccounts.onLogin(function (attempt) {\n  if (!attempt.connection) // if login method called from the server\n    return;\n\n  if (capturedLogins[attempt.connection.id])\n    capturedLogins[attempt.connection.id].push({\n      successful: true,\n      attempt: _.omit(attempt, 'connection')\n    });\n});\n\nAccounts.onLoginFailure(function (attempt) {\n  if (!attempt.connection) // if login method called from the server\n    return;\n\n  if (capturedLogins[attempt.connection.id]) {\n    capturedLogins[attempt.connection.id].push({\n      successful: false,\n      attempt: _.omit(attempt, 'connection')\n    });\n  }\n});\n\n// Because this is global state that affects every client, we can't turn\n// it on and off during the tests. Doing so would mean two simultaneous\n// test runs could collide with each other.\n//\n// We should probably have some sort of server-isolation between\n// multiple test runs. Perhaps a separate server instance per run. This\n// problem isn't unique to this test, there are other places in the code\n// where we do various hacky things to work around the lack of\n// server-side isolation.\n//\n// For now, we just test the one configuration state. You can comment\n// out each configuration option and see that the tests fail.\nAccounts.config({\n  sendVerificationEmail: true\n});\n\n\nMeteor.methods({\n  testMeteorUser: function () { return Meteor.user(); },\n  clearUsernameAndProfile: function () {\n    if (!this.userId)\n      throw new Error(\"Not logged in!\");\n    Meteor.users.update(this.userId,\n                        {$unset: {profile: 1, username: 1}});\n  },\n\n  expireTokens: function () {\n    Accounts._expireTokens(new Date(), this.userId);\n  },\n  removeUser: function (username) {\n    Meteor.users.remove({ \"username\": username });\n  }\n});\n\n\n// Create a user that had previously logged in with SRP.\n\nMeteor.methods({\n  testCreateSRPUser: function () {\n    var username = Random.id();\n    Meteor.users.remove({username: username});\n    var userId = Accounts.createUser({username: username});\n    Meteor.users.update(\n      userId,\n      { '$set': { 'services.password.srp': {\n          \"identity\" : \"iPNrshUEcpOSO5fRDu7o4RRDc9OJBCGGljYpcXCuyg9\",\n          \"salt\" : \"Dk3lFggdEtcHU3aKm6Odx7sdcaIrMskQxBbqtBtFzt6\",\n          \"verifier\" : \"2e8bce266b1357edf6952cc56d979db19f699ced97edfb2854b95972f820b0c7006c1a18e98aad40edf3fe111b87c52ef7dd06b320ce452d01376df2d560fdc4d8e74f7a97bca1f67b3cfaef34dee34dd6c76571c247d762624dc166dab5499da06bc9358528efa75bf74e2e7f5a80d09e60acf8856069ae5cfb080f2239ee76\"\n      } } }\n    );\n    return username;\n  },\n\n  testSRPUpgrade: function (username) {\n    var user = Meteor.users.findOne({username: username});\n    if (user.services && user.services.password && user.services.password.srp)\n      throw new Error(\"srp wasn't removed\");\n    if (!(user.services && user.services.password && user.services.password.bcrypt))\n      throw new Error(\"bcrypt wasn't added\");\n  },\n\n  testNoSRPUpgrade: function (username) {\n    var user = Meteor.users.findOne({username: username});\n    if (user.services && user.services.password && user.services.password.bcrypt)\n      throw new Error(\"bcrypt was added\");\n    if (user.services && user.services.password && ! user.services.password.srp)\n      throw new Error(\"srp was removed\");\n  }\n});\n"]},"hash":"25f59978568040cbb66637c6b579aacdeddec131"}
