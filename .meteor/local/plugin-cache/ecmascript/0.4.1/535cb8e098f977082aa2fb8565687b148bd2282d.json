{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/crossbar.js","filenameRelative":"/packages/ddp-server/crossbar.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/crossbar.js.map","sourceFileName":"/packages/ddp-server/crossbar.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"crossbar"},"ignored":false,"code":"// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function () {\n    function _collectionForMessage(msg) {\n      var self = this;\n      if (!_.has(msg, 'collection')) {\n        return '';\n      } else if (typeof msg.collection === 'string') {\n        if (msg.collection === '') throw Error(\"Message has empty collection!\");\n        return msg.collection;\n      } else {\n        throw Error(\"Message has non-string collection!\");\n      }\n    }\n\n    return _collectionForMessage;\n  }(),\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function () {\n    function listen(trigger, callback) {\n      var self = this;\n      var id = self.nextId++;\n\n      var collection = self._collectionForMessage(trigger);\n      var record = { trigger: EJSON.clone(trigger), callback: callback };\n      if (!_.has(self.listenersByCollection, collection)) {\n        self.listenersByCollection[collection] = {};\n      }\n      self.listenersByCollection[collection][id] = record;\n\n      if (self.factName && Package.facts) {\n        Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, 1);\n      }\n\n      return {\n        stop: function () {\n          function stop() {\n            if (self.factName && Package.facts) {\n              Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, -1);\n            }\n            delete self.listenersByCollection[collection][id];\n            if (_.isEmpty(self.listenersByCollection[collection])) {\n              delete self.listenersByCollection[collection];\n            }\n          }\n\n          return stop;\n        }()\n      };\n    }\n\n    return listen;\n  }(),\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: function () {\n    function fire(notification) {\n      var self = this;\n\n      var collection = self._collectionForMessage(notification);\n\n      if (!_.has(self.listenersByCollection, collection)) {\n        return;\n      }\n\n      var listenersForCollection = self.listenersByCollection[collection];\n      var callbackIds = [];\n      _.each(listenersForCollection, function (l, id) {\n        if (self._matches(notification, l.trigger)) {\n          callbackIds.push(id);\n        }\n      });\n\n      // Listener callbacks can yield, so we need to first find all the ones that\n      // match in a single iteration over self.listenersByCollection (which can't\n      // be mutated during this iteration), and then invoke the matching\n      // callbacks, checking before each call to ensure they haven't stopped.\n      // Note that we don't have to check that\n      // self.listenersByCollection[collection] still === listenersForCollection,\n      // because the only way that stops being true is if listenersForCollection\n      // first gets reduced down to the empty object (and then never gets\n      // increased again).\n      _.each(callbackIds, function (id) {\n        if (_.has(listenersForCollection, id)) {\n          listenersForCollection[id].callback(notification);\n        }\n      });\n    }\n\n    return fire;\n  }(),\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function () {\n    function _matches(notification, trigger) {\n      // Most notifications that use the crossbar have a string `collection` and\n      // maybe an `id` that is a string or ObjectID. We're already dividing up\n      // triggers by collection, but let's fast-track \"nope, different ID\" (and\n      // avoid the overly generic EJSON.equals). This makes a noticeable\n      // performance difference; see https://github.com/meteor/meteor/pull/3697\n      if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {\n        return false;\n      }\n      if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n        return false;\n      }\n\n      return _.all(trigger, function (triggerValue, key) {\n        return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]);\n      });\n    }\n\n    return _matches;\n  }()\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/crossbar.js"],"names":[],"mappings":"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","file":"/packages/ddp-server/crossbar.js.map","sourcesContent":["// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (! _.has(msg, 'collection')) {\n      return '';\n    } else if (typeof(msg.collection) === 'string') {\n      if (msg.collection === '')\n        throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\n    if (! _.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n    }\n    self.listenersByCollection[collection][id] = record;\n\n    if (self.factName && Package.facts) {\n      Package.facts.Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package.facts) {\n          Package.facts.Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        if (_.isEmpty(self.listenersByCollection[collection])) {\n          delete self.listenersByCollection[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (! _.has(self.listenersByCollection, collection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    _.each(callbackIds, function (id) {\n      if (_.has(listenersForCollection, id)) {\n        listenersForCollection[id].callback(notification);\n      }\n    });\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof(notification.id) === 'string' &&\n        typeof(trigger.id) === 'string' &&\n        notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID &&\n        trigger.id instanceof MongoID.ObjectID &&\n        ! notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) ||\n        EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});\n"]},"hash":"535cb8e098f977082aa2fb8565687b148bd2282d"}
