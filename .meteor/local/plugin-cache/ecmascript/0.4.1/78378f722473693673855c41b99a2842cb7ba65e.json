{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/accounts-base/accounts_tests.js","filenameRelative":"/packages/accounts-base/accounts_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/accounts_tests.js.map","sourceFileName":"/packages/accounts-base/accounts_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"accounts_tests"},"ignored":false,"code":"var _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nMeteor.methods({\n  getCurrentLoginToken: function () {\n    function getCurrentLoginToken() {\n      return Accounts._getLoginToken(this.connection.id);\n    }\n\n    return getCurrentLoginToken;\n  }()\n});\n\n// XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({ foo: \"bar\" });\n  });\n});\n\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\n\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', { id: Random.id() }).userId;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id();\n\n  // create an account with facebook\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('facebook', { id: facebookId, monkey: 42 }, { profile: { foo: 1 } }).id;\n  var users = Meteor.users.find({ \"services.facebook.id\": facebookId }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('facebook', { id: facebookId, llama: 50 }, { profile: { foo: 1000, bar: 2 } }).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({ \"services.facebook.id\": facebookId }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50);\n  // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id();\n\n  // users that have different service ids get different users\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('weibo', { id: weiboId1 }, { profile: { foo: 1 } }).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('weibo', { id: weiboId2 }, { profile: { bar: 2 } }).id;\n  test.equal(Meteor.users.find({ \"services.weibo.id\": { $in: [weiboId1, weiboId2] } }).count(), 2);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId1 }).profile.foo, 1);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId1 }).emails, undefined);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId2 }).profile.bar, 2);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId2 }).emails, undefined);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = '' + twitterIdOld;\n\n  // create an account with twitter using the old ID format of integer\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('twitter', { id: twitterIdOld, monkey: 42 }, { profile: { foo: 1 } }).id;\n  var users = Meteor.users.find({ \"services.twitter.id\": twitterIdOld }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42);\n\n  // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('twitter', { id: twitterIdNew, monkey: 42 }, { profile: { foo: 1 } }).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({ \"services.twitter.id\": twitterIdNew }).fetch();\n  test.length(users, 1);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal((0, _typeof3['default'])(userOut.createdAt), 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username);\n\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  }, 'Username already exists.');\n\n  // cleanup\n  Meteor.users.remove(userId);\n});\n\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{ address: email1, verified: false }, { address: email2, verified: true }]\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal((0, _typeof3['default'])(userOut.createdAt), 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails);\n\n  // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  }, 'Email already exists.');\n\n  // now with only one of them.\n  test.throws(function () {\n    Accounts.insertUserDoc({}, { emails: [{ address: email1 }] });\n  }, 'Email already exists.');\n\n  test.throws(function () {\n    Accounts.insertUserDoc({}, { emails: [{ address: email2 }] });\n  }, 'Email already exists.');\n\n  // a third email works.\n  var userId3 = Accounts.insertUserDoc({}, { emails: [{ address: email3 }] });\n  var user3 = Meteor.users.findOne(userId3);\n  test.equal((0, _typeof3['default'])(user3.createdAt), 'object');\n\n  // cleanup\n  Meteor.users.remove(userId);\n  Meteor.users.remove(userId3);\n});\n\n// More token expiration tests are in accounts-password\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = { username: Random.id() };\n  var userId = Accounts.insertUserDoc({ profile: {\n      name: 'Foo Bar'\n    } }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        hashedToken: Random.id(),\n        when: date\n      }, {\n        hashedToken: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(userId).observe({\n    changed: function () {\n      function changed(newUser) {\n        if (newUser.services && newUser.services.resume && _.isEmpty(newUser.services.resume.loginTokens)) {\n          observe.stop();\n          onComplete();\n        }\n      }\n\n      return changed;\n    }()\n  });\n  Accounts._expireTokens(new Date(), userId);\n});\n\n// Login tokens used to be stored unhashed in the database.  We want\n// to make sure users can still login after upgrading.\nvar insertUnhashedLoginToken = function insertUnhashedLoginToken(userId, stampedToken) {\n  Meteor.users.update(userId, { $push: { 'services.resume.loginTokens': stampedToken } });\n};\n\nTinytest.addAsync('accounts - login token', function (test, onComplete) {\n  // Test that we can login when the database contains a leftover\n  // old style unhashed login token.\n  var userId1 = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId1, stampedToken);\n  var connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stampedToken.token });\n  connection.disconnect();\n\n  // Steal the unhashed token from the database and use it to login.\n  // This is a sanity check so that when we *can't* login with a\n  // stolen *hashed* token, we know it's not a problem with the test.\n  var userId2 = Accounts.insertUserDoc({}, { username: Random.id() });\n  insertUnhashedLoginToken(userId2, Accounts._generateStampedLoginToken());\n  var stolenToken = Meteor.users.findOne(userId2).services.resume.loginTokens[0].token;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stolenToken });\n  connection.disconnect();\n\n  // Now do the same thing, this time with a stolen hashed token.\n  var userId3 = Accounts.insertUserDoc({}, { username: Random.id() });\n  Accounts._insertLoginToken(userId3, Accounts._generateStampedLoginToken());\n  stolenToken = Meteor.users.findOne(userId3).services.resume.loginTokens[0].hashedToken;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  // evil plan foiled\n  test.throws(function () {\n    connection.call('login', { resume: stolenToken });\n  }, /You\\'ve been logged out by the server/);\n  connection.disconnect();\n\n  // Old style unhashed tokens are replaced by hashed tokens when\n  // encountered.  This means that after someone logins once, the\n  // old unhashed token is no longer available to be stolen.\n  var userId4 = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId4, stampedToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stampedToken.token });\n  connection.disconnect();\n\n  // The token is no longer available to be stolen.\n  stolenToken = Meteor.users.findOne(userId4).services.resume.loginTokens[0].token;\n  test.isFalse(stolenToken);\n\n  // After the upgrade, the client can still login with their original\n  // unhashed login token.\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stampedToken.token });\n  connection.disconnect();\n\n  onComplete();\n});\n\nTinytest.addAsync('accounts - connection data cleaned up', function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // onClose callbacks are called in order, so we run after the\n    // close callback in accounts.\n    serverConn.onClose(function () {\n      test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n      onComplete();\n    });\n\n    test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n    serverConn.close();\n  }, onComplete);\n});\n\nTinytest.add('accounts - get new token', function (test) {\n  // Test that the `getNewToken` method returns us a valid token, with\n  // the same expiration as our original token.\n  var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  Accounts._insertLoginToken(userId, stampedToken);\n  var conn = DDP.connect(Meteor.absoluteUrl());\n  conn.call('login', { resume: stampedToken.token });\n  test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(stampedToken.token));\n\n  var newTokenResult = conn.call('getNewToken');\n  test.equal(newTokenResult.tokenExpires, Accounts._tokenExpiration(stampedToken.when));\n  test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(newTokenResult.token));\n  conn.disconnect();\n\n  // A second connection should be able to log in with the new token\n  // we got.\n  var secondConn = DDP.connect(Meteor.absoluteUrl());\n  secondConn.call('login', { resume: newTokenResult.token });\n  secondConn.disconnect();\n});\n\nTinytest.addAsync('accounts - remove other tokens', function (test, onComplete) {\n  // Test that the `removeOtherTokens` method removes all tokens other\n  // than the caller's token, thereby logging out and closing other\n  // connections.\n  var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedTokens = [];\n  var conns = [];\n\n  _.times(2, function (i) {\n    stampedTokens.push(Accounts._generateStampedLoginToken());\n    Accounts._insertLoginToken(userId, stampedTokens[i]);\n    var conn = DDP.connect(Meteor.absoluteUrl());\n    conn.call('login', { resume: stampedTokens[i].token });\n    test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(stampedTokens[i].token));\n    conns.push(conn);\n  });\n\n  conns[0].call('removeOtherTokens');\n  simplePoll(function () {\n    var tokens = _.map(conns, function (conn) {\n      return conn.call('getCurrentLoginToken');\n    });\n    return !tokens[1] && tokens[0] === Accounts._hashLoginToken(stampedTokens[0].token);\n  }, function () {\n    // success\n    _.each(conns, function (conn) {\n      conn.disconnect();\n    });\n    onComplete();\n  }, function () {\n    // timed out\n    throw new Error(\"accounts - remove other tokens timed out\");\n  });\n});\n\nTinytest.add('accounts - hook callbacks can access Meteor.userId()', function (test) {\n  var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  Accounts._insertLoginToken(userId, stampedToken);\n\n  var validateStopper = Accounts.validateLoginAttempt(function (attempt) {\n    test.equal(Meteor.userId(), validateAttemptExpectedUserId, \"validateLoginAttempt\");\n    return true;\n  });\n  var onLoginStopper = Accounts.onLogin(function (attempt) {\n    test.equal(Meteor.userId(), onLoginExpectedUserId, \"onLogin\");\n  });\n  var onLoginFailureStopper = Accounts.onLoginFailure(function (attempt) {\n    test.equal(Meteor.userId(), onLoginFailureExpectedUserId, \"onLoginFailure\");\n  });\n\n  var conn = DDP.connect(Meteor.absoluteUrl());\n\n  // On a new connection, Meteor.userId() should be null until logged in.\n  var validateAttemptExpectedUserId = null;\n  var onLoginExpectedUserId = userId;\n  conn.call('login', { resume: stampedToken.token });\n\n  // Now that the user is logged in on the connection, Meteor.userId() should\n  // return that user.\n  validateAttemptExpectedUserId = userId;\n  conn.call('login', { resume: stampedToken.token });\n\n  // Trigger onLoginFailure callbacks\n  var onLoginFailureExpectedUserId = userId;\n  test.throws(function () {\n    conn.call('login', { resume: \"bogus\" });\n  }, '403');\n\n  conn.disconnect();\n  validateStopper.stop();\n  onLoginStopper.stop();\n  onLoginFailureStopper.stop();\n});","ast":null,"map":{"version":3,"sources":["/packages/accounts-base/accounts_tests.js"],"names":[],"mappings":";;;;;;AAAA,OAAO,OAAP,CAAe;AACb;AAAsB,oCAAY;AAChC,aAAO,SAAS,cAAT,CAAwB,KAAK,UAAL,CAAgB,EAAhB,CAA/B,CADgC;KAAZ;;;KAAtB;CADF;;;;;AASA,SAAS,GAAT,CAAa,kCAAb,EAAiD,UAAU,IAAV,EAAgB;AAC/D,OAAK,MAAL,CAAY,YAAY;AACtB,aAAS,MAAT,CAAgB,EAAC,KAAK,KAAL,EAAjB,EADsB;GAAZ,CAAZ,CAD+D;CAAhB,CAAjD;;AAOA,IAAI,uBAAuB,EAAvB;AACJ,SAAS,eAAT,CAAyB,UAAU,IAAV,EAAgB;AACvC,uBAAqB,KAAK,GAAL,CAArB,GAAiC,IAAjC,CADuC;AAEvC,SAAO,IAAP,CAFuC;CAAhB,CAAzB;;AAKA,SAAS,GAAT,CAAa,sDAAb,EAAqE,UAAU,IAAV,EAAgB;AACnF,MAAI,YAAY,SAAS,qCAAT,CAA+C,SAA/C,EAA0D,EAAC,IAAI,OAAO,EAAP,EAAJ,EAA3D,EAA6E,MAA7E,CADmE;AAEnF,OAAK,MAAL,CAAY,aAAa,oBAAb,CAAZ,CAFmF;CAAhB,CAArE;;AAKA,SAAS,GAAT,CAAa,6DAAb,EAA4E,UAAU,IAAV,EAAgB;AAC1F,MAAI,aAAa,OAAO,EAAP,EAAb;;;AADsF,MAItF,OAAO,SAAS,qCAAT,CACT,UADS,EACG,EAAC,IAAI,UAAJ,EAAgB,QAAQ,EAAR,EADpB,EACiC,EAAC,SAAS,EAAC,KAAK,CAAL,EAAV,EADlC,EACsD,EADtD,CAJ+E;AAM1F,MAAI,QAAQ,OAAO,KAAP,CAAa,IAAb,CAAkB,EAAC,wBAAwB,UAAxB,EAAnB,EAAwD,KAAxD,EAAR,CANsF;AAO1F,OAAK,MAAL,CAAY,KAAZ,EAAmB,CAAnB,EAP0F;AAQ1F,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,OAAT,CAAiB,GAAjB,EAAsB,CAAjC,EAR0F;AAS1F,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,QAAT,CAAkB,QAAlB,CAA2B,MAA3B,EAAmC,EAA9C;;;;AAT0F,MAatF,OAAO,SAAS,qCAAT,CACT,UADS,EACG,EAAC,IAAI,UAAJ,EAAgB,OAAO,EAAP,EADpB,EAET,EAAC,SAAS,EAAC,KAAK,IAAL,EAAW,KAAK,CAAL,EAArB,EAFQ,EAEuB,EAFvB,CAb+E;AAgB1F,OAAK,KAAL,CAAW,IAAX,EAAiB,IAAjB,EAhB0F;AAiB1F,UAAQ,OAAO,KAAP,CAAa,IAAb,CAAkB,EAAC,wBAAwB,UAAxB,EAAnB,EAAwD,KAAxD,EAAR,CAjB0F;AAkB1F,OAAK,MAAL,CAAY,KAAZ,EAAmB,CAAnB,EAlB0F;AAmB1F,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,OAAT,CAAiB,GAAjB,EAAsB,CAAjC,EAnB0F;AAoB1F,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,OAAT,CAAiB,GAAjB,EAAsB,SAAjC,EApB0F;AAqB1F,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,QAAT,CAAkB,QAAlB,CAA2B,KAA3B,EAAkC,EAA7C;;;AArB0F,MAwB1F,CAAK,KAAL,CAAW,MAAM,CAAN,EAAS,QAAT,CAAkB,QAAlB,CAA2B,MAA3B,EAAmC,EAA9C;;;AAxB0F,QA2B1F,CAAO,KAAP,CAAa,MAAb,CAAoB,IAApB,EA3B0F;CAAhB,CAA5E;;AA8BA,SAAS,GAAT,CAAa,0DAAb,EAAyE,UAAU,IAAV,EAAgB;AACvF,MAAI,WAAW,OAAO,EAAP,EAAX,CADmF;AAEvF,MAAI,WAAW,OAAO,EAAP,EAAX;;;AAFmF,MAKnF,OAAO,SAAS,qCAAT,CACT,OADS,EACA,EAAC,IAAI,QAAJ,EADD,EACgB,EAAC,SAAS,EAAC,KAAK,CAAL,EAAV,EADjB,EACqC,EADrC,CAL4E;AAOvF,MAAI,OAAO,SAAS,qCAAT,CACT,OADS,EACA,EAAC,IAAI,QAAJ,EADD,EACgB,EAAC,SAAS,EAAC,KAAK,CAAL,EAAV,EADjB,EACqC,EADrC,CAP4E;AASvF,OAAK,KAAL,CAAW,OAAO,KAAP,CAAa,IAAb,CAAkB,EAAC,qBAAqB,EAAC,KAAK,CAAC,QAAD,EAAW,QAAX,CAAL,EAAtB,EAAnB,EAAsE,KAAtE,EAAX,EAA0F,CAA1F,EATuF;AAUvF,OAAK,KAAL,CAAW,OAAO,KAAP,CAAa,OAAb,CAAqB,EAAC,qBAAqB,QAArB,EAAtB,EAAsD,OAAtD,CAA8D,GAA9D,EAAmE,CAA9E,EAVuF;AAWvF,OAAK,KAAL,CAAW,OAAO,KAAP,CAAa,OAAb,CAAqB,EAAC,qBAAqB,QAArB,EAAtB,EAAsD,MAAtD,EAA8D,SAAzE,EAXuF;AAYvF,OAAK,KAAL,CAAW,OAAO,KAAP,CAAa,OAAb,CAAqB,EAAC,qBAAqB,QAArB,EAAtB,EAAsD,OAAtD,CAA8D,GAA9D,EAAmE,CAA9E,EAZuF;AAavF,OAAK,KAAL,CAAW,OAAO,KAAP,CAAa,OAAb,CAAqB,EAAC,qBAAqB,QAArB,EAAtB,EAAsD,MAAtD,EAA8D,SAAzE;;;AAbuF,QAgBvF,CAAO,KAAP,CAAa,MAAb,CAAoB,IAApB,EAhBuF;AAiBvF,SAAO,KAAP,CAAa,MAAb,CAAoB,IAApB,EAjBuF;CAAhB,CAAzE;;AAoBA,SAAS,GAAT,CAAa,4DAAb,EAA2E,UAAU,IAAV,EAAgB;AACzF,MAAI,eAAe,SAAS,OAAO,SAAP,CAAiB,CAAjB,CAAT,EAA8B,EAA9B,CAAf,CADqF;AAEzF,MAAI,eAAe,KAAG,YAAH;;;AAFsE,MAKrF,OAAO,SAAS,qCAAT,CACT,SADS,EACE,EAAC,IAAI,YAAJ,EAAkB,QAAQ,EAAR,EADrB,EACkC,EAAC,SAAS,EAAC,KAAK,CAAL,EAAV,EADnC,EACuD,EADvD,CAL8E;AAOzF,MAAI,QAAQ,OAAO,KAAP,CAAa,IAAb,CAAkB,EAAC,uBAAuB,YAAvB,EAAnB,EAAyD,KAAzD,EAAR,CAPqF;AAQzF,OAAK,MAAL,CAAY,KAAZ,EAAmB,CAAnB,EARyF;AASzF,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,OAAT,CAAiB,GAAjB,EAAsB,CAAjC,EATyF;AAUzF,OAAK,KAAL,CAAW,MAAM,CAAN,EAAS,QAAT,CAAkB,OAAlB,CAA0B,MAA1B,EAAkC,EAA7C;;;;;AAVyF,MAerF,OAAO,SAAS,qCAAT,CACT,SADS,EACE,EAAC,IAAI,YAAJ,EAAkB,QAAQ,EAAR,EADrB,EACkC,EAAC,SAAS,EAAC,KAAK,CAAL,EAAV,EADnC,EACuD,EADvD,CAf8E;AAiBzF,OAAK,KAAL,CAAW,IAAX,EAAiB,IAAjB,EAjByF;AAkBzF,UAAQ,OAAO,KAAP,CAAa,IAAb,CAAkB,EAAC,uBAAuB,YAAvB,EAAnB,EAAyD,KAAzD,EAAR,CAlByF;AAmBzF,OAAK,MAAL,CAAY,KAAZ,EAAmB,CAAnB;;;AAnByF,QAsBzF,CAAO,KAAP,CAAa,MAAb,CAAoB,IAApB,EAtByF;CAAhB,CAA3E;;AA0BA,SAAS,GAAT,CAAa,mCAAb,EAAkD,UAAU,IAAV,EAAgB;AAChE,MAAI,SAAS;AACX,cAAU,OAAO,EAAP,EAAV;GADE;;;AAD4D,MAM5D,SAAS,SAAS,aAAT,CACX,EAAC,SAAS,EAAC,MAAM,SAAN,EAAV,EADU,EAEX,MAFW,CAAT,CAN4D;AAUhE,MAAI,UAAU,OAAO,KAAP,CAAa,OAAb,CAAqB,MAArB,CAAV,CAV4D;;AAYhE,OAAK,KAAL,0BAAkB,QAAQ,SAAR,CAAlB,EAAqC,QAArC,EAZgE;AAahE,OAAK,KAAL,CAAW,QAAQ,OAAR,CAAgB,IAAhB,EAAsB,SAAjC,EAbgE;AAchE,OAAK,KAAL,CAAW,QAAQ,QAAR,EAAkB,OAAO,QAAP,CAA7B;;;AAdgE,MAiBhE,CAAK,MAAL,CAAY,YAAY;AACtB,aAAS,aAAT,CACE,EAAC,SAAS,EAAC,MAAM,SAAN,EAAV,EADH,EAEE,MAFF,EADsB;GAAZ,EAKT,0BALH;;;AAjBgE,QAyBhE,CAAO,KAAP,CAAa,MAAb,CAAoB,MAApB,EAzBgE;CAAhB,CAAlD;;AA4BA,SAAS,GAAT,CAAa,gCAAb,EAA+C,UAAU,IAAV,EAAgB;AAC7D,MAAI,SAAS,OAAO,EAAP,EAAT,CADyD;AAE7D,MAAI,SAAS,OAAO,EAAP,EAAT,CAFyD;AAG7D,MAAI,SAAS,OAAO,EAAP,EAAT,CAHyD;AAI7D,MAAI,SAAS;AACX,YAAQ,CAAC,EAAC,SAAS,MAAT,EAAiB,UAAU,KAAV,EAAnB,EACC,EAAC,SAAS,MAAT,EAAiB,UAAU,IAAV,EADnB,CAAR;GADE;;;AAJyD,MAUzD,SAAS,SAAS,aAAT,CACX,EAAC,SAAS,EAAC,MAAM,SAAN,EAAV,EADU,EAEX,MAFW,CAAT,CAVyD;AAc7D,MAAI,UAAU,OAAO,KAAP,CAAa,OAAb,CAAqB,MAArB,CAAV,CAdyD;;AAgB7D,OAAK,KAAL,0BAAkB,QAAQ,SAAR,CAAlB,EAAqC,QAArC,EAhB6D;AAiB7D,OAAK,KAAL,CAAW,QAAQ,OAAR,CAAgB,IAAhB,EAAsB,SAAjC,EAjB6D;AAkB7D,OAAK,KAAL,CAAW,QAAQ,MAAR,EAAgB,OAAO,MAAP,CAA3B;;;;AAlB6D,MAsB7D,CAAK,MAAL,CAAY,YAAY;AACtB,aAAS,aAAT,CACE,EAAC,SAAS,EAAC,MAAM,SAAN,EAAV,EADH,EAEE,MAFF,EADsB;GAAZ,EAKT,uBALH;;;AAtB6D,MA8B7D,CAAK,MAAL,CAAY,YAAY;AACtB,aAAS,aAAT,CACE,EADF,EACM,EAAC,QAAQ,CAAC,EAAC,SAAS,MAAT,EAAF,CAAR,EADP,EADsB;GAAZ,EAIT,uBAJH,EA9B6D;;AAoC7D,OAAK,MAAL,CAAY,YAAY;AACtB,aAAS,aAAT,CACE,EADF,EACM,EAAC,QAAQ,CAAC,EAAC,SAAS,MAAT,EAAF,CAAR,EADP,EADsB;GAAZ,EAIT,uBAJH;;;AApC6D,MA4CzD,UAAU,SAAS,aAAT,CACV,EADU,EACN,EAAC,QAAQ,CAAC,EAAC,SAAS,MAAT,EAAF,CAAR,EADK,CAAV,CA5CyD;AA+C7D,MAAI,QAAQ,OAAO,KAAP,CAAa,OAAb,CAAqB,OAArB,CAAR,CA/CyD;AAgD7D,OAAK,KAAL,0BAAkB,MAAM,SAAN,CAAlB,EAAmC,QAAnC;;;AAhD6D,QAmD7D,CAAO,KAAP,CAAa,MAAb,CAAoB,MAApB,EAnD6D;AAoD7D,SAAO,KAAP,CAAa,MAAb,CAAoB,OAApB,EApD6D;CAAhB,CAA/C;;;AAwDA,SAAS,QAAT,CAAkB,iCAAlB,EAAqD,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC/E,MAAI,SAAS,EAAE,UAAU,OAAO,EAAP,EAAV,EAAX,CAD2E;AAE/E,MAAI,SAAS,SAAS,aAAT,CAAuB,EAAE,SAAS;AAC7C,YAAM,SAAN;KADoC,EAAzB,EAER,MAFQ,CAAT,CAF2E;AAK/E,MAAI,OAAO,IAAI,IAAJ,CAAS,IAAI,IAAJ,KAAa,IAAb,CAAhB,CAL2E;AAM/E,SAAO,KAAP,CAAa,MAAb,CAAoB,MAApB,EAA4B;AAC1B,UAAM;AACJ,qCAA+B,CAAC;AAC9B,qBAAa,OAAO,EAAP,EAAb;AACA,cAAM,IAAN;OAF6B,EAG5B;AACD,qBAAa,OAAO,EAAP,EAAb;AACA,cAAM,CAAC,IAAD;OALuB,CAA/B;KADF;GADF,EAN+E;AAiB/E,MAAI,UAAU,OAAO,KAAP,CAAa,IAAb,CAAkB,MAAlB,EAA0B,OAA1B,CAAkC;AAC9C;AAAS,uBAAU,OAAV,EAAmB;AAC1B,YAAI,QAAQ,QAAR,IAAoB,QAAQ,QAAR,CAAiB,MAAjB,IACpB,EAAE,OAAF,CAAU,QAAQ,QAAR,CAAiB,MAAjB,CAAwB,WAAxB,CADV,EACgD;AAClD,kBAAQ,IAAR,GADkD;AAElD,uBAFkD;SADpD;OADO;;;OAAT;GADY,CAAV,CAjB2E;AA0B/E,WAAS,aAAT,CAAuB,IAAI,IAAJ,EAAvB,EAAmC,MAAnC,EA1B+E;CAA5B,CAArD;;;;AAgCA,IAAI,2BAA2B,SAA3B,wBAA2B,CAAU,MAAV,EAAkB,YAAlB,EAAgC;AAC7D,SAAO,KAAP,CAAa,MAAb,CACE,MADF,EAEE,EAAC,OAAO,EAAC,+BAA+B,YAA/B,EAAR,EAFH,EAD6D;CAAhC;;AAO/B,SAAS,QAAT,CAAkB,wBAAlB,EAA4C,UAAU,IAAV,EAAgB,UAAhB,EAA4B;;;AAGtE,MAAI,UAAU,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAC,UAAU,OAAO,EAAP,EAAV,EAA5B,CAAV,CAHkE;AAItE,MAAI,eAAe,SAAS,0BAAT,EAAf,CAJkE;AAKtE,2BAAyB,OAAzB,EAAkC,YAAlC,EALsE;AAMtE,MAAI,aAAa,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAb,CANkE;AAOtE,aAAW,IAAX,CAAgB,OAAhB,EAAyB,EAAC,QAAQ,aAAa,KAAb,EAAlC,EAPsE;AAQtE,aAAW,UAAX;;;;;AARsE,MAalE,UAAU,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAC,UAAU,OAAO,EAAP,EAAV,EAA5B,CAAV,CAbkE;AActE,2BAAyB,OAAzB,EAAkC,SAAS,0BAAT,EAAlC,EAdsE;AAetE,MAAI,cAAc,OAAO,KAAP,CAAa,OAAb,CAAqB,OAArB,EAA8B,QAA9B,CAAuC,MAAvC,CAA8C,WAA9C,CAA0D,CAA1D,EAA6D,KAA7D,CAfoD;AAgBtE,OAAK,MAAL,CAAY,WAAZ,EAhBsE;AAiBtE,eAAa,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAb,CAjBsE;AAkBtE,aAAW,IAAX,CAAgB,OAAhB,EAAyB,EAAC,QAAQ,WAAR,EAA1B,EAlBsE;AAmBtE,aAAW,UAAX;;;AAnBsE,MAsBlE,UAAU,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAC,UAAU,OAAO,EAAP,EAAV,EAA5B,CAAV,CAtBkE;AAuBtE,WAAS,iBAAT,CAA2B,OAA3B,EAAoC,SAAS,0BAAT,EAApC,EAvBsE;AAwBtE,gBAAc,OAAO,KAAP,CAAa,OAAb,CAAqB,OAArB,EAA8B,QAA9B,CAAuC,MAAvC,CAA8C,WAA9C,CAA0D,CAA1D,EAA6D,WAA7D,CAxBwD;AAyBtE,OAAK,MAAL,CAAY,WAAZ,EAzBsE;AA0BtE,eAAa,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAb;;AA1BsE,MA4BtE,CAAK,MAAL,CACE,YAAY;AACV,eAAW,IAAX,CAAgB,OAAhB,EAAyB,EAAC,QAAQ,WAAR,EAA1B,EADU;GAAZ,EAGA,uCAJF,EA5BsE;AAkCtE,aAAW,UAAX;;;;;AAlCsE,MAuClE,UAAU,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAC,UAAU,OAAO,EAAP,EAAV,EAA5B,CAAV,CAvCkE;AAwCtE,MAAI,eAAe,SAAS,0BAAT,EAAf,CAxCkE;AAyCtE,2BAAyB,OAAzB,EAAkC,YAAlC,EAzCsE;AA0CtE,eAAa,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAb,CA1CsE;AA2CtE,aAAW,IAAX,CAAgB,OAAhB,EAAyB,EAAC,QAAQ,aAAa,KAAb,EAAlC,EA3CsE;AA4CtE,aAAW,UAAX;;;AA5CsE,aA+CtE,GAAc,OAAO,KAAP,CAAa,OAAb,CAAqB,OAArB,EAA8B,QAA9B,CAAuC,MAAvC,CAA8C,WAA9C,CAA0D,CAA1D,EAA6D,KAA7D,CA/CwD;AAgDtE,OAAK,OAAL,CAAa,WAAb;;;;AAhDsE,YAoDtE,GAAa,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAb,CApDsE;AAqDtE,aAAW,IAAX,CAAgB,OAAhB,EAAyB,EAAC,QAAQ,aAAa,KAAb,EAAlC,EArDsE;AAsDtE,aAAW,UAAX,GAtDsE;;AAwDtE,eAxDsE;CAA5B,CAA5C;;AA2DA,SAAS,QAAT,CACE,uCADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC1B,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;;;AAGhC,eAAW,OAAX,CAAmB,YAAY;AAC7B,WAAK,OAAL,CAAa,SAAS,eAAT,CAAyB,WAAW,EAAX,EAAe,YAAxC,CAAb,EAD6B;AAE7B,mBAF6B;KAAZ,CAAnB,CAHgC;;AAQhC,SAAK,MAAL,CAAY,SAAS,eAAT,CAAyB,WAAW,EAAX,EAAe,YAAxC,CAAZ,EARgC;AAShC,eAAW,KAAX,GATgC;GAAlC,EAWA,UAbF,EAD0B;CAA5B,CAFF;;AAqBA,SAAS,GAAT,CACE,0BADF,EAEE,UAAU,IAAV,EAAgB;;;AAGd,MAAI,SAAS,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAE,UAAU,OAAO,EAAP,EAAV,EAA7B,CAAT,CAHU;AAId,MAAI,eAAe,SAAS,0BAAT,EAAf,CAJU;AAKd,WAAS,iBAAT,CAA2B,MAA3B,EAAmC,YAAnC,EALc;AAMd,MAAI,OAAO,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAP,CANU;AAOd,OAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,QAAQ,aAAa,KAAb,EAA7B,EAPc;AAQd,OAAK,KAAL,CAAW,KAAK,IAAL,CAAU,sBAAV,CAAX,EACW,SAAS,eAAT,CAAyB,aAAa,KAAb,CADpC,EARc;;AAWd,MAAI,iBAAiB,KAAK,IAAL,CAAU,aAAV,CAAjB,CAXU;AAYd,OAAK,KAAL,CAAW,eAAe,YAAf,EACA,SAAS,gBAAT,CAA0B,aAAa,IAAb,CADrC,EAZc;AAcd,OAAK,KAAL,CAAW,KAAK,IAAL,CAAU,sBAAV,CAAX,EACW,SAAS,eAAT,CAAyB,eAAe,KAAf,CADpC,EAdc;AAgBd,OAAK,UAAL;;;;AAhBc,MAoBV,aAAa,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAb,CApBU;AAqBd,aAAW,IAAX,CAAgB,OAAhB,EAAyB,EAAE,QAAQ,eAAe,KAAf,EAAnC,EArBc;AAsBd,aAAW,UAAX,GAtBc;CAAhB,CAFF;;AA4BA,SAAS,QAAT,CACE,gCADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;;;;AAI1B,MAAI,SAAS,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAE,UAAU,OAAO,EAAP,EAAV,EAA7B,CAAT,CAJsB;AAK1B,MAAI,gBAAgB,EAAhB,CALsB;AAM1B,MAAI,QAAQ,EAAR,CANsB;;AAQ1B,IAAE,KAAF,CAAQ,CAAR,EAAW,UAAU,CAAV,EAAa;AACtB,kBAAc,IAAd,CAAmB,SAAS,0BAAT,EAAnB,EADsB;AAEtB,aAAS,iBAAT,CAA2B,MAA3B,EAAmC,cAAc,CAAd,CAAnC,EAFsB;AAGtB,QAAI,OAAO,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAP,CAHkB;AAItB,SAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,QAAQ,cAAc,CAAd,EAAiB,KAAjB,EAA7B,EAJsB;AAKtB,SAAK,KAAL,CAAW,KAAK,IAAL,CAAU,sBAAV,CAAX,EACW,SAAS,eAAT,CAAyB,cAAc,CAAd,EAAiB,KAAjB,CADpC,EALsB;AAOtB,UAAM,IAAN,CAAW,IAAX,EAPsB;GAAb,CAAX,CAR0B;;AAkB1B,QAAM,CAAN,EAAS,IAAT,CAAc,mBAAd,EAlB0B;AAmB1B,aACE,YAAY;AACV,QAAI,SAAS,EAAE,GAAF,CAAM,KAAN,EAAa,UAAU,IAAV,EAAgB;AACxC,aAAO,KAAK,IAAL,CAAU,sBAAV,CAAP,CADwC;KAAhB,CAAtB,CADM;AAIV,WAAO,CAAE,OAAO,CAAP,CAAF,IACL,OAAO,CAAP,MAAc,SAAS,eAAT,CAAyB,cAAc,CAAd,EAAiB,KAAjB,CAAvC,CALQ;GAAZ,EAOA,YAAY;;AACV,MAAE,IAAF,CAAO,KAAP,EAAc,UAAU,IAAV,EAAgB;AAC5B,WAAK,UAAL,GAD4B;KAAhB,CAAd,CADU;AAIV,iBAJU;GAAZ,EAMA,YAAY;;AACV,UAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN,CADU;GAAZ,CAdF,CAnB0B;CAA5B,CAFF;;AA0CA,SAAS,GAAT,CACE,sDADF,EAEE,UAAU,IAAV,EAAgB;AACd,MAAI,SAAS,SAAS,aAAT,CAAuB,EAAvB,EAA2B,EAAE,UAAU,OAAO,EAAP,EAAV,EAA7B,CAAT,CADU;AAEd,MAAI,eAAe,SAAS,0BAAT,EAAf,CAFU;AAGd,WAAS,iBAAT,CAA2B,MAA3B,EAAmC,YAAnC,EAHc;;AAKd,MAAI,kBAAkB,SAAS,oBAAT,CAA8B,UAAS,OAAT,EAAkB;AACpE,SAAK,KAAL,CAAW,OAAO,MAAP,EAAX,EAA4B,6BAA5B,EAA2D,sBAA3D,EADoE;AAEpE,WAAO,IAAP,CAFoE;GAAlB,CAAhD,CALU;AASd,MAAI,iBAAiB,SAAS,OAAT,CAAiB,UAAS,OAAT,EAAkB;AACtD,SAAK,KAAL,CAAW,OAAO,MAAP,EAAX,EAA4B,qBAA5B,EAAmD,SAAnD,EADsD;GAAlB,CAAlC,CATU;AAYd,MAAI,wBAAwB,SAAS,cAAT,CAAwB,UAAS,OAAT,EAAkB;AACpE,SAAK,KAAL,CAAW,OAAO,MAAP,EAAX,EAA4B,4BAA5B,EAA0D,gBAA1D,EADoE;GAAlB,CAAhD,CAZU;;AAgBd,MAAI,OAAO,IAAI,OAAJ,CAAY,OAAO,WAAP,EAAZ,CAAP;;;AAhBU,MAmBV,gCAAgC,IAAhC,CAnBU;AAoBd,MAAI,wBAAwB,MAAxB,CApBU;AAqBd,OAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,QAAQ,aAAa,KAAb,EAA7B;;;;AArBc,+BAyBd,GAAgC,MAAhC,CAzBc;AA0Bd,OAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,QAAQ,aAAa,KAAb,EAA7B;;;AA1Bc,MA6BV,+BAA+B,MAA/B,CA7BU;AA8Bd,OAAK,MAAL,CAAY,YAAW;AAAE,SAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,QAAQ,OAAR,EAArB,EAAF;GAAX,EAAwD,KAApE,EA9Bc;;AAgCd,OAAK,UAAL,GAhCc;AAiCd,kBAAgB,IAAhB,GAjCc;AAkCd,iBAAe,IAAf,GAlCc;AAmCd,wBAAsB,IAAtB,GAnCc;CAAhB,CAFF","file":"/packages/accounts-base/accounts_tests.js.map","sourcesContent":["Meteor.methods({\n  getCurrentLoginToken: function () {\n    return Accounts._getLoginToken(this.connection.id);\n  }\n});\n\n// XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({foo: \"bar\"});\n  });\n});\n\n\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\n\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', {id: Random.id()}).userId;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id();\n\n  // create an account with facebook\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, llama: 50},\n    {profile: {foo: 1000, bar: 2}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50);\n  // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id();\n\n  // users that have different service ids get different users\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId1}, {profile: {foo: 1}}).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId2}, {profile: {bar: 2}}).id;\n  test.equal(Meteor.users.find({\"services.weibo.id\": {$in: [weiboId1, weiboId2]}}).count(), 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).profile.foo, 1);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).emails, undefined);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).profile.bar, 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).emails, undefined);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = ''+twitterIdOld;\n\n  // create an account with twitter using the old ID format of integer\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdOld, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.twitter.id\": twitterIdOld}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42);\n\n  // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdNew, monkey: 42}, {profile: {foo: 1}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.twitter.id\": twitterIdNew}).fetch();\n  test.length(users, 1);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\n\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username);\n\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  }, 'Username already exists.');\n\n  // cleanup\n  Meteor.users.remove(userId);\n});\n\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{address: email1, verified: false},\n             {address: email2, verified: true}]\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails);\n\n  // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  }, 'Email already exists.');\n\n  // now with only one of them.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email1}]}\n    );\n  }, 'Email already exists.');\n\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email2}]}\n    );\n  }, 'Email already exists.');\n\n\n  // a third email works.\n  var userId3 = Accounts.insertUserDoc(\n      {}, {emails: [{address: email3}]}\n  );\n  var user3 = Meteor.users.findOne(userId3);\n  test.equal(typeof user3.createdAt, 'object');\n\n  // cleanup\n  Meteor.users.remove(userId);\n  Meteor.users.remove(userId3);\n});\n\n// More token expiration tests are in accounts-password\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = { username: Random.id() };\n  var userId = Accounts.insertUserDoc({ profile: {\n    name: 'Foo Bar'\n  } }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        hashedToken: Random.id(),\n        when: date\n      }, {\n        hashedToken: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(userId).observe({\n    changed: function (newUser) {\n      if (newUser.services && newUser.services.resume &&\n          _.isEmpty(newUser.services.resume.loginTokens)) {\n        observe.stop();\n        onComplete();\n      }\n    }\n  });\n  Accounts._expireTokens(new Date(), userId);\n});\n\n\n// Login tokens used to be stored unhashed in the database.  We want\n// to make sure users can still login after upgrading.\nvar insertUnhashedLoginToken = function (userId, stampedToken) {\n  Meteor.users.update(\n    userId,\n    {$push: {'services.resume.loginTokens': stampedToken}}\n  );\n};\n\nTinytest.addAsync('accounts - login token', function (test, onComplete) {\n  // Test that we can login when the database contains a leftover\n  // old style unhashed login token.\n  var userId1 = Accounts.insertUserDoc({}, {username: Random.id()});\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId1, stampedToken);\n  var connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  // Steal the unhashed token from the database and use it to login.\n  // This is a sanity check so that when we *can't* login with a\n  // stolen *hashed* token, we know it's not a problem with the test.\n  var userId2 = Accounts.insertUserDoc({}, {username: Random.id()});\n  insertUnhashedLoginToken(userId2, Accounts._generateStampedLoginToken());\n  var stolenToken = Meteor.users.findOne(userId2).services.resume.loginTokens[0].token;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stolenToken});\n  connection.disconnect();\n\n  // Now do the same thing, this time with a stolen hashed token.\n  var userId3 = Accounts.insertUserDoc({}, {username: Random.id()});\n  Accounts._insertLoginToken(userId3, Accounts._generateStampedLoginToken());\n  stolenToken = Meteor.users.findOne(userId3).services.resume.loginTokens[0].hashedToken;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  // evil plan foiled\n  test.throws(\n    function () {\n      connection.call('login', {resume: stolenToken});\n    },\n    /You\\'ve been logged out by the server/\n  );\n  connection.disconnect();\n\n  // Old style unhashed tokens are replaced by hashed tokens when\n  // encountered.  This means that after someone logins once, the\n  // old unhashed token is no longer available to be stolen.\n  var userId4 = Accounts.insertUserDoc({}, {username: Random.id()});\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId4, stampedToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  // The token is no longer available to be stolen.\n  stolenToken = Meteor.users.findOne(userId4).services.resume.loginTokens[0].token;\n  test.isFalse(stolenToken);\n\n  // After the upgrade, the client can still login with their original\n  // unhashed login token.\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  onComplete();\n});\n\nTinytest.addAsync(\n  'accounts - connection data cleaned up',\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // onClose callbacks are called in order, so we run after the\n        // close callback in accounts.\n        serverConn.onClose(function () {\n          test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n          onComplete();\n        });\n\n        test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.add(\n  'accounts - get new token',\n  function (test) {\n    // Test that the `getNewToken` method returns us a valid token, with\n    // the same expiration as our original token.\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedToken);\n    var conn = DDP.connect(Meteor.absoluteUrl());\n    conn.call('login', { resume: stampedToken.token });\n    test.equal(conn.call('getCurrentLoginToken'),\n               Accounts._hashLoginToken(stampedToken.token));\n\n    var newTokenResult = conn.call('getNewToken');\n    test.equal(newTokenResult.tokenExpires,\n               Accounts._tokenExpiration(stampedToken.when));\n    test.equal(conn.call('getCurrentLoginToken'),\n               Accounts._hashLoginToken(newTokenResult.token));\n    conn.disconnect();\n\n    // A second connection should be able to log in with the new token\n    // we got.\n    var secondConn = DDP.connect(Meteor.absoluteUrl());\n    secondConn.call('login', { resume: newTokenResult.token });\n    secondConn.disconnect();\n  }\n);\n\nTinytest.addAsync(\n  'accounts - remove other tokens',\n  function (test, onComplete) {\n    // Test that the `removeOtherTokens` method removes all tokens other\n    // than the caller's token, thereby logging out and closing other\n    // connections.\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedTokens = [];\n    var conns = [];\n\n    _.times(2, function (i) {\n      stampedTokens.push(Accounts._generateStampedLoginToken());\n      Accounts._insertLoginToken(userId, stampedTokens[i]);\n      var conn = DDP.connect(Meteor.absoluteUrl());\n      conn.call('login', { resume: stampedTokens[i].token });\n      test.equal(conn.call('getCurrentLoginToken'),\n                 Accounts._hashLoginToken(stampedTokens[i].token));\n      conns.push(conn);\n    });\n\n    conns[0].call('removeOtherTokens');\n    simplePoll(\n      function () {\n        var tokens = _.map(conns, function (conn) {\n          return conn.call('getCurrentLoginToken');\n        });\n        return ! tokens[1] &&\n          tokens[0] === Accounts._hashLoginToken(stampedTokens[0].token);\n      },\n      function () { // success\n        _.each(conns, function (conn) {\n          conn.disconnect();\n        });\n        onComplete();\n      },\n      function () { // timed out\n        throw new Error(\"accounts - remove other tokens timed out\");\n      }\n    );\n  }\n);\n\nTinytest.add(\n  'accounts - hook callbacks can access Meteor.userId()',\n  function (test) {\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedToken);\n\n    var validateStopper = Accounts.validateLoginAttempt(function(attempt) {\n      test.equal(Meteor.userId(), validateAttemptExpectedUserId, \"validateLoginAttempt\");\n      return true;\n    });\n    var onLoginStopper = Accounts.onLogin(function(attempt) {\n      test.equal(Meteor.userId(), onLoginExpectedUserId, \"onLogin\");\n    });\n    var onLoginFailureStopper = Accounts.onLoginFailure(function(attempt) {\n      test.equal(Meteor.userId(), onLoginFailureExpectedUserId, \"onLoginFailure\");\n    });\n\n    var conn = DDP.connect(Meteor.absoluteUrl());\n\n    // On a new connection, Meteor.userId() should be null until logged in.\n    var validateAttemptExpectedUserId = null;\n    var onLoginExpectedUserId = userId;\n    conn.call('login', { resume: stampedToken.token });\n\n    // Now that the user is logged in on the connection, Meteor.userId() should\n    // return that user.\n    validateAttemptExpectedUserId = userId;\n    conn.call('login', { resume: stampedToken.token });\n\n    // Trigger onLoginFailure callbacks\n    var onLoginFailureExpectedUserId = userId;\n    test.throws(function() { conn.call('login', { resume: \"bogus\" }) }, '403');\n\n    conn.disconnect();\n    validateStopper.stop();\n    onLoginStopper.stop();\n    onLoginFailureStopper.stop();\n  }\n);\n"]},"hash":"78378f722473693673855c41b99a2842cb7ba65e"}
