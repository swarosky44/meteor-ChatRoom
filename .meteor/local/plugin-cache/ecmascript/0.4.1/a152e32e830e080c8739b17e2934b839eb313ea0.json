{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"./accounts_client.js","imported":["AccountsClient"],"specifiers":[{"kind":"named","imported":"AccountsClient","local":"AccountsClient"}]}],"exports":{"exported":["AccountsTest"],"specifiers":[{"kind":"local","local":"AccountsTest","exported":"AccountsTest"}]}}},"options":{"filename":"/packages/accounts-base/url_client.js","filenameRelative":"/packages/accounts-base/url_client.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/url_client.js.map","sourceFileName":"/packages/accounts-base/url_client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"url_client"},"ignored":false,"code":"exports.__esModule = true;\nexports.AccountsTest = undefined;\n\nvar _accounts_client = require(\"./accounts_client.js\");\n\nvar Ap = _accounts_client.AccountsClient.prototype;\n\n// All of the special hash URLs we support for accounts interactions\nvar accountsPaths = [\"reset-password\", \"verify-email\", \"enroll-account\"];\n\nvar savedHash = window.location.hash;\n\nAp._initUrlMatching = function () {\n  // By default, allow the autologin process to happen.\n  this._autoLoginEnabled = true;\n\n  // We only support one callback per URL.\n  this._accountsCallbacks = {};\n\n  // Try to match the saved value of window.location.hash.\n  this._attemptToMatchHash();\n};\n\n// Separate out this functionality for testing\n\nAp._attemptToMatchHash = function () {\n  _attemptToMatchHash(this, savedHash, defaultSuccessHandler);\n};\n\n// Note that both arguments are optional and are currently only passed by\n// accounts_url_tests.js.\nfunction _attemptToMatchHash(accounts, hash, success) {\n  _.each(accountsPaths, function (urlPart) {\n    var token;\n\n    var tokenRegex = new RegExp(\"^\\\\#\\\\/\" + urlPart + \"\\\\/(.*)$\");\n    var match = hash.match(tokenRegex);\n\n    if (match) {\n      token = match[1];\n\n      // XXX COMPAT WITH 0.9.3\n      if (urlPart === \"reset-password\") {\n        accounts._resetPasswordToken = token;\n      } else if (urlPart === \"verify-email\") {\n        accounts._verifyEmailToken = token;\n      } else if (urlPart === \"enroll-account\") {\n        accounts._enrollAccountToken = token;\n      }\n    } else {\n      return;\n    }\n\n    // If no handlers match the hash, then maybe it's meant to be consumed\n    // by some entirely different code, so we only clear it the first time\n    // a handler successfully matches. Note that later handlers reuse the\n    // savedHash, so clearing window.location.hash here will not interfere\n    // with their needs.\n    window.location.hash = \"\";\n\n    // Do some stuff with the token we matched\n    success.call(accounts, token, urlPart);\n  });\n}\n\nfunction defaultSuccessHandler(token, urlPart) {\n  var self = this;\n\n  // put login in a suspended state to wait for the interaction to finish\n  self._autoLoginEnabled = false;\n\n  // wait for other packages to register callbacks\n  Meteor.startup(function () {\n    // if a callback has been registered for this kind of token, call it\n    if (self._accountsCallbacks[urlPart]) {\n      self._accountsCallbacks[urlPart](token, function () {\n        self._enableAutoLogin();\n      });\n    }\n  });\n}\n\n// Export for testing\nvar AccountsTest = exports.AccountsTest = {\n  attemptToMatchHash: function () {\n    function attemptToMatchHash(hash, success) {\n      return _attemptToMatchHash(Accounts, hash, success);\n    }\n\n    return attemptToMatchHash;\n  }()\n};\n\n// XXX these should be moved to accounts-password eventually. Right now\n// this is prevented by the need to set autoLoginEnabled=false, but in\n// some bright future we won't need to do that anymore.\n\n/**\n * @summary Register a function to call when a reset password link is clicked\n * in an email sent by\n * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @memberof! Accounts\n * @name onResetPasswordLink\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: A password reset token that can be passed to\n * [`Accounts.resetPassword`](#accounts_resetpassword).\n * 2. `done`: A function to call when the password reset UI flow is complete. The normal\n * login process is suspended until this function is called, so that the\n * password for user A can be reset even if user B was logged in.\n * @locus Client\n */\nAp.onResetPasswordLink = function (callback) {\n  if (this._accountsCallbacks[\"reset-password\"]) {\n    Meteor._debug(\"Accounts.onResetPasswordLink was called more than once. \" + \"Only one callback added will be executed.\");\n  }\n\n  this._accountsCallbacks[\"reset-password\"] = callback;\n};\n\n/**\n * @summary Register a function to call when an email verification link is\n * clicked in an email sent by\n * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @memberof! Accounts\n * @name onEmailVerificationLink\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: An email verification token that can be passed to\n * [`Accounts.verifyEmail`](#accounts_verifyemail).\n * 2. `done`: A function to call when the email verification UI flow is complete.\n * The normal login process is suspended until this function is called, so\n * that the user can be notified that they are verifying their email before\n * being logged in.\n * @locus Client\n */\nAp.onEmailVerificationLink = function (callback) {\n  if (this._accountsCallbacks[\"verify-email\"]) {\n    Meteor._debug(\"Accounts.onEmailVerificationLink was called more than once. \" + \"Only one callback added will be executed.\");\n  }\n\n  this._accountsCallbacks[\"verify-email\"] = callback;\n};\n\n/**\n * @summary Register a function to call when an account enrollment link is\n * clicked in an email sent by\n * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @memberof! Accounts\n * @name onEnrollmentLink\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: A password reset token that can be passed to\n * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\n * enrolled account a password.\n * 2. `done`: A function to call when the enrollment UI flow is complete.\n * The normal login process is suspended until this function is called, so that\n * user A can be enrolled even if user B was logged in.\n * @locus Client\n */\nAp.onEnrollmentLink = function (callback) {\n  if (this._accountsCallbacks[\"enroll-account\"]) {\n    Meteor._debug(\"Accounts.onEnrollmentLink was called more than once. \" + \"Only one callback added will be executed.\");\n  }\n\n  this._accountsCallbacks[\"enroll-account\"] = callback;\n};","ast":null,"map":{"version":3,"sources":["/packages/accounts-base/url_client.js"],"names":[],"mappings":"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","file":"/packages/accounts-base/url_client.js.map","sourcesContent":["import {AccountsClient} from \"./accounts_client.js\";\n\nvar Ap = AccountsClient.prototype;\n\n// All of the special hash URLs we support for accounts interactions\nvar accountsPaths = [\"reset-password\", \"verify-email\", \"enroll-account\"];\n\nvar savedHash = window.location.hash;\n\nAp._initUrlMatching = function () {\n  // By default, allow the autologin process to happen.\n  this._autoLoginEnabled = true;\n\n  // We only support one callback per URL.\n  this._accountsCallbacks = {};\n\n  // Try to match the saved value of window.location.hash.\n  this._attemptToMatchHash();\n};\n\n// Separate out this functionality for testing\n\nAp._attemptToMatchHash = function () {\n  attemptToMatchHash(this, savedHash, defaultSuccessHandler);\n};\n\n// Note that both arguments are optional and are currently only passed by\n// accounts_url_tests.js.\nfunction attemptToMatchHash(accounts, hash, success) {\n  _.each(accountsPaths, function (urlPart) {\n    var token;\n\n    var tokenRegex = new RegExp(\"^\\\\#\\\\/\" + urlPart + \"\\\\/(.*)$\");\n    var match = hash.match(tokenRegex);\n\n    if (match) {\n      token = match[1];\n\n      // XXX COMPAT WITH 0.9.3\n      if (urlPart === \"reset-password\") {\n        accounts._resetPasswordToken = token;\n      } else if (urlPart === \"verify-email\") {\n        accounts._verifyEmailToken = token;\n      } else if (urlPart === \"enroll-account\") {\n        accounts._enrollAccountToken = token;\n      }\n    } else {\n      return;\n    }\n\n    // If no handlers match the hash, then maybe it's meant to be consumed\n    // by some entirely different code, so we only clear it the first time\n    // a handler successfully matches. Note that later handlers reuse the\n    // savedHash, so clearing window.location.hash here will not interfere\n    // with their needs.\n    window.location.hash = \"\";\n\n    // Do some stuff with the token we matched\n    success.call(accounts, token, urlPart);\n  });\n}\n\nfunction defaultSuccessHandler(token, urlPart) {\n  var self = this;\n\n  // put login in a suspended state to wait for the interaction to finish\n  self._autoLoginEnabled = false;\n\n  // wait for other packages to register callbacks\n  Meteor.startup(function () {\n    // if a callback has been registered for this kind of token, call it\n    if (self._accountsCallbacks[urlPart]) {\n      self._accountsCallbacks[urlPart](token, function () {\n        self._enableAutoLogin();\n      });\n    }\n  });\n}\n\n// Export for testing\nexport var AccountsTest = {\n  attemptToMatchHash: function (hash, success) {\n    return attemptToMatchHash(Accounts, hash, success);\n  }\n};\n\n// XXX these should be moved to accounts-password eventually. Right now\n// this is prevented by the need to set autoLoginEnabled=false, but in\n// some bright future we won't need to do that anymore.\n\n/**\n * @summary Register a function to call when a reset password link is clicked\n * in an email sent by\n * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @memberof! Accounts\n * @name onResetPasswordLink\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: A password reset token that can be passed to\n * [`Accounts.resetPassword`](#accounts_resetpassword).\n * 2. `done`: A function to call when the password reset UI flow is complete. The normal\n * login process is suspended until this function is called, so that the\n * password for user A can be reset even if user B was logged in.\n * @locus Client\n */\nAp.onResetPasswordLink = function (callback) {\n  if (this._accountsCallbacks[\"reset-password\"]) {\n    Meteor._debug(\"Accounts.onResetPasswordLink was called more than once. \" +\n      \"Only one callback added will be executed.\");\n  }\n\n  this._accountsCallbacks[\"reset-password\"] = callback;\n};\n\n/**\n * @summary Register a function to call when an email verification link is\n * clicked in an email sent by\n * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @memberof! Accounts\n * @name onEmailVerificationLink\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: An email verification token that can be passed to\n * [`Accounts.verifyEmail`](#accounts_verifyemail).\n * 2. `done`: A function to call when the email verification UI flow is complete.\n * The normal login process is suspended until this function is called, so\n * that the user can be notified that they are verifying their email before\n * being logged in.\n * @locus Client\n */\nAp.onEmailVerificationLink = function (callback) {\n  if (this._accountsCallbacks[\"verify-email\"]) {\n    Meteor._debug(\"Accounts.onEmailVerificationLink was called more than once. \" +\n      \"Only one callback added will be executed.\");\n  }\n\n  this._accountsCallbacks[\"verify-email\"] = callback;\n};\n\n/**\n * @summary Register a function to call when an account enrollment link is\n * clicked in an email sent by\n * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @memberof! Accounts\n * @name onEnrollmentLink\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: A password reset token that can be passed to\n * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\n * enrolled account a password.\n * 2. `done`: A function to call when the enrollment UI flow is complete.\n * The normal login process is suspended until this function is called, so that\n * user A can be enrolled even if user B was logged in.\n * @locus Client\n */\nAp.onEnrollmentLink = function (callback) {\n  if (this._accountsCallbacks[\"enroll-account\"]) {\n    Meteor._debug(\"Accounts.onEnrollmentLink was called more than once. \" +\n      \"Only one callback added will be executed.\");\n  }\n\n  this._accountsCallbacks[\"enroll-account\"] = callback;\n};\n"]},"hash":"a152e32e830e080c8739b17e2934b839eb313ea0"}
