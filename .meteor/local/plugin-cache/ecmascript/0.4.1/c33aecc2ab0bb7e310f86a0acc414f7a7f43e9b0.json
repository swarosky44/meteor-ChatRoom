{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/crossbar_tests.js","filenameRelative":"/packages/ddp-server/crossbar_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/crossbar_tests.js.map","sourceFileName":"/packages/ddp-server/crossbar_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"crossbar_tests"},"ignored":false,"code":"// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar();\n  test.isTrue(crossbar._matches({ collection: \"C\" }, { collection: \"C\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\" }, { collection: \"C\", id: \"X\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\" }));\n\n  test.isFalse(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\", id: \"Y\" }));\n\n  // Test that stopped listens definitely don't fire.\n  var calledFirst = false;\n  var calledSecond = false;\n  var trigger = { collection: \"C\" };\n  var secondHandle;\n  crossbar.listen(trigger, function (notification) {\n    // This test assumes that listeners will be called in the order\n    // registered. It's not wrong for the crossbar to do something different,\n    // but the test won't be valid in that case, so make it fail so we notice.\n    calledFirst = true;\n    if (calledSecond) {\n      test.fail({\n        type: \"test_assumption_failed\",\n        message: \"test assumed that listeners would be called in the order registered\"\n      });\n    } else {\n      secondHandle.stop();\n    }\n  });\n  secondHandle = crossbar.listen(trigger, function (notification) {\n    // This should not get invoked, because it should be stopped by the other\n    // listener!\n    calledSecond = true;\n  });\n  crossbar.fire(trigger);\n  test.isTrue(calledFirst);\n  test.isFalse(calledSecond);\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/crossbar_tests.js"],"names":[],"mappings":";;;;;;;AAOA,SAAS,GAAT,CAAa,qBAAb,EAAoC,UAAU,IAAV,EAAgB;AAClD,MAAI,WAAW,IAAI,UAAU,SAAV,EAAf,CAD8C;AAElD,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAZ,EAAnB,EACkB,EAAC,YAAY,GAAZ,EADnB,CAAZ,EAFkD;AAIlD,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAZ,EAAiB,IAAI,GAAJ,EAApC,EACkB,EAAC,YAAY,GAAZ,EADnB,CAAZ,EAJkD;AAMlD,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAZ,EAAnB,EACkB,EAAC,YAAY,GAAZ,EAAiB,IAAI,GAAJ,EADpC,CAAZ,EANkD;AAQlD,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAZ,EAAiB,IAAI,GAAJ,EAApC,EACkB,EAAC,YAAY,GAAZ,EADnB,CAAZ,EARkD;;AAWlD,OAAK,OAAL,CAAa,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAZ,EAAiB,IAAI,GAAJ,EAApC,EACkB,EAAC,YAAY,GAAZ,EAAiB,IAAI,GAAJ,EADpC,CAAb;;;AAXkD,MAe9C,cAAc,KAAd,CAf8C;AAgBlD,MAAI,eAAe,KAAf,CAhB8C;AAiBlD,MAAI,UAAU,EAAC,YAAY,GAAZ,EAAX,CAjB8C;AAkBlD,MAAI,YAAJ,CAlBkD;AAmBlD,WAAS,MAAT,CAAgB,OAAhB,EAAyB,UAAU,YAAV,EAAwB;;;;AAI/C,kBAAc,IAAd,CAJ+C;AAK/C,QAAI,YAAJ,EAAkB;AAChB,WAAK,IAAL,CAAU;AACR,cAAM,wBAAN;AACA,iBAAS,qEAAT;OAFF,EADgB;KAAlB,MAKO;AACL,mBAAa,IAAb,GADK;KALP;GALuB,CAAzB,CAnBkD;AAiClD,iBAAe,SAAS,MAAT,CAAgB,OAAhB,EAAyB,UAAU,YAAV,EAAwB;;;AAG9D,mBAAe,IAAf,CAH8D;GAAxB,CAAxC,CAjCkD;AAsClD,WAAS,IAAT,CAAc,OAAd,EAtCkD;AAuClD,OAAK,MAAL,CAAY,WAAZ,EAvCkD;AAwClD,OAAK,OAAL,CAAa,YAAb,EAxCkD;CAAhB,CAApC","file":"/packages/ddp-server/crossbar_tests.js.map","sourcesContent":["// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar;\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\", id: \"X\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n\n  test.isFalse(crossbar._matches({collection: \"C\", id: \"X\"},\n                                 {collection: \"C\", id: \"Y\"}));\n\n  // Test that stopped listens definitely don't fire.\n  var calledFirst = false;\n  var calledSecond = false;\n  var trigger = {collection: \"C\"};\n  var secondHandle;\n  crossbar.listen(trigger, function (notification) {\n    // This test assumes that listeners will be called in the order\n    // registered. It's not wrong for the crossbar to do something different,\n    // but the test won't be valid in that case, so make it fail so we notice.\n    calledFirst = true;\n    if (calledSecond) {\n      test.fail({\n        type: \"test_assumption_failed\",\n        message: \"test assumed that listeners would be called in the order registered\"\n      });\n    } else {\n      secondHandle.stop();\n    }\n  });\n  secondHandle = crossbar.listen(trigger, function (notification) {\n    // This should not get invoked, because it should be stopped by the other\n    // listener!\n    calledSecond = true;\n  });\n  crossbar.fire(trigger);\n  test.isTrue(calledFirst);\n  test.isFalse(calledSecond);\n});\n"]},"hash":"c33aecc2ab0bb7e310f86a0acc414f7a7f43e9b0"}
