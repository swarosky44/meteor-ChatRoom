{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/http/httpcall_server.js","filenameRelative":"/packages/http/httpcall_server.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/http/httpcall_server.js.map","sourceFileName":"/packages/http/httpcall_server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"httpcall_server"},"ignored":false,"code":"var path = Npm.require('path');\nvar request = Npm.require('request');\nvar url_util = Npm.require('url');\n\nHTTPInternals = {\n  NpmModules: {\n    request: {\n      version: Npm.require('request/package.json').version,\n      module: request\n    }\n  }\n};\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nvar _call = function _call(method, url, options, callback) {\n\n  ////////// Process arguments //////////\n\n  if (!callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (_.has(options, 'beforeSend')) {\n    throw new Error(\"Option beforeSend not supported on server.\");\n  }\n\n  method = (method || \"\").toUpperCase();\n\n  if (!/^https?:\\/\\//.test(url)) throw new Error(\"url must be absolute and start with http:// or https://\");\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  var paramsForUrl, paramsForBody;\n  if (content || method === \"GET\" || method === \"HEAD\") paramsForUrl = options.params;else paramsForBody = options.params;\n\n  var newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0) throw new Error('auth option should be of the form \"username:password\"');\n    headers['Authorization'] = \"Basic \" + new Buffer(options.auth, \"ascii\").toString(\"base64\");\n  }\n\n  if (paramsForBody) {\n    content = URL._encodeParams(paramsForBody);\n    headers['Content-Type'] = \"application/x-www-form-urlencoded\";\n  }\n\n  _.extend(headers, options.headers || {});\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = function (callback) {\n    return function (error, response) {\n      if (error && response) error.response = response;\n      callback(error, response);\n    };\n  }(callback);\n\n  // safety belt: only call the callback once.\n  callback = _.once(callback);\n\n  ////////// Kickoff! //////////\n\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n  var reqOptions = _.extend({\n    url: newUrl,\n    method: method,\n    encoding: \"utf8\",\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    followRedirect: options.followRedirects,\n    // Follow redirects on non-GET requests\n    // also. (https://github.com/meteor/meteor/issues/2808)\n    followAllRedirects: options.followRedirects,\n    headers: headers\n  }, options.npmRequestOptions || {});\n\n  request(reqOptions, function (error, res, body) {\n    var response = null;\n\n    if (!error) {\n\n      response = {};\n      response.statusCode = res.statusCode;\n      response.content = body;\n      response.headers = res.headers;\n\n      populateData(response);\n\n      if (response.statusCode >= 400) error = makeErrorByStatus(response.statusCode, response.content);\n    }\n\n    callback(error, response);\n  });\n};\n\nHTTP.call = Meteor.wrapAsync(_call);","ast":null,"map":{"version":3,"sources":["/packages/http/httpcall_server.js"],"names":[],"mappings":"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","file":"/packages/http/httpcall_server.js.map","sourcesContent":["var path = Npm.require('path');\nvar request = Npm.require('request');\nvar url_util = Npm.require('url');\n\nHTTPInternals = {\n  NpmModules: {\n    request: {\n      version: Npm.require('request/package.json').version,\n      module: request\n    }\n  }\n};\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nvar _call = function(method, url, options, callback) {\n\n  ////////// Process arguments //////////\n\n  if (! callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (_.has(options, 'beforeSend')) {\n    throw new Error(\"Option beforeSend not supported on server.\");\n  }\n\n  method = (method || \"\").toUpperCase();\n\n  if (! /^https?:\\/\\//.test(url))\n    throw new Error(\"url must be absolute and start with http:// or https://\");\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n\n  var paramsForUrl, paramsForBody;\n  if (content || method === \"GET\" || method === \"HEAD\")\n    paramsForUrl = options.params;\n  else\n    paramsForBody = options.params;\n\n  var newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    headers['Authorization'] = \"Basic \"+\n      (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n  }\n\n  if (paramsForBody) {\n    content = URL._encodeParams(paramsForBody);\n    headers['Content-Type'] = \"application/x-www-form-urlencoded\";\n  }\n\n  _.extend(headers, options.headers || {});\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function(callback) {\n    return function(error, response) {\n      if (error && response)\n        error.response = response;\n      callback(error, response);\n    };\n  })(callback);\n\n  // safety belt: only call the callback once.\n  callback = _.once(callback);\n\n\n  ////////// Kickoff! //////////\n\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n  var reqOptions = _.extend({\n    url: newUrl,\n    method: method,\n    encoding: \"utf8\",\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    followRedirect: options.followRedirects,\n    // Follow redirects on non-GET requests\n    // also. (https://github.com/meteor/meteor/issues/2808)\n    followAllRedirects: options.followRedirects,\n    headers: headers\n  }, options.npmRequestOptions || {});\n\n  request(reqOptions, function(error, res, body) {\n    var response = null;\n\n    if (! error) {\n\n      response = {};\n      response.statusCode = res.statusCode;\n      response.content = body;\n      response.headers = res.headers;\n\n      populateData(response);\n\n      if (response.statusCode >= 400)\n        error = makeErrorByStatus(response.statusCode, response.content);\n    }\n\n    callback(error, response);\n\n  });\n};\n\nHTTP.call = Meteor.wrapAsync(_call);\n"]},"hash":"d7140090a6ca37b69d9ab7b3b413a5b21c1d0fcf"}
