{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/livedata_server_tests.js","filenameRelative":"/packages/ddp-server/livedata_server_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/livedata_server_tests.js.map","sourceFileName":"/packages/ddp-server/livedata_server_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"livedata_server_tests"},"ignored":false,"code":"var Fiber = Npm.require('fibers');\n\nTinytest.addAsync(\"livedata server - connectionHandle.onClose()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // On the server side, wait for the connection to be closed.\n    serverConn.onClose(function () {\n      test.isTrue(true);\n      // Add a new onClose after the connection is already\n      // closed. See that it fires.\n      serverConn.onClose(function () {\n        onComplete();\n      });\n    });\n    // Close the connection from the client.\n    clientConn.disconnect();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connectionHandle.close()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Wait for the connection to be closed from the server side.\n    simplePoll(function () {\n      return !clientConn.status().connected;\n    }, onComplete, function () {\n      test.fail(\"timeout waiting for the connection to be closed on the server side\");\n      onComplete();\n    });\n\n    // Close the connection from the server.\n    serverConn.close();\n  }, onComplete);\n});\n\ntestAsyncMulti(\"livedata server - onConnection doesn't get callback after stop.\", [function (test, expect) {\n  var afterStop = false;\n  var expectStop1 = expect();\n  var stopHandle1 = Meteor.onConnection(function (conn) {\n    stopHandle2.stop();\n    stopHandle1.stop();\n    afterStop = true;\n    // yield to the event loop for a moment to see that no other calls\n    // to listener2 are called.\n    Meteor.setTimeout(expectStop1, 10);\n  });\n  var stopHandle2 = Meteor.onConnection(function (conn) {\n    test.isFalse(afterStop);\n  });\n\n  // trigger a connection\n  var expectConnection = expect();\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Close the connection from the client.\n    clientConn.disconnect();\n    expectConnection();\n  }, expectConnection);\n}]);\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    function livedata_server_test_inner() {\n      return this.connection.id;\n    }\n\n    return livedata_server_test_inner;\n  }(),\n\n  livedata_server_test_outer: function () {\n    function livedata_server_test_outer() {\n      return Meteor.call('livedata_server_test_inner');\n    }\n\n    return livedata_server_test_outer;\n  }()\n});\n\nTinytest.addAsync(\"livedata server - connection in method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_inner');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connection in nested method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_outer');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback) callback(this);\n  this.stop();\n});\n\nTinytest.addAsync(\"livedata server - connection in publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    onSubscription[serverConn.id] = function (subscription) {\n      delete onSubscription[serverConn.id];\n      test.equal(subscription.connection.id, serverConn.id);\n      clientConn.disconnect();\n      onComplete();\n    };\n    clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n  });\n});\n\nMeteor.methods({\n  testResolvedPromise: function () {\n    function testResolvedPromise(arg) {\n      var invocation1 = DDP._CurrentInvocation.get();\n      return new Promise.resolve(arg).then(function (result) {\n        var invocation2 = DDP._CurrentInvocation.get();\n        // This equality holds because Promise callbacks are bound to the\n        // dynamic environment where .then was called.\n        if (invocation1 !== invocation2) {\n          throw new Meteor.Error(\"invocation mismatch\");\n        }\n        return result + \" after waiting\";\n      });\n    }\n\n    return testResolvedPromise;\n  }(),\n  testRejectedPromise: function () {\n    function testRejectedPromise(arg) {\n      return new Promise.resolve(arg).then(function (result) {\n        throw new Meteor.Error(result + \" raised Meteor.Error\");\n      });\n    }\n\n    return testRejectedPromise;\n  }()\n});\n\nTinytest.addAsync(\"livedata server - waiting for Promise\", function (test, onComplete) {\n  return makeTestConnection(test, function (clientConn, serverConn) {\n    test.equal(clientConn.call(\"testResolvedPromise\", \"clientConn.call\"), \"clientConn.call after waiting\");\n\n    var clientCallPromise = new Promise(function (resolve, reject) {\n      return clientConn.call(\"testResolvedPromise\", \"clientConn.call with callback\", function (error, result) {\n        return error ? reject(error) : resolve(result);\n      });\n    });\n\n    var clientCallRejectedPromise = new Promise(function (resolve) {\n      clientConn.call(\"testRejectedPromise\", \"with callback\", function (error, result) {\n        return resolve(error.message);\n      });\n    });\n\n    Promise.all([clientCallPromise, clientCallRejectedPromise]).then(function (results) {\n      return test.equal(results, [\"clientConn.call with callback after waiting\", \"[with callback raised Meteor.Error]\"]);\n    }, function (error) {\n      return test.fail(error);\n    }).then(onComplete);\n  });\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/livedata_server_tests.js"],"names":[],"mappings":"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","file":"/packages/ddp-server/livedata_server_tests.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.onClose()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // On the server side, wait for the connection to be closed.\n        serverConn.onClose(function () {\n          test.isTrue(true);\n          // Add a new onClose after the connection is already\n          // closed. See that it fires.\n          serverConn.onClose(function () {\n            onComplete();\n          });\n        });\n        // Close the connection from the client.\n        clientConn.disconnect();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.close()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Wait for the connection to be closed from the server side.\n        simplePoll(\n          function () {\n            return ! clientConn.status().connected;\n          },\n          onComplete,\n          function () {\n            test.fail(\"timeout waiting for the connection to be closed on the server side\");\n            onComplete();\n          }\n        );\n\n        // Close the connection from the server.\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\n\ntestAsyncMulti(\n  \"livedata server - onConnection doesn't get callback after stop.\",\n  [function (test, expect) {\n    var afterStop = false;\n    var expectStop1 = expect();\n    var stopHandle1 = Meteor.onConnection(function (conn) {\n      stopHandle2.stop();\n      stopHandle1.stop();\n      afterStop = true;\n      // yield to the event loop for a moment to see that no other calls\n      // to listener2 are called.\n      Meteor.setTimeout(expectStop1, 10);\n    });\n    var stopHandle2 = Meteor.onConnection(function (conn) {\n      test.isFalse(afterStop);\n    });\n\n    // trigger a connection\n    var expectConnection = expect();\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Close the connection from the client.\n        clientConn.disconnect();\n        expectConnection();\n      },\n      expectConnection\n    );\n  }]\n);\n\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_inner');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in nested method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_outer');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback)\n    callback(this);\n  this.stop();\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (subscription) {\n          delete onSubscription[serverConn.id];\n          test.equal(subscription.connection.id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n      }\n    );\n  }\n);\n\nMeteor.methods({\n  testResolvedPromise(arg) {\n    const invocation1 = DDP._CurrentInvocation.get();\n    return new Promise.resolve(arg).then(result => {\n      const invocation2 = DDP._CurrentInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise(arg) {\n    return new Promise.resolve(arg).then(result => {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  }\n});\n\nTinytest.addAsync(\n  \"livedata server - waiting for Promise\",\n  (test, onComplete) => makeTestConnection(test, (clientConn, serverConn) => {\n    test.equal(\n      clientConn.call(\"testResolvedPromise\", \"clientConn.call\"),\n      \"clientConn.call after waiting\"\n    );\n\n    const clientCallPromise = new Promise(\n      (resolve, reject) => clientConn.call(\n        \"testResolvedPromise\",\n        \"clientConn.call with callback\",\n        (error, result) => error ? reject(error) : resolve(result)\n      )\n    );\n\n    const clientCallRejectedPromise = new Promise(resolve => {\n      clientConn.call(\n        \"testRejectedPromise\",\n        \"with callback\",\n        (error, result) => resolve(error.message)\n      );\n    });\n\n    Promise.all([\n      clientCallPromise,\n      clientCallRejectedPromise,\n    ]).then(results => test.equal(results, [\n      \"clientConn.call with callback after waiting\",\n      \"[with callback raised Meteor.Error]\",\n    ]), error => test.fail(error))\n      .then(onComplete);\n  })\n);\n"]},"hash":"e7c9ca35126846df4c421a7f721bc1d82d924009"}
