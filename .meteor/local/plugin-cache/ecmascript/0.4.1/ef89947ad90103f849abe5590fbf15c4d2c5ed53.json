{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./accounts_common.js","imported":["AccountsCommon"],"specifiers":[{"kind":"named","imported":"AccountsCommon","local":"AccountsCommon"}]}],"exports":{"exported":["AccountsClient"],"specifiers":[{"kind":"local","local":"AccountsClient","exported":"AccountsClient"}]}}},"options":{"filename":"/packages/accounts-base/accounts_client.js","filenameRelative":"/packages/accounts-base/accounts_client.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/accounts_client.js.map","sourceFileName":"/packages/accounts-base/accounts_client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"accounts_client"},"ignored":false,"code":"exports.__esModule = true;\nexports.AccountsClient = undefined;\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _accounts_common = require(\"./accounts_common.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class AccountsClient\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\n\nvar AccountsClient = exports.AccountsClient = function (_AccountsCommon) {\n  (0, _inherits3[\"default\"])(AccountsClient, _AccountsCommon);\n\n  function AccountsClient(options) {\n    (0, _classCallCheck3[\"default\"])(this, AccountsClient);\n\n    var _this = (0, _possibleConstructorReturn3[\"default\"])(this, _AccountsCommon.call(this, options));\n\n    _this._loggingIn = false;\n    _this._loggingInDeps = new Tracker.Dependency();\n\n    _this._loginServicesHandle = _this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    _this._pageLoadLoginCallbacks = [];\n    _this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    _this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    _this._initLocalStorage();\n    return _this;\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n\n\n  AccountsClient.prototype.userId = function () {\n    function userId() {\n      return this.connection.userId();\n    }\n\n    return userId;\n  }();\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n\n\n  AccountsClient.prototype._setLoggingIn = function () {\n    function _setLoggingIn(x) {\n      if (this._loggingIn !== x) {\n        this._loggingIn = x;\n        this._loggingInDeps.changed();\n      }\n    }\n\n    return _setLoggingIn;\n  }();\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n\n\n  AccountsClient.prototype.loggingIn = function () {\n    function loggingIn() {\n      this._loggingInDeps.depend();\n      return this._loggingIn;\n    }\n\n    return loggingIn;\n  }();\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n\n\n  AccountsClient.prototype.logout = function () {\n    function logout(callback) {\n      var self = this;\n      self.connection.apply('logout', [], {\n        wait: true\n      }, function (error, result) {\n        if (error) {\n          callback && callback(error);\n        } else {\n          self.makeClientLoggedOut();\n          callback && callback();\n        }\n      });\n    }\n\n    return logout;\n  }();\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n\n\n  AccountsClient.prototype.logoutOtherClients = function () {\n    function logoutOtherClients(callback) {\n      var self = this;\n\n      // We need to make two method calls: one to replace our current token,\n      // and another to remove all tokens except the current one. We want to\n      // call these two methods one after the other, without any other\n      // methods running between them. For example, we don't want `logout`\n      // to be called in between our two method calls (otherwise the second\n      // method call would return an error). Another example: we don't want\n      // logout to be called before the callback for `getNewToken`;\n      // otherwise we would momentarily log the user out and then write a\n      // new token to localStorage.\n      //\n      // To accomplish this, we make both calls as wait methods, and queue\n      // them one after the other, without spinning off the event loop in\n      // between. Even though we queue `removeOtherTokens` before\n      // `getNewToken`, we won't actually send the `removeOtherTokens` call\n      // until the `getNewToken` callback has finished running, because they\n      // are both wait methods.\n      self.connection.apply('getNewToken', [], { wait: true }, function (err, result) {\n        if (!err) {\n          self._storeLoginToken(self.userId(), result.token, result.tokenExpires);\n        }\n      });\n\n      self.connection.apply('removeOtherTokens', [], { wait: true }, function (err) {\n        callback && callback(err);\n      });\n    }\n\n    return logoutOtherClients;\n  }();\n\n  return AccountsClient;\n}(_accounts_common.AccountsCommon);\n\n;\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f]) options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function onResultReceived(err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n        self.connection.onReconnect = function () {\n          reconnected = true;\n          // If our token was updated in storage, use the latest one.\n          var storedToken = self._storedLoginToken();\n          if (storedToken) {\n            result = {\n              token: storedToken,\n              tokenExpires: self._storedLoginTokenExpires()\n            };\n          }\n          if (!result.tokenExpires) result.tokenExpires = self._tokenExpiration(new Date());\n          if (self._tokenExpiresSoon(result.tokenExpires)) {\n            self.makeClientLoggedOut();\n          } else {\n            self.callLoginMethod({\n              methodArguments: [{ resume: result.token }],\n              // Reconnect quiescence ensures that the user doesn't see an\n              // intermediate state before the login method finishes. So we don't\n              // need to show a logging-in animation.\n              _suppressLoggingIn: true,\n              userCallback: function () {\n                function userCallback(error) {\n                  var storedTokenNow = self._storedLoginToken();\n                  if (error) {\n                    // If we had a login error AND the current stored token is the\n                    // one that we tried to log in with, then declare ourselves\n                    // logged out. If there's a token in storage but it's not the\n                    // token that we tried to log in with, we don't know anything\n                    // about whether that token is valid or not, so do nothing. The\n                    // periodic localStorage poll will decide if we are logged in or\n                    // out with this token, if it hasn't already. Of course, even\n                    // with this check, another tab could insert a new valid token\n                    // immediately before we clear localStorage here, which would\n                    // lead to both tabs being logged out, but by checking the token\n                    // in storage right now we hope to make that unlikely to happen.\n                    //\n                    // If there is no token in storage right now, we don't have to\n                    // do anything; whatever code removed the token from storage was\n                    // responsible for calling `makeClientLoggedOut()`, or the\n                    // periodic localStorage poll will call `makeClientLoggedOut`\n                    // eventually if another tab wiped the token from storage.\n                    if (storedTokenNow && storedTokenNow === result.token) {\n                      self.makeClientLoggedOut();\n                    }\n                  }\n                  // Possibly a weird callback to call, but better than nothing if\n                  // there is a reconnect between \"login result received\" and \"data\n                  // ready\".\n                  loginCallbacks(error);\n                }\n\n                return userCallback;\n              }() });\n          }\n        };\n      }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function loggedInAndDataReadyCallback(error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected) return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn) self._setLoggingIn(true);\n  self.connection.apply(options.methodName, options.methodArguments, { wait: true, onResultReceived: onResultReceived }, loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}","ast":null,"map":{"version":3,"sources":["/packages/accounts-base/accounts_client.js"],"names":[],"mappings":"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","file":"/packages/accounts-base/accounts_client.js.map","sourcesContent":["import {AccountsCommon} from \"./accounts_common.js\";\n\n/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class AccountsClient\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nexport class AccountsClient extends AccountsCommon {\n  constructor(options) {\n    super(options);\n\n    this._loggingIn = false;\n    this._loggingInDeps = new Tracker.Dependency;\n\n    this._loginServicesHandle =\n      this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    this._initLocalStorage();\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n  userId() {\n    return this.connection.userId();\n  }\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n  _setLoggingIn(x) {\n    if (this._loggingIn !== x) {\n      this._loggingIn = x;\n      this._loggingInDeps.changed();\n    }\n  }\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingIn() {\n    this._loggingInDeps.depend();\n    return this._loggingIn;\n  }\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logout(callback) {\n    var self = this;\n    self.connection.apply('logout', [], {\n      wait: true\n    }, function (error, result) {\n      if (error) {\n        callback && callback(error);\n      } else {\n        self.makeClientLoggedOut();\n        callback && callback();\n      }\n    });\n  }\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logoutOtherClients(callback) {\n    var self = this;\n\n    // We need to make two method calls: one to replace our current token,\n    // and another to remove all tokens except the current one. We want to\n    // call these two methods one after the other, without any other\n    // methods running between them. For example, we don't want `logout`\n    // to be called in between our two method calls (otherwise the second\n    // method call would return an error). Another example: we don't want\n    // logout to be called before the callback for `getNewToken`;\n    // otherwise we would momentarily log the user out and then write a\n    // new token to localStorage.\n    //\n    // To accomplish this, we make both calls as wait methods, and queue\n    // them one after the other, without spinning off the event loop in\n    // between. Even though we queue `removeOtherTokens` before\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\n    // until the `getNewToken` callback has finished running, because they\n    // are both wait methods.\n    self.connection.apply(\n      'getNewToken',\n      [],\n      { wait: true },\n      function (err, result) {\n        if (! err) {\n          self._storeLoginToken(\n            self.userId(),\n            result.token,\n            result.tokenExpires\n          );\n        }\n      }\n    );\n\n    self.connection.apply(\n      'removeOtherTokens',\n      [],\n      { wait: true },\n      function (err) {\n        callback && callback(err);\n      }\n    );\n  }\n};\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n      self.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = self._storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: self._storedLoginTokenExpires()\n          };\n        }\n        if (! result.tokenExpires)\n          result.tokenExpires = self._tokenExpiration(new Date());\n        if (self._tokenExpiresSoon(result.tokenExpires)) {\n          self.makeClientLoggedOut();\n        } else {\n          self.callLoginMethod({\n            methodArguments: [{resume: result.token}],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = self._storedLoginToken();\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  self.makeClientLoggedOut();\n                }\n              }\n              // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n              loginCallbacks(error);\n            }});\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn)\n    self._setLoggingIn(true);\n  self.connection.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}\n"]},"hash":"ef89947ad90103f849abe5590fbf15c4d2c5ed53"}
