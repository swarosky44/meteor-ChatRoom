{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/mongo","imported":["Mongo"],"specifiers":[{"kind":"named","imported":"Mongo","local":"Mongo"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]}],"exports":{"exported":["Tasks"],"specifiers":[{"kind":"local","local":"Tasks","exported":"Tasks"}]}}},"options":{"filename":"/imports/api/tasks.js","filenameRelative":"/imports/api/tasks.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/api/tasks.js.map","sourceFileName":"/imports/api/tasks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"tasks"},"ignored":false,"code":"exports.__esModule = true;\nexports.Tasks = undefined;\n\nvar _meteor = require('meteor/meteor');\n\nvar _mongo = require('meteor/mongo');\n\nvar _check = require('meteor/check');\n\nvar Tasks = exports.Tasks = new _mongo.Mongo.Collection('tasks');\nif (_meteor.Meteor.isServer) {\n  // This code only runs on the server\n  // Only return public tasks and private tasks belong to owner\n  _meteor.Meteor.publish('tasks', function () {\n    function tasksPublication() {\n      return Tasks.find({\n        $or: [{ 'private': { $ne: true } }, { owner: this.userId }]\n      });\n    }\n\n    return tasksPublication;\n  }());\n}\n_meteor.Meteor.methods({\n  'tasks.insert': function () {\n    function tasksInsert(text) {\n      (0, _check.check)(text, String);\n\n      // Make sure the user is logged in before inserting a task\n      if (!_meteor.Meteor.userId()) {\n        throw new _meteor.Meteor.Error('not-authorized');\n      }\n\n      Tasks.insert({\n        text: text,\n        createdAt: new Date(),\n        owner: _meteor.Meteor.userId(),\n        username: _meteor.Meteor.user().username\n      });\n    }\n\n    return tasksInsert;\n  }(),\n  'tasks.remove': function () {\n    function tasksRemove(taskId) {\n      (0, _check.check)(taskId, String);\n\n      var task = Tasks.findOne(taskId);\n      if (task['private'] && task.owner !== _meteor.Meteor.userId()) {\n        // If the task is private, make sure only the owner can delete it\n        throw new _meteor.Meteor.Error('not-authorized');\n      }\n\n      Tasks.remove(taskId);\n    }\n\n    return tasksRemove;\n  }(),\n  'tasks.setChecked': function () {\n    function tasksSetChecked(taskId, setChecked) {\n      (0, _check.check)(taskId, String);\n      (0, _check.check)(setChecked, Boolean);\n      var task = Tasks.findOne(taskId);\n      if (task['private'] && task.owner !== _meteor.Meteor.userId()) {\n        // If the task is private, make sure only the owner can check it off\n        throw new _meteor.Meteor.Error('not-authorized');\n      }\n      Tasks.update(taskId, { $set: { checked: setChecked } });\n    }\n\n    return tasksSetChecked;\n  }(),\n  'tasks.setPrivate': function () {\n    function tasksSetPrivate(taskId, setToPrivate) {\n      (0, _check.check)(taskId, String);\n      (0, _check.check)(setToPrivate, Boolean);\n\n      var task = Tasks.findOne(taskId);\n\n      // Make sure only the task owner can make a task private\n      if (task.owner !== _meteor.Meteor.userId()) {\n        throw new _meteor.Meteor.Error('not-authorized');\n      }\n\n      Tasks.update(taskId, { $set: { 'private': setToPrivate } });\n    }\n\n    return tasksSetPrivate;\n  }()\n});","ast":null,"map":{"version":3,"sources":["/imports/api/tasks.js"],"names":[],"mappings":";;;AAAA;;AACA;;AACA;;AAEO,IAAM,wBAAQ,IAAI,aAAM,UAAN,CAAiB,OAArB,CAAR;AACb,IAAI,eAAO,QAAP,EAAiB;;;AAGnB,iBAAO,OAAP,CAAe,OAAf;AAAwB,aAAS,gBAAT,GAA4B;AAClD,aAAO,MAAM,IAAN,CAAW;AAChB,aAAK,CACH,EAAE,WAAS,EAAE,KAAK,IAAL,EAAX,EADC,EAEH,EAAE,OAAO,KAAK,MAAL,EAFN,CAAL;OADK,CAAP,CADkD;KAA5B;;WAAS;KAAjC,EAHmB;CAArB;AAYA,eAAO,OAAP,CAAe;AACb;yBAAe,MAAM;AACnB,wBAAM,IAAN,EAAY,MAAZ;;;AADmB,UAIf,CAAE,eAAO,MAAP,EAAF,EAAmB;AACrB,cAAM,IAAI,eAAO,KAAP,CAAa,gBAAjB,CAAN,CADqB;OAAvB;;AAIA,YAAM,MAAN,CAAa;AACX,kBADW;AAEX,mBAAW,IAAI,IAAJ,EAAX;AACA,eAAO,eAAO,MAAP,EAAP;AACA,kBAAU,eAAO,IAAP,GAAc,QAAd;OAJZ,EARmB;;;;KADR;AAgBb;yBAAe,QAAQ;AACrB,wBAAM,MAAN,EAAc,MAAd,EADqB;;AAGrB,UAAM,OAAO,MAAM,OAAN,CAAc,MAAd,CAAP,CAHe;AAIrB,UAAI,mBAAgB,KAAK,KAAL,KAAe,eAAO,MAAP,EAAf,EAAgC;;AAElD,cAAM,IAAI,eAAO,KAAP,CAAa,gBAAjB,CAAN,CAFkD;OAApD;;AAKA,YAAM,MAAN,CAAa,MAAb,EATqB;;;;KAhBV;AA2Bb;6BAAmB,QAAQ,YAAY;AACrC,wBAAM,MAAN,EAAc,MAAd,EADqC;AAErC,wBAAM,UAAN,EAAkB,OAAlB,EAFqC;AAGrC,UAAM,OAAO,MAAM,OAAN,CAAc,MAAd,CAAP,CAH+B;AAIrC,UAAI,mBAAgB,KAAK,KAAL,KAAe,eAAO,MAAP,EAAf,EAAgC;;AAElD,cAAM,IAAI,eAAO,KAAP,CAAa,gBAAjB,CAAN,CAFkD;OAApD;AAIA,YAAM,MAAN,CAAa,MAAb,EAAqB,EAAE,MAAM,EAAE,SAAS,UAAT,EAAR,EAAvB,EARqC;;;;KA3B1B;AAqCb;6BAAmB,QAAQ,cAAc;AACvC,wBAAM,MAAN,EAAc,MAAd,EADuC;AAEvC,wBAAM,YAAN,EAAoB,OAApB,EAFuC;;AAIvC,UAAM,OAAO,MAAM,OAAN,CAAc,MAAd,CAAP;;;AAJiC,UAOnC,KAAK,KAAL,KAAe,eAAO,MAAP,EAAf,EAAgC;AAClC,cAAM,IAAI,eAAO,KAAP,CAAa,gBAAjB,CAAN,CADkC;OAApC;;AAIA,YAAM,MAAN,CAAa,MAAb,EAAqB,EAAE,MAAM,EAAE,WAAS,YAAT,EAAR,EAAvB,EAXuC;;;;KArC5B;CAAf","file":"/imports/api/tasks.js.map","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Mongo } from 'meteor/mongo';\nimport { check } from 'meteor/check';\n \nexport const Tasks = new Mongo.Collection('tasks');\nif (Meteor.isServer) {\n  // This code only runs on the server\n  // Only return public tasks and private tasks belong to owner\n  Meteor.publish('tasks', function tasksPublication() {\n    return Tasks.find({\n      $or: [\n        { private: { $ne: true } },\n        { owner: this.userId },\n      ],\n    });\n  });\n} \nMeteor.methods({\n  'tasks.insert'(text) {\n    check(text, String);\n \n    // Make sure the user is logged in before inserting a task\n    if (! Meteor.userId()) {\n      throw new Meteor.Error('not-authorized');\n    }\n \n    Tasks.insert({\n      text,\n      createdAt: new Date(),\n      owner: Meteor.userId(),\n      username: Meteor.user().username,\n    });\n  },\n  'tasks.remove'(taskId) {\n    check(taskId, String);\n\n    const task = Tasks.findOne(taskId);\n    if (task.private && task.owner !== Meteor.userId()) {\n      // If the task is private, make sure only the owner can delete it\n      throw new Meteor.Error('not-authorized');\n    }\n\n    Tasks.remove(taskId);\n  },\n  'tasks.setChecked'(taskId, setChecked) {\n    check(taskId, String);\n    check(setChecked, Boolean);\n    const task = Tasks.findOne(taskId);\n    if (task.private && task.owner !== Meteor.userId()) {\n      // If the task is private, make sure only the owner can check it off\n      throw new Meteor.Error('not-authorized');\n    }\n    Tasks.update(taskId, { $set: { checked: setChecked } });\n  },\n  'tasks.setPrivate'(taskId, setToPrivate) {\n    check(taskId, String);\n    check(setToPrivate, Boolean);\n \n    const task = Tasks.findOne(taskId);\n \n    // Make sure only the task owner can make a task private\n    if (task.owner !== Meteor.userId()) {\n      throw new Meteor.Error('not-authorized');\n    }\n \n    Tasks.update(taskId, { $set: { private: setToPrivate } });\n  },\n});"]},"hash":"f5aabc641860139bfef08b63b79ac514a31164a7"}
